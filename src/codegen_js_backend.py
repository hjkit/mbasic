#!/usr/bin/env python3
"""
JavaScript Code Generation Backend

Generates JavaScript code from BASIC programs that runs in:
- Browser (via <script> tag or standalone HTML)
- Node.js (command-line execution)

Generated code uses a switch-based control flow system for GOTO/GOSUB.
"""

from typing import List, Dict, Set, Optional, Any
from src.ast_nodes import *
from src.semantic_analyzer import SymbolTable, VarType
from src.codegen_backend import CodeGenBackend


class JavaScriptBackend(CodeGenBackend):
    """
    JavaScript code generator for browser and Node.js execution.

    Features:
    - Switch-based control flow (PC variable)
    - Variable-indexed FOR loops
    - Built-in BASIC functions
    - Environment detection (browser vs Node.js)
    - Self-contained runtime
    """

    def __init__(self, symbols: SymbolTable, config: Optional[Dict[str, Any]] = None):
        super().__init__(symbols)
        self.indent_level = 0
        self.line_labels: Set[int] = set()  # Line numbers that need case statements
        self.next_line_map: Dict[int, Optional[int]] = {}  # Map line -> next line
        self.config = config or {}

        # Track what features are used
        self.uses_input = False
        self.uses_gosub = False
        self.uses_data = False
        self.uses_random = False

        # DATA/READ/RESTORE support
        self.data_values: List[Any] = []
        self.data_types: List[str] = []  # 'number' or 'string'

        # DEF FN functions
        self.def_fn_functions: List[DefFnStatementNode] = []

    def get_file_extension(self) -> str:
        """JavaScript files use .js extension"""
        return '.js'

    def get_compiler_command(self, source_file: str, output_file: str) -> List[str]:
        """
        No compilation needed for JavaScript - it's interpreted.
        For Node.js, can make executable with shebang and chmod.
        """
        return []  # No compilation step

    def indent(self) -> str:
        """Return current indentation"""
        return '  ' * self.indent_level

    def generate(self, program: ProgramNode) -> str:
        """Generate JavaScript code for the program"""
        # Analysis passes
        self._collect_line_labels(program)
        self._collect_data_values(program)
        self._collect_def_fn(program)
        self._analyze_features(program)

        code = []

        # Header
        code.append('#!/usr/bin/env node')
        code.append('// Generated by MBASIC-2025 JavaScript Backend')
        code.append(f'// Source: {self.config.get("source_file", "program.bas")}')
        code.append('')
        code.append('(function() {')
        code.append("  'use strict';")
        code.append('')

        self.indent_level = 1

        # Runtime library
        code.append(self.indent() + '// ===== Runtime Library =====')
        code.extend(self._generate_runtime())
        code.append('')

        # Variables
        code.append(self.indent() + '// ===== Variables =====')
        code.extend(self._generate_variables())
        code.append('')

        # DEF FN functions
        if self.def_fn_functions:
            code.append(self.indent() + '// ===== DEF FN Functions =====')
            code.extend(self._generate_def_fn_functions())
            code.append('')

        # Main program
        code.append(self.indent() + '// ===== Program =====')
        code.append(self.indent() + 'function main() {')
        self.indent_level += 1

        # Initialize PC to first line
        first_line = min(line.line_number for line in program.lines) if program.lines else 10
        code.append(self.indent() + f'let _pc = {first_line};')
        code.append('')

        # Main execution loop with switch statement
        code.append(self.indent() + 'while (_pc !== null) {')
        self.indent_level += 1
        code.append(self.indent() + 'switch (_pc) {')
        self.indent_level += 1

        # Generate code for each line
        for line in program.lines:
            code.extend(self._generate_line(line))

        # Default case - unknown line
        code.append(self.indent() + 'default:')
        self.indent_level += 1
        code.append(self.indent() + '_error(`Undefined line number ${_pc}`);')
        code.append(self.indent() + 'return;')
        self.indent_level -= 1

        self.indent_level -= 1
        code.append(self.indent() + '}')  # End switch
        self.indent_level -= 1
        code.append(self.indent() + '}')  # End while

        self.indent_level -= 1
        code.append(self.indent() + '}')  # End main()
        code.append('')

        # Run the program
        code.append(self.indent() + '// ===== Execute =====')
        code.append(self.indent() + 'try {')
        self.indent_level += 1
        code.append(self.indent() + 'main();')
        self.indent_level -= 1
        code.append(self.indent() + '} catch (e) {')
        self.indent_level += 1
        code.append(self.indent() + '_print(e.message);')
        code.append(self.indent() + 'if (typeof process !== "undefined") process.exit(1);')
        self.indent_level -= 1
        code.append(self.indent() + '}')

        self.indent_level = 0
        code.append('})();')
        code.append('')

        return '\n'.join(code)

    def _collect_line_labels(self, program: ProgramNode):
        """Collect all line numbers that are referenced"""
        # All lines need labels in switch statement
        for i, line in enumerate(program.lines):
            self.line_labels.add(line.line_number)

            # Build next line map
            if i + 1 < len(program.lines):
                self.next_line_map[line.line_number] = program.lines[i + 1].line_number
            else:
                self.next_line_map[line.line_number] = None  # Last line

    def _collect_data_values(self, program: ProgramNode):
        """Collect all DATA values"""
        for line in program.lines:
            for stmt in line.statements:
                if isinstance(stmt, DataStatementNode):
                    for value in stmt.values:
                        if isinstance(value, str):
                            self.data_values.append(value)
                            self.data_types.append('string')
                        else:
                            self.data_values.append(value)
                            self.data_types.append('number')

    def _collect_def_fn(self, program: ProgramNode):
        """Collect all DEF FN statements"""
        for line in program.lines:
            for stmt in line.statements:
                if isinstance(stmt, DefFnStatementNode):
                    self.def_fn_functions.append(stmt)

    def _analyze_features(self, program: ProgramNode):
        """Analyze which features the program uses"""
        for line in program.lines:
            for stmt in line.statements:
                if isinstance(stmt, InputStatementNode):
                    self.uses_input = True
                elif isinstance(stmt, GosubStatementNode):
                    self.uses_gosub = True
                elif isinstance(stmt, ReadStatementNode):
                    self.uses_data = True
                elif isinstance(stmt, RestoreStatementNode):
                    self.uses_data = True
                # Check for RND function in expressions
                self._check_for_rnd(stmt)

    def _check_for_rnd(self, node):
        """Recursively check for RND function usage"""
        if isinstance(node, FunctionCallNode) and node.name.lower() == 'rnd':
            self.uses_random = True
        # Recursively check children
        if hasattr(node, '__dict__'):
            for attr_value in node.__dict__.values():
                if isinstance(attr_value, list):
                    for item in attr_value:
                        self._check_for_rnd(item)
                elif hasattr(attr_value, '__dict__'):
                    self._check_for_rnd(attr_value)

    def _generate_runtime(self) -> List[str]:
        """Generate runtime library functions"""
        code = []

        # Error handling
        code.append(self.indent() + 'function _error(msg) {')
        self.indent_level += 1
        code.append(self.indent() + 'throw new Error("?" + msg);')
        self.indent_level -= 1
        code.append(self.indent() + '}')
        code.append('')

        # Print function
        code.append(self.indent() + 'function _print(str, newline = true) {')
        self.indent_level += 1
        code.append(self.indent() + 'const s = String(str);')
        code.append(self.indent() + 'if (typeof window !== "undefined") {')
        self.indent_level += 1
        code.append(self.indent() + '// Browser')
        code.append(self.indent() + 'const output = document.getElementById("output");')
        code.append(self.indent() + 'if (output) {')
        self.indent_level += 1
        code.append(self.indent() + 'output.textContent += s;')
        code.append(self.indent() + 'if (newline) output.textContent += "\\n";')
        self.indent_level -= 1
        code.append(self.indent() + '}')
        self.indent_level -= 1
        code.append(self.indent() + '} else if (typeof process !== "undefined") {')
        self.indent_level += 1
        code.append(self.indent() + '// Node.js')
        code.append(self.indent() + 'if (newline) {')
        self.indent_level += 1
        code.append(self.indent() + 'console.log(s);')
        self.indent_level -= 1
        code.append(self.indent() + '} else {')
        self.indent_level += 1
        code.append(self.indent() + 'process.stdout.write(s);')
        self.indent_level -= 1
        code.append(self.indent() + '}')
        self.indent_level -= 1
        code.append(self.indent() + '}')
        self.indent_level -= 1
        code.append(self.indent() + '}')
        code.append('')

        # Math functions
        code.append(self.indent() + '// Math functions')
        code.append(self.indent() + 'const _abs = Math.abs;')
        code.append(self.indent() + 'const _int = Math.floor;')
        code.append(self.indent() + 'const _sqr = Math.sqrt;')
        code.append(self.indent() + 'const _sin = Math.sin;')
        code.append(self.indent() + 'const _cos = Math.cos;')
        code.append(self.indent() + 'const _tan = Math.tan;')
        code.append(self.indent() + 'const _atn = Math.atan;')
        code.append(self.indent() + 'const _log = Math.log;')
        code.append(self.indent() + 'const _exp = Math.exp;')
        code.append('')

        # RND function
        if self.uses_random:
            code.append(self.indent() + 'let _rnd_last = 0.5;')
            code.append(self.indent() + 'function _rnd(x) {')
            self.indent_level += 1
            code.append(self.indent() + 'if (x === undefined || x > 0) {')
            self.indent_level += 1
            code.append(self.indent() + '_rnd_last = Math.random();')
            self.indent_level -= 1
            code.append(self.indent() + '} else if (x < 0) {')
            self.indent_level += 1
            code.append(self.indent() + '// Seed (can\'t truly seed Math.random)')
            code.append(self.indent() + '_rnd_last = Math.abs(Math.sin(x) * 43758.5453);')
            code.append(self.indent() + '_rnd_last = _rnd_last - Math.floor(_rnd_last);')
            self.indent_level -= 1
            code.append(self.indent() + '}')
            code.append(self.indent() + 'return _rnd_last;')
            self.indent_level -= 1
            code.append(self.indent() + '}')
            code.append('')

        # String functions
        code.append(self.indent() + '// String functions')
        code.append(self.indent() + 'function _left(str, n) { return String(str).substring(0, n); }')
        code.append(self.indent() + 'function _right(str, n) { const s = String(str); return s.substring(s.length - n); }')
        code.append(self.indent() + 'function _mid(str, start, len) {')
        self.indent_level += 1
        code.append(self.indent() + 'const s = String(str);')
        code.append(self.indent() + 'if (len === undefined) return s.substring(start - 1);')
        code.append(self.indent() + 'return s.substring(start - 1, start - 1 + len);')
        self.indent_level -= 1
        code.append(self.indent() + '}')
        code.append(self.indent() + 'function _len(str) { return String(str).length; }')
        code.append(self.indent() + 'function _chr(n) { return String.fromCharCode(n); }')
        code.append(self.indent() + 'function _asc(str) { return String(str).charCodeAt(0) || 0; }')
        code.append(self.indent() + 'function _str(n) { return " " + n; }')
        code.append(self.indent() + 'function _val(str) { return parseFloat(String(str).trim()) || 0; }')
        code.append('')

        # GOSUB/RETURN
        if self.uses_gosub:
            code.append(self.indent() + '// GOSUB/RETURN stack')
            code.append(self.indent() + 'const _gosub_stack = [];')
            code.append(self.indent() + 'function _gosub(return_line) {')
            self.indent_level += 1
            code.append(self.indent() + '_gosub_stack.push(return_line);')
            self.indent_level -= 1
            code.append(self.indent() + '}')
            code.append(self.indent() + 'function _return() {')
            self.indent_level += 1
            code.append(self.indent() + 'if (_gosub_stack.length === 0) _error("RETURN without GOSUB");')
            code.append(self.indent() + 'return _gosub_stack.pop();')
            self.indent_level -= 1
            code.append(self.indent() + '}')
            code.append('')

        # FOR/NEXT loop state (variable-indexed approach)
        code.append(self.indent() + '// FOR/NEXT loop state')
        code.append(self.indent() + 'const _for_loops = {};  // Map var name -> {end, step, line}')
        code.append('')

        # DATA/READ/RESTORE
        if self.uses_data or self.data_values:
            code.append(self.indent() + '// DATA/READ/RESTORE')
            code.append(self.indent() + f'const _data = {self._format_data_array()};')
            code.append(self.indent() + 'let _data_ptr = 0;')
            code.append(self.indent() + 'function _read() {')
            self.indent_level += 1
            code.append(self.indent() + 'if (_data_ptr >= _data.length) _error("Out of DATA");')
            code.append(self.indent() + 'return _data[_data_ptr++];')
            self.indent_level -= 1
            code.append(self.indent() + '}')
            code.append(self.indent() + 'function _restore() {')
            self.indent_level += 1
            code.append(self.indent() + '_data_ptr = 0;')
            self.indent_level -= 1
            code.append(self.indent() + '}')
            code.append('')

        return code

    def _format_data_array(self) -> str:
        """Format DATA values as JavaScript array literal"""
        if not self.data_values:
            return '[]'

        items = []
        for value, vtype in zip(self.data_values, self.data_types):
            if vtype == 'string':
                items.append(f'"{self._escape_string(value)}"')
            else:
                items.append(str(value))

        return '[' + ', '.join(items) + ']'

    def _escape_string(self, s: str) -> str:
        """Escape string for JavaScript"""
        return s.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')

    def _generate_variables(self) -> List[str]:
        """Generate variable declarations"""
        code = []

        for var_name, var_info in sorted(self.symbols.variables.items()):
            js_name = self._mangle_var_name(var_name)

            # Skip arrays - they're handled separately
            if var_info.is_array:
                # Generate array initialization
                dimensions = var_info.dimensions or [10]  # Default size
                if var_info.var_type == VarType.STRING:
                    init_value = '""'
                else:
                    init_value = '0'
                code.append(self.indent() + f'let {js_name} = {self._create_array_init(dimensions, init_value)};')
            else:
                # Regular variable
                if var_info.var_type == VarType.STRING:
                    code.append(self.indent() + f'let {js_name} = "";')
                elif var_info.var_type == VarType.INTEGER:
                    code.append(self.indent() + f'let {js_name} = 0;')
                else:  # SINGLE or DOUBLE
                    code.append(self.indent() + f'let {js_name} = 0;')

        return code

    def _create_array_init(self, dimensions: List[int], init_value: str) -> str:
        """Create nested array initialization"""
        if len(dimensions) == 1:
            size = dimensions[0] + 1  # BASIC arrays are 0-based with OPTION BASE
            return f'new Array({size}).fill({init_value})'
        else:
            size = dimensions[0] + 1
            inner = self._create_array_init(dimensions[1:], init_value)
            return f'Array.from({{length: {size}}}, () => {inner})'

    def _mangle_var_name(self, name: str) -> str:
        """Convert BASIC variable name to JavaScript identifier"""
        # Remove type suffix and convert
        base_name = name.rstrip('$%!#')

        # Add suffix for type
        if name.endswith('$'):
            return base_name.lower() + '_str'
        elif name.endswith('%'):
            return base_name.lower() + '_int'
        elif name.endswith('#'):
            return base_name.lower() + '_dbl'
        else:
            return base_name.lower()

    def _generate_def_fn_functions(self) -> List[str]:
        """Generate DEF FN functions"""
        code = []
        # TODO: Implement DEF FN
        return code

    def _generate_line(self, line: LineNode) -> List[str]:
        """Generate code for one line"""
        code = []

        # Case label for this line
        code.append(self.indent() + f'case {line.line_number}:')
        self.indent_level += 1

        # Generate statements
        for i, stmt in enumerate(line.statements):
            stmt_code = self._generate_statement(stmt, line.line_number, i, len(line.statements))
            code.extend(stmt_code)

            # Check if statement changed control flow (GOTO, RETURN, END, etc.)
            if self._is_control_flow_statement(stmt):
                # Control flow statement handles PC itself
                self.indent_level -= 1
                return code

        # Default: continue to next line
        next_line = self.next_line_map.get(line.line_number)
        if next_line is not None:
            code.append(self.indent() + f'_pc = {next_line};')
        else:
            code.append(self.indent() + '_pc = null;')
        code.append(self.indent() + 'break;')

        self.indent_level -= 1

        return code

    def _is_control_flow_statement(self, stmt) -> bool:
        """Check if statement changes control flow"""
        return isinstance(stmt, (
            GotoStatementNode,
            OnGotoStatementNode,
            GosubStatementNode,
            ReturnStatementNode,
            EndStatementNode,
        ))

    def _generate_statement(self, stmt, line_number: int, stmt_index: int, total_stmts: int) -> List[str]:
        """Generate code for a statement"""
        code = []

        if isinstance(stmt, PrintStatementNode):
            code.extend(self._generate_print(stmt))
        elif isinstance(stmt, LetStatementNode):
            code.extend(self._generate_let(stmt))
        elif isinstance(stmt, EndStatementNode):
            code.append(self.indent() + '_pc = null;')
            code.append(self.indent() + 'return;')
        elif isinstance(stmt, GotoStatementNode):
            code.extend(self._generate_goto(stmt))
        elif isinstance(stmt, OnGotoStatementNode):
            code.extend(self._generate_on_goto(stmt))
        elif isinstance(stmt, GosubStatementNode):
            code.extend(self._generate_gosub(stmt, line_number))
        elif isinstance(stmt, ReturnStatementNode):
            code.extend(self._generate_return(stmt))
        elif isinstance(stmt, ForStatementNode):
            # Calculate return line for FOR loop
            is_last_stmt = (stmt_index == total_stmts - 1)
            if is_last_stmt:
                return_line = self.next_line_map.get(line_number, None)
            else:
                return_line = line_number  # Next statement on same line
            code.extend(self._generate_for(stmt, return_line))
        elif isinstance(stmt, NextStatementNode):
            code.extend(self._generate_next(stmt))
        elif isinstance(stmt, WhileStatementNode):
            code.extend(self._generate_while(stmt))
        elif isinstance(stmt, WendStatementNode):
            code.extend(self._generate_wend(stmt))
        elif isinstance(stmt, IfStatementNode):
            code.extend(self._generate_if(stmt, line_number))
        elif isinstance(stmt, InputStatementNode):
            code.extend(self._generate_input(stmt))
        elif isinstance(stmt, ReadStatementNode):
            code.extend(self._generate_read(stmt))
        elif isinstance(stmt, RestoreStatementNode):
            code.extend(self._generate_restore(stmt))
        elif isinstance(stmt, DataStatementNode):
            # DATA statements are processed during initialization
            pass
        elif isinstance(stmt, DimStatementNode):
            # DIM statements are processed during variable generation
            pass
        elif isinstance(stmt, RemarkStatementNode):
            # Comments are skipped
            pass
        else:
            code.append(self.indent() + f'// Unsupported: {type(stmt).__name__}')

        return code

    def _generate_print(self, stmt: PrintStatementNode) -> List[str]:
        """Generate PRINT statement"""
        code = []

        if not stmt.expressions:
            # Empty PRINT - just newline
            code.append(self.indent() + '_print("");')
        else:
            for i, expr in enumerate(stmt.expressions):
                is_last = (i == len(stmt.expressions) - 1)
                separator = stmt.separators[i] if i < len(stmt.separators) else None

                expr_code = self._generate_expression(expr)

                # Determine if we should add a newline
                # Newline if last item and no separator, or separator is None
                newline = 'true' if (is_last and separator is None) else 'false'

                code.append(self.indent() + f'_print({expr_code}, {newline});')

                # Handle separator (comma for tab, semicolon for no space)
                if separator == ',':
                    code.append(self.indent() + '_print("\\t", false);')
                elif separator == ';':
                    # Semicolon means no space - already handled
                    pass

        return code

    def _generate_let(self, stmt: LetStatementNode) -> List[str]:
        """Generate LET statement (assignment)"""
        code = []

        # Check if assigning to array element
        if stmt.variable.subscripts:
            var_name = self._mangle_var_name(stmt.variable.name + (stmt.variable.type_suffix or ''))
            access = var_name
            for idx_expr in stmt.variable.subscripts:
                idx = self._generate_expression(idx_expr)
                access = f'{access}[{idx}]'
            expr_code = self._generate_expression(stmt.expression)
            code.append(self.indent() + f'{access} = {expr_code};')
        else:
            var_name = self._mangle_var_name(stmt.variable.name + (stmt.variable.type_suffix or ''))
            expr_code = self._generate_expression(stmt.expression)
            code.append(self.indent() + f'{var_name} = {expr_code};')

        return code

    def _generate_expression(self, expr) -> str:
        """Generate JavaScript expression"""
        if isinstance(expr, NumberNode):
            return str(expr.value)
        elif isinstance(expr, StringNode):
            return f'"{self._escape_string(expr.value)}"'
        elif isinstance(expr, VariableNode):
            # Check if it's an array access
            if expr.subscripts:
                var_name = self._mangle_var_name(expr.name + (expr.type_suffix or ''))
                access = var_name
                for idx_expr in expr.subscripts:
                    idx = self._generate_expression(idx_expr)
                    access = f'{access}[{idx}]'
                return access
            else:
                return self._mangle_var_name(expr.name + (expr.type_suffix or ''))
        elif isinstance(expr, BinaryOpNode):
            left = self._generate_expression(expr.left)
            right = self._generate_expression(expr.right)
            op = expr.operator

            # Map BASIC operators to JavaScript
            if op == '^':
                return f'Math.pow({left}, {right})'
            elif op in ['+', '-', '*', '/', '<', '>', '<=', '>=', '=', '<>']:
                if op == '=':
                    js_op = '==='
                elif op == '<>':
                    js_op = '!=='
                else:
                    js_op = op
                return f'({left} {js_op} {right})'
            else:
                return f'({left} {op} {right})'
        elif isinstance(expr, UnaryOpNode):
            operand = self._generate_expression(expr.operand)
            return f'({expr.operator}{operand})'
        elif isinstance(expr, FunctionCallNode):
            return self._generate_function_call(expr)
        else:
            return f'/* Unknown expr: {type(expr).__name__} */'

    def _generate_function_call(self, func: FunctionCallNode) -> str:
        """Generate function call"""
        func_name = func.name.lower()
        args = [self._generate_expression(arg) for arg in func.arguments]

        # Map BASIC function names to JavaScript
        js_func_map = {
            'abs': '_abs',
            'int': '_int',
            'sqr': '_sqr',
            'sin': '_sin',
            'cos': '_cos',
            'tan': '_tan',
            'atn': '_atn',
            'log': '_log',
            'exp': '_exp',
            'rnd': '_rnd',
            'left$': '_left',
            'right$': '_right',
            'mid$': '_mid',
            'len': '_len',
            'chr$': '_chr',
            'asc': '_asc',
            'str$': '_str',
            'val': '_val',
        }

        js_func = js_func_map.get(func_name, func_name)
        return f'{js_func}({", ".join(args)})'

    def _generate_goto(self, stmt: GotoStatementNode) -> List[str]:
        """Generate GOTO statement"""
        code = []
        code.append(self.indent() + f'_pc = {stmt.target};')
        code.append(self.indent() + 'break;')
        return code

    def _generate_on_goto(self, stmt: OnGotoStatementNode) -> List[str]:
        """Generate ON...GOTO statement"""
        code = []
        expr = self._generate_expression(stmt.expression)
        code.append(self.indent() + f'{{')
        self.indent_level += 1
        code.append(self.indent() + f'const _idx = Math.floor({expr});')
        code.append(self.indent() + f'const _targets = [{", ".join(str(t) for t in stmt.targets)}];')
        code.append(self.indent() + f'if (_idx >= 1 && _idx <= _targets.length) {{')
        self.indent_level += 1
        code.append(self.indent() + f'_pc = _targets[_idx - 1];')
        code.append(self.indent() + f'break;')
        self.indent_level -= 1
        code.append(self.indent() + f'}}')
        code.append(self.indent() + f'// Fall through if index out of range')
        self.indent_level -= 1
        code.append(self.indent() + f'}}')
        return code

    def _generate_gosub(self, stmt: GosubStatementNode, current_line: int) -> List[str]:
        """Generate GOSUB statement"""
        code = []
        # Calculate return line (next statement or next line)
        # For simplicity, we'll need to track this - for now use current_line as placeholder
        code.append(self.indent() + f'_gosub({current_line});  // TODO: Calculate return address')
        code.append(self.indent() + f'_pc = {stmt.target};')
        code.append(self.indent() + 'break;')
        return code

    def _generate_return(self, stmt: ReturnStatementNode) -> List[str]:
        """Generate RETURN statement"""
        code = []
        code.append(self.indent() + '_pc = _return();')
        code.append(self.indent() + 'break;')
        return code

    def _generate_for(self, stmt: ForStatementNode, return_line: Optional[int]) -> List[str]:
        """Generate FOR statement - variable-indexed approach"""
        code = []
        var_name = self._mangle_var_name(stmt.variable.name + (stmt.variable.type_suffix or ''))
        start_expr = self._generate_expression(stmt.start_expr)
        end_expr = self._generate_expression(stmt.end_expr)

        if stmt.step_expr:
            step_expr = self._generate_expression(stmt.step_expr)
        else:
            step_expr = '1'

        # Initialize loop variable and store state
        code.append(self.indent() + f'{{')
        self.indent_level += 1
        code.append(self.indent() + f'const _end = {end_expr};')
        code.append(self.indent() + f'const _step = {step_expr};')
        code.append(self.indent() + f'{var_name} = {start_expr};')

        # Check initial condition before entering loop
        code.append(self.indent() + f'const _start_ok = (_step > 0) ? ({var_name} <= _end) : ({var_name} >= _end);')
        code.append(self.indent() + f'if (_start_ok) {{')
        self.indent_level += 1

        code.append(self.indent() + f'_for_loops["{var_name}"] = {{')
        self.indent_level += 1
        code.append(self.indent() + f'end: _end,')
        code.append(self.indent() + f'step: _step,')
        if return_line is not None:
            code.append(self.indent() + f'line: {return_line}')
        else:
            code.append(self.indent() + f'line: null  // End of program')
        self.indent_level -= 1
        code.append(self.indent() + f'}};')

        self.indent_level -= 1
        code.append(self.indent() + f'}} else {{')
        self.indent_level += 1
        code.append(self.indent() + f'// Skip loop - condition not met')
        code.append(self.indent() + f'// TODO: Jump to line after NEXT')
        self.indent_level -= 1
        code.append(self.indent() + f'}}')
        self.indent_level -= 1
        code.append(self.indent() + f'}}')

        return code

    def _generate_next(self, stmt: NextStatementNode) -> List[str]:
        """Generate NEXT statement - check condition and loop back"""
        code = []

        # Get variable names
        if not stmt.variables:
            # NEXT without variable - use most recent FOR loop
            # For now, generate error (TODO: track loop stack)
            code.append(self.indent() + '_error("NEXT without FOR");')
            return code

        # Handle each variable (NEXT can have multiple variables: NEXT I, J, K)
        for var in stmt.variables:
            var_name = self._mangle_var_name(var.name + (var.type_suffix or ''))

            # Increment variable and check condition
            code.append(self.indent() + f'if (_for_loops["{var_name}"]) {{')
            self.indent_level += 1
            code.append(self.indent() + f'const _loop = _for_loops["{var_name}"];')
            code.append(self.indent() + f'{var_name} += _loop.step;')
            code.append(self.indent() + f'const _continue = (_loop.step > 0) ? ({var_name} <= _loop.end) : ({var_name} >= _loop.end);')
            code.append(self.indent() + f'if (_continue) {{')
            self.indent_level += 1
            code.append(self.indent() + f'_pc = _loop.line;')
            code.append(self.indent() + f'break;')
            self.indent_level -= 1
            code.append(self.indent() + f'}} else {{')
            self.indent_level += 1
            code.append(self.indent() + f'delete _for_loops["{var_name}"];')
            self.indent_level -= 1
            code.append(self.indent() + f'}}')
            self.indent_level -= 1
            code.append(self.indent() + f'}}')

        return code

    def _generate_while(self, stmt: WhileStatementNode) -> List[str]:
        """Generate WHILE statement"""
        code = []
        condition = self._generate_expression(stmt.condition)
        code.append(self.indent() + f'while ({condition}) {{')
        self.indent_level += 1
        return code

    def _generate_wend(self, stmt: WendStatementNode) -> List[str]:
        """Generate WEND statement"""
        code = []
        self.indent_level -= 1
        code.append(self.indent() + '}')
        return code

    def _generate_if(self, stmt: IfStatementNode, current_line: int) -> List[str]:
        """Generate IF statement"""
        code = []
        condition = self._generate_expression(stmt.condition)

        if stmt.then_statements:
            # Multi-line IF...THEN...END IF
            code.append(self.indent() + f'if ({condition}) {{')
            self.indent_level += 1
            for s in stmt.then_statements:
                code.extend(self._generate_statement(s, current_line, 0, 1))
            self.indent_level -= 1

            if stmt.else_statements:
                code.append(self.indent() + '} else {')
                self.indent_level += 1
                for s in stmt.else_statements:
                    code.extend(self._generate_statement(s, current_line, 0, 1))
                self.indent_level -= 1

            code.append(self.indent() + '}')
        elif stmt.then_line:
            # IF...THEN line_number (GOTO)
            code.append(self.indent() + f'if ({condition}) {{')
            self.indent_level += 1
            code.append(self.indent() + f'_pc = {stmt.then_line};')
            code.append(self.indent() + 'break;')
            self.indent_level -= 1
            code.append(self.indent() + '}')

        return code

    def _generate_input(self, stmt: InputStatementNode) -> List[str]:
        """Generate INPUT statement"""
        code = []

        # Generate prompt if present
        if stmt.prompt:
            prompt_str = self._escape_string(stmt.prompt)
            code.append(self.indent() + f'_print("{prompt_str}", false);')

        # For now, skip INPUT implementation (needs async handling)
        code.append(self.indent() + '// TODO: INPUT not yet implemented')

        return code

    def _generate_read(self, stmt: ReadStatementNode) -> List[str]:
        """Generate READ statement"""
        code = []
        for var in stmt.variables:
            var_name = self._mangle_var_name(var.name + (var.type_suffix or ''))
            code.append(self.indent() + f'{var_name} = _read();')
        return code

    def _generate_restore(self, stmt: RestoreStatementNode) -> List[str]:
        """Generate RESTORE statement"""
        code = []
        code.append(self.indent() + '_restore();')
        return code
