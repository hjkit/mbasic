#!/usr/bin/env python3
"""
Code Generation Backend Interface

This module defines the abstract interface for code generation backends.
Different backends can generate code for different target platforms:
- C code for z88dk (CP/M, Z80)
- Assembly for various processors
- Other high-level languages

Each backend receives a fully analyzed AST from the semantic analyzer
and generates executable code in the target language.
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Set, Optional, Any
from src.ast_nodes import *
from src.semantic_analyzer import SymbolTable, VarType


class CodeGenBackend(ABC):
    """Abstract base class for code generation backends"""

    def __init__(self, symbols: SymbolTable):
        """
        Initialize the backend with symbol table information.

        Args:
            symbols: Symbol table from semantic analysis
        """
        self.symbols = symbols
        self.errors: List[str] = []
        self.warnings: List[str] = []

    @abstractmethod
    def generate(self, program: ProgramNode) -> str:
        """
        Generate code for the entire program.

        Args:
            program: Fully analyzed AST

        Returns:
            Generated source code as a string
        """
        pass

    @abstractmethod
    def get_file_extension(self) -> str:
        """Return the file extension for generated code (e.g., '.c', '.asm')"""
        pass

    @abstractmethod
    def get_compiler_command(self, source_file: str, output_file: str) -> List[str]:
        """
        Return the command to compile the generated code.

        Args:
            source_file: Path to generated source file
            output_file: Desired output executable path

        Returns:
            List of command arguments (e.g., ['gcc', '-o', 'output', 'source.c'])
        """
        pass


class Z88dkCBackend(CodeGenBackend):
    """
    C code generator for z88dk compiler targeting CP/M on Z80.

    Supports:
    - Integer variables (BASIC ! suffix maps to C int)
    - FOR/NEXT loops
    - PRINT statements for integers

    Future:
    - String support (requires runtime library)
    - Arrays
    - More complex expressions
    """

    def __init__(self, symbols: SymbolTable):
        super().__init__(symbols)
        self.indent_level = 0
        self.line_labels: Set[int] = set()  # Line numbers that need labels
        self.gosub_return_counter = 0  # Counter for unique GOSUB return labels
        self.total_gosubs = 0  # Total number of GOSUB statements in program

    def get_file_extension(self) -> str:
        return '.c'

    def get_compiler_command(self, source_file: str, output_file: str) -> List[str]:
        """Return z88dk.zcc command for CP/M compilation"""
        # z88dk.zcc +cpm source.c -create-app -o output
        # This generates OUTPUT.COM (uppercase .COM file)
        # -lm links the math library for floating point support
        return ['/snap/bin/z88dk.zcc', '+cpm', source_file, '-create-app', '-lm', '-o', output_file]

    def indent(self) -> str:
        """Return current indentation string"""
        return '    ' * self.indent_level

    def generate(self, program: ProgramNode) -> str:
        """Generate C code for the program"""
        # First pass: count GOSUB statements
        self._count_gosubs(program)

        # Collect line numbers that are referenced (for labels)
        self._collect_line_labels(program)

        code = []

        # Header
        code.append('/* Generated by MBASIC-2025 compiler */')
        code.append('/* Target: CP/M via z88dk */')
        code.append('')
        code.append('#include <stdio.h>')
        code.append('#include <math.h>')
        code.append('')

        # Main function
        code.append('int main() {')
        self.indent_level += 1

        # Variable declarations
        var_decls = self._generate_variable_declarations()
        if var_decls:
            code.extend(var_decls)
            code.append('')

        # GOSUB return stack - for implementing GOSUB/RETURN
        code.append(self.indent() + '/* GOSUB return stack */')
        code.append(self.indent() + 'int gosub_stack[100];  /* Return line numbers */')
        code.append(self.indent() + 'int gosub_sp = 0;      /* Stack pointer */')
        code.append('')

        # Generate code for each line
        for line_node in program.lines:
            code.extend(self._generate_line(line_node))

        # End main
        self.indent_level -= 1
        code.append('')
        code.append('    return 0;')
        code.append('}')
        code.append('')

        return '\n'.join(code)

    def _count_gosubs(self, program: ProgramNode):
        """Count total number of GOSUB statements in the program"""
        self.total_gosubs = 0
        for line_node in program.lines:
            for stmt in line_node.statements:
                if isinstance(stmt, GosubStatementNode):
                    self.total_gosubs += 1

    def _collect_line_labels(self, program: ProgramNode):
        """
        Collect all line numbers that need labels (referenced by GOTO, GOSUB, etc.)
        For now, we'll label all lines to keep it simple.
        """
        for line_node in program.lines:
            self.line_labels.add(line_node.line_number)

    def _generate_variable_declarations(self) -> List[str]:
        """Generate C variable declarations from symbol table"""
        decls = []

        # Group by type for cleaner output
        integers = []
        singles = []
        doubles = []

        for var_name, var_info in self.symbols.variables.items():
            if var_info.is_array:
                # Skip arrays for now - not supported in initial implementation
                continue

            c_name = self._mangle_variable_name(var_name)

            if var_info.var_type == VarType.INTEGER:
                integers.append(c_name)
            elif var_info.var_type == VarType.SINGLE:
                singles.append(c_name)
            elif var_info.var_type == VarType.DOUBLE:
                doubles.append(c_name)

        # Generate declarations
        if integers:
            decls.append(self.indent() + 'int ' + ', '.join(integers) + ';')
        if singles:
            decls.append(self.indent() + 'float ' + ', '.join(singles) + ';')
        if doubles:
            decls.append(self.indent() + 'double ' + ', '.join(doubles) + ';')

        return decls

    def _mangle_variable_name(self, basic_name: str) -> str:
        """
        Convert BASIC variable name to valid C identifier.

        BASIC allows names like "I!", "COUNT%", "VALUE#"
        C needs alphanumeric + underscore, no type suffixes.
        """
        # Remove type suffix
        name = basic_name.rstrip('!%#$')

        # Make lowercase for consistency
        name = name.lower()

        # Add prefix to avoid C keyword conflicts
        if name in ('int', 'float', 'double', 'char', 'void', 'if', 'for', 'while', 'return'):
            name = 'v_' + name

        return name

    def _generate_line(self, line_node: LineNode) -> List[str]:
        """Generate code for one line of BASIC"""
        code = []

        # Add line label if needed
        if line_node.line_number in self.line_labels:
            # Use goto label syntax: line_100:
            code.append(f'line_{line_node.line_number}:')

        # Generate code for each statement on the line
        for stmt in line_node.statements:
            stmt_code = self._generate_statement(stmt)
            if stmt_code:
                code.extend(stmt_code)

        return code

    def _generate_statement(self, stmt: Any) -> List[str]:
        """Generate code for a single statement"""
        if isinstance(stmt, PrintStatementNode):
            return self._generate_print(stmt)
        elif isinstance(stmt, ForStatementNode):
            return self._generate_for(stmt)
        elif isinstance(stmt, NextStatementNode):
            return self._generate_next(stmt)
        elif isinstance(stmt, LetStatementNode):
            return self._generate_assignment(stmt)
        elif isinstance(stmt, EndStatementNode):
            return self._generate_end(stmt)
        elif isinstance(stmt, RemarkStatementNode):
            return self._generate_remark(stmt)
        elif isinstance(stmt, WhileStatementNode):
            return self._generate_while(stmt)
        elif isinstance(stmt, WendStatementNode):
            return self._generate_wend(stmt)
        elif isinstance(stmt, GotoStatementNode):
            return self._generate_goto(stmt)
        elif isinstance(stmt, GosubStatementNode):
            return self._generate_gosub(stmt)
        elif isinstance(stmt, ReturnStatementNode):
            return self._generate_return(stmt)
        else:
            # Unsupported statement
            self.warnings.append(f"Unsupported statement type: {type(stmt).__name__}")
            return [self.indent() + f'/* Unsupported: {type(stmt).__name__} */']

    def _get_expression_type(self, expr: Any) -> VarType:
        """Determine the type of an expression"""
        if isinstance(expr, NumberNode):
            # Check if it's a float or integer
            if isinstance(expr.value, float) and expr.value != int(expr.value):
                return VarType.SINGLE  # Default float type
            else:
                return VarType.INTEGER
        elif isinstance(expr, VariableNode):
            var_name = expr.name.upper()
            if var_name in self.symbols.variables:
                return self.symbols.variables[var_name].var_type
            else:
                return VarType.SINGLE  # Default
        elif isinstance(expr, BinaryOpNode):
            # For simplicity, use the type of the left operand
            # In reality, we'd need type promotion rules
            return self._get_expression_type(expr.left)
        else:
            return VarType.SINGLE  # Default

    def _get_format_specifier(self, var_type: VarType) -> str:
        """Get printf format specifier for a variable type"""
        if var_type == VarType.INTEGER:
            return '%d'
        elif var_type == VarType.SINGLE:
            return '%g'  # %g uses shortest representation (no trailing zeros)
        elif var_type == VarType.DOUBLE:
            return '%lg'  # %lg for double
        elif var_type == VarType.STRING:
            return '%s'
        else:
            return '%g'

    def _generate_print(self, stmt: PrintStatementNode) -> List[str]:
        """Generate PRINT statement code"""
        code = []

        if stmt.file_number:
            self.warnings.append("PRINT to file not supported yet")
            return [self.indent() + '/* PRINT to file not supported */']

        # Print each expression with appropriate format
        for i, expr in enumerate(stmt.expressions):
            c_expr = self._generate_expression(expr)
            separator = stmt.separators[i] if i < len(stmt.separators) else None

            # Determine format based on expression type
            expr_type = self._get_expression_type(expr)
            fmt = self._get_format_specifier(expr_type)

            if separator == ';':
                # No space, no newline
                code.append(self.indent() + f'printf("{fmt}", {c_expr});')
            elif separator == ',':
                # Tab to next zone (use space for now)
                code.append(self.indent() + f'printf("{fmt} ", {c_expr});')
            else:
                # Newline after
                code.append(self.indent() + f'printf("{fmt}\\n", {c_expr});')

        return code

    def _generate_for(self, stmt: ForStatementNode) -> List[str]:
        """Generate FOR loop code"""
        code = []

        var_name = self._mangle_variable_name(stmt.variable.name)
        start = self._generate_expression(stmt.start_expr)
        end = self._generate_expression(stmt.end_expr)
        step = '1'
        if stmt.step_expr:
            step = self._generate_expression(stmt.step_expr)

        # Generate C for loop
        # BASIC: FOR I = 1 TO 10 STEP 2
        # C: for (i = 1; i <= 10; i += 2)

        # Determine comparison operator based on step
        if stmt.step_expr:
            # If step is negative, use >= instead of <=
            # For now, assume positive step (TODO: handle negative steps)
            comp = '<='
        else:
            comp = '<='

        code.append(self.indent() + f'for ({var_name} = {start}; {var_name} {comp} {end}; {var_name} += {step}) {{')
        self.indent_level += 1

        return code

    def _generate_next(self, stmt: NextStatementNode) -> List[str]:
        """Generate NEXT statement (close FOR loop)"""
        self.indent_level -= 1
        return [self.indent() + '}']

    def _generate_assignment(self, stmt: LetStatementNode) -> List[str]:
        """Generate assignment statement"""
        var_name = self._mangle_variable_name(stmt.variable.name)
        expr = self._generate_expression(stmt.expression)
        return [self.indent() + f'{var_name} = {expr};']

    def _generate_end(self, stmt: EndStatementNode) -> List[str]:
        """Generate END statement"""
        return [self.indent() + 'return 0;']

    def _generate_remark(self, stmt: RemarkStatementNode) -> List[str]:
        """Generate REM statement as C comment"""
        # Convert BASIC comment to C comment
        comment_text = stmt.text.strip()
        if comment_text:
            return [self.indent() + f'/* {comment_text} */']
        else:
            return []  # Empty comment, skip it

    def _generate_while(self, stmt: WhileStatementNode) -> List[str]:
        """Generate WHILE statement"""
        code = []
        condition = self._generate_expression(stmt.condition)
        code.append(self.indent() + f'while ({condition}) {{')
        self.indent_level += 1
        return code

    def _generate_wend(self, stmt: WendStatementNode) -> List[str]:
        """Generate WEND statement (close WHILE loop)"""
        self.indent_level -= 1
        return [self.indent() + '}']

    def _generate_goto(self, stmt: GotoStatementNode) -> List[str]:
        """Generate GOTO statement"""
        return [self.indent() + f'goto line_{stmt.line_number};']

    def _generate_gosub(self, stmt: GosubStatementNode) -> List[str]:
        """Generate GOSUB statement with proper return mechanism"""
        code = []
        # Each GOSUB gets a unique return label
        return_id = self.gosub_return_counter
        self.gosub_return_counter += 1

        # Push return ID onto stack
        code.append(self.indent() + f'gosub_stack[gosub_sp++] = {return_id};  /* Push return address */')
        code.append(self.indent() + f'goto line_{stmt.line_number};  /* Jump to subroutine */')
        code.append(f'gosub_return_{return_id}:  /* Return point */')
        return code

    def _generate_return(self, stmt: ReturnStatementNode) -> List[str]:
        """Generate RETURN statement"""
        code = []
        # Pop return ID from stack and jump to appropriate return point
        code.append(self.indent() + 'if (gosub_sp > 0) {')
        self.indent_level += 1
        code.append(self.indent() + 'switch (gosub_stack[--gosub_sp]) {')
        self.indent_level += 1

        # Generate case statements for each GOSUB in the program
        # (iterating over GOSUB count from the first pass)
        for return_id in range(self.total_gosubs):
            code.append(self.indent() + f'case {return_id}: goto gosub_return_{return_id};')

        # Default case (should never happen if program is correct)
        code.append(self.indent() + 'default: break;  /* Error: invalid return address */')

        self.indent_level -= 1
        code.append(self.indent() + '}')
        self.indent_level -= 1
        code.append(self.indent() + '}')
        return code

    def _generate_expression(self, expr: Any) -> str:
        """Generate C code for an expression"""
        if isinstance(expr, NumberNode):
            # Format numbers appropriately - if it's a whole number, output as integer
            if isinstance(expr.value, (int, float)) and expr.value == int(expr.value):
                return str(int(expr.value))
            else:
                return str(expr.value)
        elif isinstance(expr, VariableNode):
            return self._mangle_variable_name(expr.name)
        elif isinstance(expr, BinaryOpNode):
            return self._generate_binary_op(expr)
        elif isinstance(expr, UnaryOpNode):
            return self._generate_unary_op(expr)
        else:
            self.warnings.append(f"Unsupported expression type: {type(expr).__name__}")
            return '0  /* unsupported expression */'

    def _generate_binary_op(self, expr: BinaryOpNode) -> str:
        """Generate C code for binary operation"""
        left = self._generate_expression(expr.left)
        right = self._generate_expression(expr.right)

        # Map BASIC operators to C operators
        op_map = {
            TokenType.PLUS: '+',
            TokenType.MINUS: '-',
            TokenType.MULTIPLY: '*',
            TokenType.DIVIDE: '/',
            TokenType.POWER: '**',  # Need to handle this specially
            TokenType.EQUAL: '==',
            TokenType.NOT_EQUAL: '!=',
            TokenType.LESS_THAN: '<',
            TokenType.LESS_EQUAL: '<=',
            TokenType.GREATER_THAN: '>',
            TokenType.GREATER_EQUAL: '>=',
        }

        c_op = op_map.get(expr.operator, '?')

        # Special handling for power operator (not in C)
        if expr.operator == TokenType.POWER:
            # Use pow() function from math.h
            return f'pow({left}, {right})'

        return f'({left} {c_op} {right})'

    def _generate_unary_op(self, expr: UnaryOpNode) -> str:
        """Generate C code for unary operation"""
        operand = self._generate_expression(expr.operand)

        if expr.operator == TokenType.MINUS:
            return f'(-{operand})'
        elif expr.operator == TokenType.PLUS:
            return f'(+{operand})'
        else:
            return operand
