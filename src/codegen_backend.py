#!/usr/bin/env python3
"""
Code Generation Backend Interface

This module defines the abstract interface for code generation backends.
Different backends can generate code for different target platforms:
- C code for z88dk (CP/M, Z80)
- Assembly for various processors
- Other high-level languages

Each backend receives a fully analyzed AST from the semantic analyzer
and generates executable code in the target language.
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Set, Optional, Any
from src.ast_nodes import *
from src.semantic_analyzer import SymbolTable, VarType


class CodeGenBackend(ABC):
    """Abstract base class for code generation backends"""

    def __init__(self, symbols: SymbolTable):
        """
        Initialize the backend with symbol table information.

        Args:
            symbols: Symbol table from semantic analysis
        """
        self.symbols = symbols
        self.errors: List[str] = []
        self.warnings: List[str] = []

    @abstractmethod
    def generate(self, program: ProgramNode) -> str:
        """
        Generate code for the entire program.

        Args:
            program: Fully analyzed AST

        Returns:
            Generated source code as a string
        """
        pass

    @abstractmethod
    def get_file_extension(self) -> str:
        """Return the file extension for generated code (e.g., '.c', '.asm')"""
        pass

    @abstractmethod
    def get_compiler_command(self, source_file: str, output_file: str) -> List[str]:
        """
        Return the command to compile the generated code.

        Args:
            source_file: Path to generated source file
            output_file: Desired output executable path

        Returns:
            List of command arguments (e.g., ['gcc', '-o', 'output', 'source.c'])
        """
        pass


class Z88dkCBackend(CodeGenBackend):
    """
    C code generator for z88dk compiler targeting CP/M on Z80.

    Supports:
    - Integer variables (BASIC ! suffix maps to C int)
    - FOR/NEXT loops
    - PRINT statements for integers
    - String variables and operations (using mb25_string runtime)

    Known limitations (not yet implemented):
    - Arrays (partial - string arrays need work)
    - Complex expressions beyond simple binary operations
    """

    def __init__(self, symbols: SymbolTable):
        super().__init__(symbols)
        self.indent_level = 0
        self.line_labels: Set[int] = set()  # Line numbers that need labels
        self.gosub_return_counter = 0  # Counter for unique GOSUB return labels
        self.total_gosubs = 0  # Total number of GOSUB statements in program
        self.string_count = 0  # Total number of string descriptors needed
        self.string_ids = {}  # Maps variable name to string ID
        self.next_temp_id = 0  # For temporary string allocation
        self.max_temps_per_statement = 5  # Estimate max temporaries needed

    def get_file_extension(self) -> str:
        return '.c'

    def get_compiler_command(self, source_file: str, output_file: str) -> List[str]:
        """Return z88dk.zcc command for CP/M compilation.

        Requirements:
        - z88dk must be installed and z88dk.zcc must be in your PATH
        - Installation options:
          * Ubuntu/Debian: sudo snap install z88dk (then add /snap/bin to PATH)
          * Build from source: https://github.com/z88dk/z88dk
          * Docker: docker pull z88dk/z88dk

        The compiler uses /usr/bin/env to find z88dk.zcc in PATH, making it
        portable across different installation methods.
        """
        # z88dk.zcc +cpm source.c -create-app -o output
        # This generates OUTPUT.COM (uppercase .COM file)
        # -lm links the math library for floating point support
        return ['/usr/bin/env', 'z88dk.zcc', '+cpm', source_file, '-create-app', '-lm', '-o', output_file]

    def indent(self) -> str:
        """Return current indentation string"""
        return '    ' * self.indent_level

    def generate(self, program: ProgramNode) -> str:
        """Generate C code for the program"""
        # First pass: count GOSUB statements
        self._count_gosubs(program)

        # Count strings and allocate IDs
        self._count_strings_and_allocate_ids(program)

        # Collect line numbers that are referenced (for labels)
        self._collect_line_labels(program)

        code = []

        # Header
        code.append('/* Generated by MBASIC-2025 compiler */')
        code.append('/* Target: CP/M via z88dk */')
        code.append('')

        # String system defines and includes
        if self.string_count > 0:
            code.append(f'#define MB25_NUM_STRINGS {self.string_count}')
            code.append('#define MB25_POOL_SIZE 8192  /* 8KB string pool */')
            code.append('#include "mb25_string.h"')
            code.append('')
            # Generate string ID defines
            for var_name, str_id in sorted(self.string_ids.items(), key=lambda x: x[1]):
                code.append(f'#define STR_{self._mangle_string_name(var_name)} {str_id}')
            code.append('')

        code.append('#include <stdio.h>')
        code.append('#include <stdlib.h>')
        code.append('#include <string.h>')
        code.append('#include <math.h>')
        code.append('')

        # Main function
        code.append('int main() {')
        self.indent_level += 1

        # Initialize string system if needed
        if self.string_count > 0:
            code.append(self.indent() + '/* Initialize string system */')
            code.append(self.indent() + 'if (mb25_init(MB25_POOL_SIZE) != MB25_SUCCESS) {')
            self.indent_level += 1
            code.append(self.indent() + 'fprintf(stderr, "?Out of memory\\n");')
            code.append(self.indent() + 'return 1;')
            self.indent_level -= 1
            code.append(self.indent() + '}')
            code.append('')

        # Variable declarations
        var_decls = self._generate_variable_declarations()
        if var_decls:
            code.extend(var_decls)
            code.append('')

        # GOSUB return stack - for implementing GOSUB/RETURN
        code.append(self.indent() + '/* GOSUB return stack */')
        code.append(self.indent() + 'int gosub_stack[100];  /* Return IDs (0, 1, 2...) - not line numbers */')
        code.append(self.indent() + 'int gosub_sp = 0;      /* Stack pointer */')
        code.append('')

        # Generate code for each line
        for line_node in program.lines:
            code.extend(self._generate_line(line_node))

        # End main
        self.indent_level -= 1
        code.append('')

        # Cleanup string system if needed
        if self.string_count > 0:
            code.append('    mb25_cleanup();')

        code.append('    return 0;')
        code.append('}')
        code.append('')

        return '\n'.join(code)

    def _count_strings_and_allocate_ids(self, program: ProgramNode):
        """Count string variables and allocate string IDs"""
        current_id = 0

        # Allocate IDs for string variables from symbol table
        for var_name, var_info in self.symbols.variables.items():
            if var_info.var_type == VarType.STRING:
                if var_info.is_array:
                    # For arrays, allocate IDs for all elements
                    # TODO: Need proper array dimension info from symbol table
                    # For now, allocate a reasonable default
                    array_size = 11  # Default DIM A$(10) = 0-10 = 11 elements
                    self.string_ids[var_name] = current_id
                    current_id += array_size
                else:
                    self.string_ids[var_name] = current_id
                    current_id += 1

        # Reserve space for temporaries (for complex expressions)
        # Estimate based on program complexity
        temp_count = self._estimate_temp_strings_needed(program)
        self.string_ids['_TEMP_BASE'] = current_id
        current_id += temp_count

        self.string_count = current_id
        self.next_temp_id = self.string_ids['_TEMP_BASE']

    def _estimate_temp_strings_needed(self, program: ProgramNode) -> int:
        """Estimate the maximum number of temporary strings needed"""
        max_temps = 0

        for line_node in program.lines:
            for stmt in line_node.statements:
                # Count complexity of string expressions in this statement
                temps_needed = self._count_expression_temps(stmt)
                max_temps = max(max_temps, temps_needed)

        # Add some buffer for safety
        return max_temps + 3

    def _count_expression_temps(self, node) -> int:
        """Count temporary strings needed for an expression or statement"""
        if isinstance(node, PrintStatementNode):
            # Each string expression might need a temp
            return len(node.expressions)
        elif isinstance(node, LetStatementNode):
            # Complex concatenations need temps
            return self._count_concat_depth(node.expression)
        # Add more cases as needed
        return 1

    def _count_concat_depth(self, expr) -> int:
        """Count depth of concatenation operations"""
        if isinstance(expr, BinaryOpNode) and expr.operator == TokenType.PLUS:
            # For string concatenation
            left_depth = self._count_concat_depth(expr.left)
            right_depth = self._count_concat_depth(expr.right)
            return left_depth + right_depth + 1
        return 0

    def _mangle_string_name(self, basic_name: str) -> str:
        """Convert BASIC string variable name to valid C identifier for defines"""
        # Remove $ suffix and make uppercase for defines
        name = basic_name.rstrip('$').upper()
        # Replace any non-alphanumeric with underscore
        name = ''.join(c if c.isalnum() else '_' for c in name)
        return name

    def _count_gosubs(self, program: ProgramNode):
        """Count total number of GOSUB statements in the program"""
        self.total_gosubs = 0
        for line_node in program.lines:
            for stmt in line_node.statements:
                if isinstance(stmt, GosubStatementNode):
                    self.total_gosubs += 1

    def _collect_line_labels(self, program: ProgramNode):
        """
        Collect all line numbers that need labels (referenced by GOTO, GOSUB, etc.)
        For now, we'll label all lines to keep it simple.
        """
        for line_node in program.lines:
            self.line_labels.add(line_node.line_number)

    def _generate_variable_declarations(self) -> List[str]:
        """Generate C variable declarations from symbol table"""
        decls = []

        # Group by type for cleaner output
        integers = []
        singles = []
        doubles = []

        for var_name, var_info in self.symbols.variables.items():
            if var_info.is_array:
                # Skip arrays for now - not fully supported
                continue

            # Skip string variables - they're handled by mb25_string system
            if var_info.var_type == VarType.STRING:
                continue

            c_name = self._mangle_variable_name(var_name)

            if var_info.var_type == VarType.INTEGER:
                integers.append(c_name)
            elif var_info.var_type == VarType.SINGLE:
                singles.append(c_name)
            elif var_info.var_type == VarType.DOUBLE:
                doubles.append(c_name)

        # Generate declarations
        if integers:
            decls.append(self.indent() + 'int ' + ', '.join(integers) + ';')
        if singles:
            decls.append(self.indent() + 'float ' + ', '.join(singles) + ';')
        if doubles:
            decls.append(self.indent() + 'double ' + ', '.join(doubles) + ';')

        # Add buffer for INPUT if we have strings
        if self.string_count > 0:
            decls.append(self.indent() + 'char input_buffer[256];  /* For INPUT statements */')

        return decls

    def _mangle_variable_name(self, basic_name: str) -> str:
        """
        Convert BASIC variable name to valid C identifier.

        BASIC allows names like "I!", "COUNT%", "VALUE#"
        C needs alphanumeric + underscore, no type suffixes.

        Transformations applied:
        1. Remove type suffix (!%#$)
        2. Convert to lowercase for consistency
        3. Add 'v_' prefix if name conflicts with C keywords
        """
        # Remove type suffix
        name = basic_name.rstrip('!%#$')

        # Make lowercase for consistency
        name = name.lower()

        # Add prefix to avoid C keyword conflicts
        if name in ('int', 'float', 'double', 'char', 'void', 'if', 'for', 'while', 'return'):
            name = 'v_' + name

        return name

    def _generate_line(self, line_node: LineNode) -> List[str]:
        """Generate code for one line of BASIC"""
        code = []

        # Add line label if needed
        if line_node.line_number in self.line_labels:
            # Use goto label syntax: line_100:
            code.append(f'line_{line_node.line_number}:')

        # Generate code for each statement on the line
        for stmt in line_node.statements:
            stmt_code = self._generate_statement(stmt)
            if stmt_code:
                code.extend(stmt_code)

        return code

    def _generate_statement(self, stmt: Any) -> List[str]:
        """Generate code for a single statement"""
        if isinstance(stmt, PrintStatementNode):
            return self._generate_print(stmt)
        elif isinstance(stmt, ForStatementNode):
            return self._generate_for(stmt)
        elif isinstance(stmt, NextStatementNode):
            return self._generate_next(stmt)
        elif isinstance(stmt, LetStatementNode):
            return self._generate_assignment(stmt)
        elif isinstance(stmt, InputStatementNode):
            return self._generate_input(stmt)
        elif isinstance(stmt, EndStatementNode):
            return self._generate_end(stmt)
        elif isinstance(stmt, RemarkStatementNode):
            return self._generate_remark(stmt)
        elif isinstance(stmt, WhileStatementNode):
            return self._generate_while(stmt)
        elif isinstance(stmt, WendStatementNode):
            return self._generate_wend(stmt)
        elif isinstance(stmt, GotoStatementNode):
            return self._generate_goto(stmt)
        elif isinstance(stmt, GosubStatementNode):
            return self._generate_gosub(stmt)
        elif isinstance(stmt, ReturnStatementNode):
            return self._generate_return(stmt)
        else:
            # Unsupported statement
            self.warnings.append(f"Unsupported statement type: {type(stmt).__name__}")
            return [self.indent() + f'/* Unsupported: {type(stmt).__name__} */']

    def _get_expression_type(self, expr: Any) -> VarType:
        """Determine the type of an expression"""
        if isinstance(expr, NumberNode):
            # Check if it's a float or integer
            if isinstance(expr.value, float) and expr.value != int(expr.value):
                return VarType.SINGLE  # Default float type
            else:
                return VarType.INTEGER
        elif isinstance(expr, StringNode):
            return VarType.STRING
        elif isinstance(expr, VariableNode):
            var_name = expr.name.upper()
            if var_name in self.symbols.variables:
                return self.symbols.variables[var_name].var_type
            else:
                return VarType.SINGLE  # Default
        elif isinstance(expr, BinaryOpNode):
            # For string concatenation
            left_type = self._get_expression_type(expr.left)
            if left_type == VarType.STRING:
                return VarType.STRING
            # For numeric operations
            return left_type
        elif isinstance(expr, FunctionCallNode):
            # String functions (parser removes $ from function names)
            if expr.name.upper() in ('LEFT', 'RIGHT', 'MID', 'CHR', 'STR', 'STRING'):
                return VarType.STRING
            # LEN returns integer
            elif expr.name.upper() == 'LEN':
                return VarType.INTEGER
            # ASC returns integer
            elif expr.name.upper() == 'ASC':
                return VarType.INTEGER
            # VAL returns numeric
            elif expr.name.upper() == 'VAL':
                return VarType.SINGLE
            else:
                return VarType.SINGLE  # Default for other functions
        else:
            return VarType.SINGLE  # Default

    def _get_format_specifier(self, var_type: VarType) -> str:
        """Get printf format specifier for a variable type"""
        if var_type == VarType.INTEGER:
            return '%d'
        elif var_type == VarType.SINGLE:
            return '%g'  # %g uses shortest representation (no trailing zeros)
        elif var_type == VarType.DOUBLE:
            return '%lg'  # %lg for double
        elif var_type == VarType.STRING:
            return '%s'
        else:
            return '%g'

    def _generate_print(self, stmt: PrintStatementNode) -> List[str]:
        """Generate PRINT statement code"""
        code = []

        if stmt.file_number:
            self.warnings.append("PRINT to file not supported yet")
            return [self.indent() + '/* PRINT to file not supported */']

        # Print each expression with appropriate format
        for i, expr in enumerate(stmt.expressions):
            separator = stmt.separators[i] if i < len(stmt.separators) else None

            # Determine format based on expression type
            expr_type = self._get_expression_type(expr)

            if expr_type == VarType.STRING:
                # For strings, need to convert to C string
                str_expr = self._generate_string_expression(expr)
                code.append(self.indent() + '{')
                self.indent_level += 1
                code.append(self.indent() + f'char *temp_str = mb25_to_c_string({str_expr});')
                code.append(self.indent() + 'if (temp_str) {')
                self.indent_level += 1

                if separator == ';':
                    code.append(self.indent() + 'printf("%s", temp_str);')
                elif separator == ',':
                    code.append(self.indent() + 'printf("%s ", temp_str);')
                else:
                    code.append(self.indent() + 'printf("%s\\n", temp_str);')

                code.append(self.indent() + 'free(temp_str);')
                self.indent_level -= 1
                code.append(self.indent() + '}')
                self.indent_level -= 1
                code.append(self.indent() + '}')
            else:
                # Numeric types
                c_expr = self._generate_expression(expr)
                fmt = self._get_format_specifier(expr_type)

                if separator == ';':
                    code.append(self.indent() + f'printf("{fmt}", {c_expr});')
                elif separator == ',':
                    code.append(self.indent() + f'printf("{fmt} ", {c_expr});')
                else:
                    code.append(self.indent() + f'printf("{fmt}\\n", {c_expr});')

        # If no expressions or last separator was ; add newline
        if not stmt.expressions or (stmt.separators and stmt.separators[-1] != ';'):
            if not stmt.expressions:
                code.append(self.indent() + 'printf("\\n");')

        return code

    def _generate_for(self, stmt: ForStatementNode) -> List[str]:
        """Generate FOR loop code"""
        code = []

        var_name = self._mangle_variable_name(stmt.variable.name)
        start = self._generate_expression(stmt.start_expr)
        end = self._generate_expression(stmt.end_expr)
        step = '1'
        if stmt.step_expr:
            step = self._generate_expression(stmt.step_expr)

        # Generate C for loop
        # BASIC: FOR I = 1 TO 10 STEP 2
        # C: for (i = 1; i <= 10; i += 2)

        # Determine comparison operator based on step
        # LIMITATION: Currently only handles positive steps correctly
        # Negative steps (e.g., FOR I = 10 TO 1 STEP -1) would generate incorrect C code
        # and loop indefinitely. This is a known limitation that requires runtime step detection.
        comp = '<='

        code.append(self.indent() + f'for ({var_name} = {start}; {var_name} {comp} {end}; {var_name} += {step}) {{')
        self.indent_level += 1

        return code

    def _generate_next(self, stmt: NextStatementNode) -> List[str]:
        """Generate NEXT statement (close FOR loop)"""
        self.indent_level -= 1
        return [self.indent() + '}']

    def _generate_assignment(self, stmt: LetStatementNode) -> List[str]:
        """Generate assignment statement"""
        # Check if it's a string assignment
        var_type = self._get_expression_type(stmt.variable)

        if var_type == VarType.STRING:
            # String assignment
            var_str_id = self._get_string_id(stmt.variable.name)

            if isinstance(stmt.expression, StringNode):
                # String literal assignment
                return [self.indent() + f'mb25_string_alloc_const({var_str_id}, "{self._escape_string(stmt.expression.value)}");']
            elif isinstance(stmt.expression, VariableNode):
                # Simple variable copy
                src_str_id = self._get_string_id(stmt.expression.name)
                return [self.indent() + f'mb25_string_copy({var_str_id}, {src_str_id});']
            elif isinstance(stmt.expression, FunctionCallNode):
                # String function result
                func_code = self._generate_string_function_statement(stmt.expression, var_str_id)
                return [self.indent() + f'{func_code};']
            elif isinstance(stmt.expression, BinaryOpNode) and stmt.expression.operator == TokenType.PLUS:
                # String concatenation - generate step by step
                return self._generate_concat_assignment(var_str_id, stmt.expression)
            else:
                # Other string expression
                self.warnings.append(f"Unsupported string expression: {type(stmt.expression).__name__}")
                return [self.indent() + f'/* Unsupported string expression */']
        else:
            # Numeric assignment
            var_name = self._mangle_variable_name(stmt.variable.name)
            expr = self._generate_expression(stmt.expression)
            return [self.indent() + f'{var_name} = {expr};']

    def _generate_input(self, stmt: InputStatementNode) -> List[str]:
        """Generate INPUT statement"""
        code = []

        if stmt.file_number:
            self.warnings.append("INPUT from file not supported yet")
            return [self.indent() + '/* INPUT from file not supported */']

        # Generate prompt
        if stmt.prompt:
            # Check if it's a string literal
            if isinstance(stmt.prompt, StringNode):
                prompt_str = stmt.prompt.value
            else:
                # For expressions, we'd need to evaluate - not implemented yet
                prompt_str = ""
                self.warnings.append("Complex prompt expressions not yet supported")

            # Add question mark if not suppressed
            if not stmt.suppress_question:
                prompt_str += "? "

            code.append(self.indent() + f'printf("{self._escape_string(prompt_str)}");')
        elif not stmt.suppress_question:
            # No prompt but show "? " unless suppressed
            code.append(self.indent() + 'printf("? ");')

        # Generate input for each variable
        for i, var_node in enumerate(stmt.variables):
            var_type = self._get_expression_type(var_node)

            if var_type == VarType.STRING:
                # String input
                var_str_id = self._get_string_id(var_node.name)
                code.append(self.indent() + 'if (fgets(input_buffer, 256, stdin)) {')
                self.indent_level += 1
                code.append(self.indent() + 'size_t len = strlen(input_buffer);')
                code.append(self.indent() + 'if (len > 0 && input_buffer[len-1] == \'\\n\') {')
                self.indent_level += 1
                code.append(self.indent() + 'input_buffer[len-1] = \'\\0\';')
                self.indent_level -= 1
                code.append(self.indent() + '}')
                code.append(self.indent() + f'mb25_string_alloc_init({var_str_id}, input_buffer);')
                self.indent_level -= 1
                code.append(self.indent() + '}')
            else:
                # Numeric input
                var_name = self._mangle_variable_name(var_node.name)
                if var_type == VarType.INTEGER:
                    code.append(self.indent() + f'scanf("%d", &{var_name});')
                else:
                    code.append(self.indent() + f'scanf("%f", &{var_name});')

            # If there are more variables, show another prompt
            if i < len(stmt.variables) - 1:
                code.append(self.indent() + 'printf("?? ");  /* Next variable prompt */')

        return code

    def _generate_end(self, stmt: EndStatementNode) -> List[str]:
        """Generate END statement"""
        return [self.indent() + 'return 0;']

    def _generate_remark(self, stmt: RemarkStatementNode) -> List[str]:
        """Generate REM statement as C comment"""
        # Convert BASIC comment to C comment
        comment_text = stmt.text.strip()
        if comment_text:
            return [self.indent() + f'/* {comment_text} */']
        else:
            return []  # Empty comment, skip it

    def _generate_while(self, stmt: WhileStatementNode) -> List[str]:
        """Generate WHILE statement"""
        code = []
        condition = self._generate_expression(stmt.condition)
        code.append(self.indent() + f'while ({condition}) {{')
        self.indent_level += 1
        return code

    def _generate_wend(self, stmt: WendStatementNode) -> List[str]:
        """Generate WEND statement (close WHILE loop)"""
        self.indent_level -= 1
        return [self.indent() + '}']

    def _generate_goto(self, stmt: GotoStatementNode) -> List[str]:
        """Generate GOTO statement"""
        return [self.indent() + f'goto line_{stmt.line_number};']

    def _generate_gosub(self, stmt: GosubStatementNode) -> List[str]:
        """Generate GOSUB statement with proper return mechanism"""
        code = []
        # Each GOSUB gets a unique return label
        return_id = self.gosub_return_counter
        self.gosub_return_counter += 1

        # Push return ID onto stack
        code.append(self.indent() + f'gosub_stack[gosub_sp++] = {return_id};  /* Push return ID */')
        code.append(self.indent() + f'goto line_{stmt.line_number};  /* Jump to subroutine */')
        code.append(f'gosub_return_{return_id}:  /* Return point */')
        return code

    def _generate_return(self, stmt: ReturnStatementNode) -> List[str]:
        """Generate RETURN statement"""
        code = []
        # Pop return ID from stack and jump to appropriate return point
        code.append(self.indent() + 'if (gosub_sp > 0) {')
        self.indent_level += 1
        code.append(self.indent() + 'switch (gosub_stack[--gosub_sp]) {')
        self.indent_level += 1

        # Generate case statements for each GOSUB in the program
        # (iterating over GOSUB count from the first pass)
        for return_id in range(self.total_gosubs):
            code.append(self.indent() + f'case {return_id}: goto gosub_return_{return_id};')

        # Default case (should never happen if program is correct)
        code.append(self.indent() + 'default: break;  /* Error: invalid return address */')

        self.indent_level -= 1
        code.append(self.indent() + '}')
        self.indent_level -= 1
        code.append(self.indent() + '}')
        return code

    def _generate_expression(self, expr: Any) -> str:
        """Generate C code for an expression"""
        # Check if it's a string expression
        expr_type = self._get_expression_type(expr)
        if expr_type == VarType.STRING:
            # This shouldn't be called for strings - use _generate_string_expression
            self.warnings.append("String expression in numeric context")
            return '0  /* string in numeric context */'

        if isinstance(expr, NumberNode):
            # Format numbers appropriately - if it's a whole number, output as integer
            if isinstance(expr.value, (int, float)) and expr.value == int(expr.value):
                return str(int(expr.value))
            else:
                return str(expr.value)
        elif isinstance(expr, VariableNode):
            return self._mangle_variable_name(expr.name)
        elif isinstance(expr, BinaryOpNode):
            return self._generate_binary_op(expr)
        elif isinstance(expr, UnaryOpNode):
            return self._generate_unary_op(expr)
        elif isinstance(expr, FunctionCallNode):
            return self._generate_function_call(expr)
        else:
            self.warnings.append(f"Unsupported expression type: {type(expr).__name__}")
            return '0  /* unsupported expression */'

    def _generate_string_expression(self, expr: Any) -> str:
        """Generate C code for a string expression"""
        if isinstance(expr, StringNode):
            # String literal - allocate as constant
            temp_id = self._get_temp_string_id()
            return f'mb25_string_alloc_const({temp_id}, "{self._escape_string(expr.value)}"), {temp_id}'
        elif isinstance(expr, VariableNode):
            # String variable reference
            return self._get_string_id(expr.name)
        elif isinstance(expr, BinaryOpNode) and expr.operator == TokenType.PLUS:
            # String concatenation
            left_str = self._generate_string_expression(expr.left)
            right_str = self._generate_string_expression(expr.right)
            result_id = self._get_temp_string_id()
            return f'mb25_string_concat({result_id}, {left_str}, {right_str}), {result_id}'
        elif isinstance(expr, FunctionCallNode):
            return self._generate_string_function(expr)
        else:
            self.warnings.append(f"Unsupported string expression: {type(expr).__name__}")
            return '0  /* unsupported string expression */'

    def _generate_string_function(self, expr: FunctionCallNode) -> str:
        """Generate code for string functions"""
        func_name = expr.name.upper()
        result_id = self._get_temp_string_id()

        if func_name == 'LEFT':
            if len(expr.arguments) != 2:
                self.warnings.append("LEFT$ requires 2 arguments")
                return '0'
            str_arg = self._generate_string_expression(expr.arguments[0])
            len_arg = self._generate_expression(expr.arguments[1])
            return f'mb25_string_left({result_id}, {str_arg}, {len_arg}), {result_id}'

        elif func_name == 'RIGHT':
            if len(expr.arguments) != 2:
                self.warnings.append("RIGHT$ requires 2 arguments")
                return '0'
            str_arg = self._generate_string_expression(expr.arguments[0])
            len_arg = self._generate_expression(expr.arguments[1])
            return f'mb25_string_right({result_id}, {str_arg}, {len_arg}), {result_id}'

        elif func_name == 'MID':
            if len(expr.arguments) < 2 or len(expr.arguments) > 3:
                self.warnings.append("MID$ requires 2 or 3 arguments")
                return '0'
            str_arg = self._generate_string_expression(expr.arguments[0])
            start_arg = self._generate_expression(expr.arguments[1])
            if len(expr.arguments) == 3:
                len_arg = self._generate_expression(expr.arguments[2])
                return f'mb25_string_mid({result_id}, {str_arg}, {start_arg}, {len_arg}), {result_id}'
            else:
                # MID$ without length - to end of string
                return f'mb25_string_mid({result_id}, {str_arg}, {start_arg}, 255), {result_id}'

        elif func_name == 'CHR':
            if len(expr.arguments) != 1:
                self.warnings.append("CHR$ requires 1 argument")
                return '0'
            code_arg = self._generate_expression(expr.arguments[0])
            # Create a single-character string
            return f'({{ char _chr[2] = {{(char){code_arg}, \'\\0\'}}; mb25_string_alloc_init({result_id}, _chr); }}), {result_id}'

        else:
            self.warnings.append(f"Unsupported string function: {func_name}")
            return '0'

    def _generate_function_call(self, expr: FunctionCallNode) -> str:
        """Generate code for numeric function calls"""
        func_name = expr.name.upper()

        if func_name == 'LEN':
            if len(expr.arguments) != 1:
                self.warnings.append("LEN requires 1 argument")
                return '0'
            str_arg = self._generate_string_expression(expr.arguments[0])
            return f'mb25_get_length({str_arg})'

        elif func_name == 'ASC':
            if len(expr.arguments) != 1:
                self.warnings.append("ASC requires 1 argument")
                return '0'
            str_arg = self._generate_string_expression(expr.arguments[0])
            return f'({{ uint8_t *_data = mb25_get_data({str_arg}); (_data && mb25_get_length({str_arg}) > 0) ? _data[0] : 0; }})'

        elif func_name == 'VAL':
            if len(expr.arguments) != 1:
                self.warnings.append("VAL requires 1 argument")
                return '0'
            str_arg = self._generate_string_expression(expr.arguments[0])
            return f'({{ char *_s = mb25_to_c_string({str_arg}); double _v = _s ? atof(_s) : 0; if (_s) free(_s); _v; }})'

        else:
            # Other numeric functions (SIN, COS, etc.)
            self.warnings.append(f"Function {func_name} not yet implemented")
            return '0'

    def _get_string_id(self, var_name: str) -> str:
        """Get the string ID for a variable"""
        upper_name = var_name.upper()
        if upper_name in self.string_ids:
            return f'STR_{self._mangle_string_name(upper_name)}'
        else:
            self.warnings.append(f"Unknown string variable: {var_name}")
            return '0'

    def _get_temp_string_id(self) -> str:
        """Allocate a temporary string ID"""
        # Reuse temporaries within a statement
        base_temp = self.string_ids.get('_TEMP_BASE', 0)
        # Use modulo to wrap around and reuse temps
        temp_offset = (self.next_temp_id - base_temp) % self.max_temps_per_statement
        temp_id = base_temp + temp_offset
        self.next_temp_id += 1
        return str(temp_id)

    def _reset_temp_strings(self):
        """Reset temporary string allocation for next statement"""
        self.next_temp_id = self.string_ids.get('_TEMP_BASE', 0)

    def _escape_string(self, s: str) -> str:
        """Escape a string for C"""
        # Basic escaping for C strings
        s = s.replace('\\', '\\\\')
        s = s.replace('"', '\\"')
        s = s.replace('\n', '\\n')
        s = s.replace('\r', '\\r')
        s = s.replace('\t', '\\t')
        return s

    def _generate_string_function_statement(self, expr: FunctionCallNode, result_id: str) -> str:
        """Generate code for string function directly into result variable"""
        func_name = expr.name.upper()

        if func_name == 'LEFT':
            if len(expr.arguments) != 2:
                self.warnings.append("LEFT$ requires 2 arguments")
                return '/* LEFT$ error */'
            str_arg = self._get_string_var_id(expr.arguments[0])
            len_arg = self._generate_expression(expr.arguments[1])
            return f'mb25_string_left({result_id}, {str_arg}, {len_arg})'

        elif func_name == 'RIGHT':
            if len(expr.arguments) != 2:
                self.warnings.append("RIGHT$ requires 2 arguments")
                return '/* RIGHT$ error */'
            str_arg = self._get_string_var_id(expr.arguments[0])
            len_arg = self._generate_expression(expr.arguments[1])
            return f'mb25_string_right({result_id}, {str_arg}, {len_arg})'

        elif func_name == 'MID':
            if len(expr.arguments) < 2 or len(expr.arguments) > 3:
                self.warnings.append("MID$ requires 2 or 3 arguments")
                return '/* MID$ error */'
            str_arg = self._get_string_var_id(expr.arguments[0])
            start_arg = self._generate_expression(expr.arguments[1])
            if len(expr.arguments) == 3:
                len_arg = self._generate_expression(expr.arguments[2])
                return f'mb25_string_mid({result_id}, {str_arg}, {start_arg}, {len_arg})'
            else:
                return f'mb25_string_mid({result_id}, {str_arg}, {start_arg}, 255)'

        elif func_name == 'CHR':
            if len(expr.arguments) != 1:
                self.warnings.append("CHR$ requires 1 argument")
                return '/* CHR$ error */'
            code_arg = self._generate_expression(expr.arguments[0])
            return f'{{ char _chr[2] = {{(char){code_arg}, \'\\0\'}}; mb25_string_alloc_init({result_id}, _chr); }}'

        else:
            self.warnings.append(f"Unsupported string function: {func_name}")
            return '/* unsupported function */'

    def _get_string_var_id(self, expr) -> str:
        """Get string ID for a variable or expression"""
        if isinstance(expr, VariableNode):
            return self._get_string_id(expr.name)
        else:
            # For complex expressions, need to evaluate into temp
            return self._generate_string_expression(expr)

    def _generate_concat_assignment(self, dest_id: str, expr: BinaryOpNode) -> List[str]:
        """Generate string concatenation assignment step by step"""
        code = []
        self._reset_temp_strings()  # Reset temp allocation

        # Collect all concatenated parts
        parts = []
        self._collect_concat_parts(expr, parts)

        # Generate concatenation steps
        if len(parts) == 2:
            # Simple two-part concat
            left_id = self._get_concat_part_id(parts[0])
            right_id = self._get_concat_part_id(parts[1])
            code.append(self.indent() + f'mb25_string_concat({dest_id}, {left_id}, {right_id});')
        else:
            # Multi-part concatenation - do it step by step
            temp1 = self._get_temp_string_id()
            left_id = self._get_concat_part_id(parts[0])
            right_id = self._get_concat_part_id(parts[1])
            code.append(self.indent() + f'mb25_string_concat({temp1}, {left_id}, {right_id});')

            for i in range(2, len(parts) - 1):
                temp2 = self._get_temp_string_id()
                part_id = self._get_concat_part_id(parts[i])
                code.append(self.indent() + f'mb25_string_concat({temp2}, {temp1}, {part_id});')
                temp1 = temp2

            # Final concat into destination
            last_id = self._get_concat_part_id(parts[-1])
            code.append(self.indent() + f'mb25_string_concat({dest_id}, {temp1}, {last_id});')

        return code

    def _collect_concat_parts(self, expr, parts):
        """Recursively collect all parts of a concatenation"""
        if isinstance(expr, BinaryOpNode) and expr.operator == TokenType.PLUS:
            self._collect_concat_parts(expr.left, parts)
            self._collect_concat_parts(expr.right, parts)
        else:
            parts.append(expr)

    def _get_concat_part_id(self, expr) -> str:
        """Get string ID for a concatenation part"""
        if isinstance(expr, StringNode):
            temp_id = self._get_temp_string_id()
            # Need to allocate the constant first
            return f'(mb25_string_alloc_const({temp_id}, "{self._escape_string(expr.value)}"), {temp_id})'
        elif isinstance(expr, VariableNode):
            return self._get_string_id(expr.name)
        else:
            return self._generate_string_expression(expr)

    def _generate_binary_op(self, expr: BinaryOpNode) -> str:
        """Generate C code for binary operation"""
        left = self._generate_expression(expr.left)
        right = self._generate_expression(expr.right)

        # Map BASIC operators to C operators
        op_map = {
            TokenType.PLUS: '+',
            TokenType.MINUS: '-',
            TokenType.MULTIPLY: '*',
            TokenType.DIVIDE: '/',
            TokenType.POWER: '**',  # Need to handle this specially
            TokenType.EQUAL: '==',
            TokenType.NOT_EQUAL: '!=',
            TokenType.LESS_THAN: '<',
            TokenType.LESS_EQUAL: '<=',
            TokenType.GREATER_THAN: '>',
            TokenType.GREATER_EQUAL: '>=',
        }

        c_op = op_map.get(expr.operator, '?')

        # Special handling for power operator (not in C)
        if expr.operator == TokenType.POWER:
            # Use pow() function from math.h
            return f'pow({left}, {right})'

        return f'({left} {c_op} {right})'

    def _generate_unary_op(self, expr: UnaryOpNode) -> str:
        """Generate C code for unary operation"""
        operand = self._generate_expression(expr.operand)

        if expr.operator == TokenType.MINUS:
            return f'(-{operand})'
        elif expr.operator == TokenType.PLUS:
            return f'(+{operand})'
        else:
            return operand
