#!/usr/bin/env python3
"""
MBASIC 5.21 Interpreter

Usage:
    ./mbasic                                  # Interactive mode (curses screen editor)
    ./mbasic program.bas                      # Execute program
    ./mbasic --ui curses                      # Curses text UI (urwid, full-screen terminal) (default)
    ./mbasic --ui cli                         # CLI backend (line-based)
    ./mbasic --ui tk                          # Tkinter GUI (graphical)
    ./mbasic --ui web                         # Web UI (browser-based)
    ./mbasic --ui web --port 3000             # Web UI on custom port
    ./mbasic --debug                          # Enable debug output
"""

import sys
import os
import argparse
import importlib
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / 'src'))

from parser import TypeInfo


def list_backends():
    """Check which backends are available and print status"""
    backends = {
        'cli': {
            'name': 'CLI',
            'description': 'Line-based command interface',
            'module': None,  # Built-in, always available
            'install': None
        },
        'curses': {
            'name': 'Curses',
            'description': 'Full-screen terminal UI',
            'module': 'urwid',
            'install': 'pip install mbasic[curses]'
        },
        'tk': {
            'name': 'Tkinter',
            'description': 'Graphical UI',
            'module': 'tkinter',
            'install': 'Included with Python (may need: apt install python3-tk)'
        },
        'web': {
            'name': 'Web',
            'description': 'Web-based UI (NiceGUI)',
            'module': 'nicegui',
            'install': 'pip install nicegui'
        },
    }

    print("Available MBASIC backends:\n")
    for name, info in backends.items():
        status = "✓ Available"
        install_help = ""

        # Check if module is available
        if info['module']:
            try:
                __import__(info['module'])
            except ImportError:
                status = "✗ Not available"
                if info['install']:
                    install_help = f" ({info['install']})"

        print(f"  {name:10} {info['name']:12} {info['description']:30} {status}{install_help}")

    print("\nUsage: ./mbasic --ui <name>")


def create_default_def_type_map():
    """Create default DEF type map (all SINGLE precision)"""
    def_type_map = {}
    for letter in 'abcdefghijklmnopqrstuvwxyz':
        def_type_map[letter] = TypeInfo.SINGLE
    return def_type_map


def compile_to_javascript(input_file, output_file, generate_html=False, debug=False):
    """Compile BASIC program to JavaScript

    Args:
        input_file: Path to BASIC source file
        output_file: Path to output JavaScript file
        generate_html: Also generate HTML wrapper
        debug: Enable debug output
    """
    try:
        # Import required modules
        from lexer import Lexer
        from parser import Parser
        from semantic_analyzer import SemanticAnalyzer
        from src.codegen_js_backend import JavaScriptBackend

        # Read source file
        with open(input_file, 'r') as f:
            source = f.read()

        if debug:
            print(f"Compiling {input_file} to JavaScript...", file=sys.stderr)

        # Lex
        lexer = Lexer(source)
        tokens = lexer.tokenize()

        if debug:
            print(f"  Lexed {len(tokens)} tokens", file=sys.stderr)

        # Parse
        parser = Parser(tokens)
        ast = parser.parse()

        if debug:
            print(f"  Parsed {len(ast.lines)} lines", file=sys.stderr)

        # Semantic analysis
        analyzer = SemanticAnalyzer()
        success = analyzer.analyze(ast)

        if not success:
            print("Semantic analysis failed", file=sys.stderr)
            sys.exit(1)

        if debug:
            print(f"  Semantic analysis complete", file=sys.stderr)

        # Generate JavaScript
        config = {
            'source_file': os.path.basename(input_file)
        }
        backend = JavaScriptBackend(analyzer.symbols, config)
        js_code = backend.generate(ast)

        # Write JavaScript file
        with open(output_file, 'w') as f:
            f.write(js_code)

        # Make executable
        os.chmod(output_file, 0o755)

        print(f"Generated JavaScript: {output_file}")

        # Generate HTML wrapper if requested
        if generate_html:
            html_file = output_file.replace('.js', '.html')
            generate_html_wrapper(output_file, html_file, os.path.basename(input_file))
            print(f"Generated HTML wrapper: {html_file}")

    except FileNotFoundError:
        print(f"Error: File not found: {input_file}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        if debug:
            import traceback
            traceback.print_exc()
        else:
            print(f"Compilation error: {e}", file=sys.stderr)
        sys.exit(1)


def sanitize_cpm_filename(name):
    """Sanitize filename for CP/M 8.3 format.

    CP/M filenames must:
    - Be max 8 characters (before extension)
    - Use only A-Z, 0-9 (no underscores, hyphens, etc.)
    - tnylpo requires lowercase filenames

    Args:
        name: Input filename (without extension)

    Returns:
        Sanitized filename suitable for tnylpo/CP/M
    """
    import re
    # Remove extension if present
    name = os.path.splitext(name)[0]
    # Replace underscores/hyphens with nothing
    name = re.sub(r'[_\-]', '', name)
    # Keep only alphanumeric
    name = re.sub(r'[^a-zA-Z0-9]', '', name)
    # Truncate to 8 characters
    name = name[:8]
    # Lowercase (tnylpo requires this)
    name = name.lower()
    # Default if empty
    if not name:
        name = 'program'
    return name


def compile_to_c(input_file, output_file, cpu='z80', run=False, debug=False):
    """Compile BASIC program to C for z88dk/CP/M

    Args:
        input_file: Path to BASIC source file
        output_file: Path to output (without extension - generates .c and .com)
        cpu: Target CPU - 'z80' (default) or '8080'
        run: Run the compiled program with tnylpo after compilation
        debug: Enable debug output
    """
    import subprocess

    try:
        # Import required modules
        from lexer import Lexer
        from parser import Parser
        from semantic_analyzer import SemanticAnalyzer
        from src.codegen_backend import Z88dkCBackend

        # Read source file
        with open(input_file, 'r') as f:
            source = f.read()

        if debug:
            print(f"Compiling {input_file} to C ({cpu})...", file=sys.stderr)

        # Lex
        lexer = Lexer(source)
        tokens = lexer.tokenize()

        if debug:
            print(f"  Lexed {len(tokens)} tokens", file=sys.stderr)

        # Parse
        parser = Parser(tokens)
        ast = parser.parse()

        if debug:
            print(f"  Parsed {len(ast.lines)} lines", file=sys.stderr)

        # Semantic analysis
        analyzer = SemanticAnalyzer()
        success = analyzer.analyze(ast)

        if not success:
            print("Semantic analysis failed", file=sys.stderr)
            for err in analyzer.errors:
                print(f"  {err}", file=sys.stderr)
            sys.exit(1)

        if analyzer.warnings:
            for warn in analyzer.warnings:
                print(f"Warning: {warn}", file=sys.stderr)

        if debug:
            print(f"  Semantic analysis complete", file=sys.stderr)

        # Generate C code
        config = {
            'source_file': os.path.basename(input_file),
            'cpu_target': cpu
        }
        backend = Z88dkCBackend(analyzer.symbols, config)
        c_code = backend.generate(ast)

        # Write C file
        c_file = output_file + '.c'
        with open(c_file, 'w') as f:
            f.write(c_code)

        print(f"Generated C: {c_file}")

        # Compile with z88dk
        com_file = output_file + '.com'

        # Find runtime library path
        script_dir = os.path.dirname(os.path.abspath(__file__))
        runtime_dir = os.path.join(script_dir, 'runtime', 'strings')
        runtime_c = os.path.join(runtime_dir, 'mb25_string.c')

        if cpu == '8080':
            zcc_cmd = ['z88dk.zcc', '+cpm', '-clib=8080', '--math-mbf32',
                       f'-I{runtime_dir}', c_file, runtime_c,
                       '-o', output_file, '-create-app']
        else:
            zcc_cmd = ['z88dk.zcc', '+cpm', f'-I{runtime_dir}',
                       c_file, runtime_c, '-o', output_file, '-create-app']

        if debug:
            print(f"  Running: {' '.join(zcc_cmd)}", file=sys.stderr)

        result = subprocess.run(zcc_cmd, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"z88dk compilation failed:", file=sys.stderr)
            print(result.stderr, file=sys.stderr)
            sys.exit(1)

        print(f"Generated COM: {com_file}")

        # Run with tnylpo if requested
        if run and os.path.exists(com_file):
            # tnylpo requires CP/M 8.3 filenames - sanitize if needed
            basename = os.path.basename(output_file)
            safe_name = sanitize_cpm_filename(basename)
            run_file = com_file

            # If filename isn't CP/M safe, copy to safe name in current dir
            if safe_name != basename.lower():
                import shutil
                run_file = f'{safe_name}.com'
                shutil.copy(com_file, run_file)
                if debug:
                    print(f"  Copied to CP/M-safe name: {run_file}", file=sys.stderr)

            print(f"\nRunning {run_file}...")
            print("-" * 40)
            try:
                subprocess.run(['tnylpo', run_file], check=True)
            except FileNotFoundError:
                print("tnylpo not found - install tnylpo to run CP/M programs")
                print("See docs/dev/TNYLPO_SETUP.md for installation instructions")
            except subprocess.CalledProcessError as e:
                print(f"Execution failed: {e}", file=sys.stderr)

    except FileNotFoundError:
        print(f"Error: File not found: {input_file}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        if debug:
            import traceback
            traceback.print_exc()
        else:
            print(f"Compilation error: {e}", file=sys.stderr)
        sys.exit(1)


def generate_html_wrapper(js_file, html_file, source_name):
    """Generate HTML wrapper for JavaScript output

    Args:
        js_file: Path to JavaScript file
        html_file: Path to output HTML file
        source_name: Name of BASIC source file (for title)
    """
    js_basename = os.path.basename(js_file)

    html_content = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MBASIC Program: {source_name}</title>
  <style>
    body {{
      font-family: 'Courier New', monospace;
      background: black;
      color: #00ff00;
      padding: 20px;
      margin: 0;
    }}
    #output {{
      white-space: pre;
      line-height: 1.4;
    }}
    .header {{
      color: #ffff00;
      margin-bottom: 10px;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }}
  </style>
</head>
<body>
  <div class="header">MBASIC Program: {source_name}</div>
  <div id="output"></div>
  <script src="{js_basename}"></script>
</body>
</html>
"""

    with open(html_file, 'w') as f:
        f.write(html_content)


def load_backend(backend_name, io_handler, program_manager):
    """Load a UI backend dynamically using importlib

    Args:
        backend_name: Name of backend ('cli', 'curses', 'tk', 'web')
        io_handler: IOHandler instance for I/O operations
        program_manager: ProgramManager instance for program storage

    Returns:
        UIBackend instance

    Raises:
        ImportError: If backend module cannot be loaded (with helpful installation instructions)
        AttributeError: If backend doesn't have required classes
    """
    try:
        # Map backend name to module and class name
        backend_map = {
            'cli': ('src.ui.cli', 'CLIBackend'),
            'visual': ('src.ui.visual', 'VisualBackend'),
            'curses': ('src.ui.curses_ui', 'CursesBackend'),
            'tk': ('src.ui.tk_ui', 'TkBackend'),
            'web': ('src.ui.web', 'NiceGUIBackend'),
        }

        if backend_name not in backend_map:
            raise ValueError(f"Unknown backend: {backend_name}")

        module_name, class_name = backend_map[backend_name]

        # Import the backend module
        backend_module = importlib.import_module(module_name)

        # Get the backend class
        backend_class = getattr(backend_module, class_name)

        # Create and return the backend instance
        return backend_class(io_handler, program_manager)

    except ImportError as e:
        # Provide helpful installation instructions
        help_messages = {
            'tk': (
                "\nTkinter backend requires tkinter (usually included with Python).\n"
                "If missing:\n"
                "  • Debian/Ubuntu: sudo apt-get install python3-tk\n"
                "  • RHEL/Fedora:   sudo dnf install python3-tkinter\n"
                "  • macOS/Windows: Reinstall Python from python.org\n"
                "\n"
                "Alternative: Use --ui cli or --ui curses\n"
                "Run './mbasic --list-backends' to see all available UIs."
            ),
            'curses': (
                "\nCurses backend requires urwid library.\n"
                "Install with: pip install mbasic[curses]\n"
                "         or: pip install urwid>=2.0.0\n"
                "\n"
                "Alternative: Use --ui cli or --ui tk\n"
                "Run './mbasic --list-backends' to see all available UIs."
            ),
            'web': (
                "\nWeb backend requires nicegui library.\n"
                "Install with: pip install mbasic[web]\n"
                "         or: pip install nicegui>=3.2.0\n"
                "\n"
                "Alternative: Use --ui cli, --ui curses, or --ui tk\n"
                "Run './mbasic --list-backends' to see all available UIs."
            ),
        }

        error_msg = f"Failed to load backend '{backend_name}': {e}"
        if backend_name in help_messages:
            error_msg += help_messages[backend_name]

        raise ImportError(error_msg)
    except AttributeError as e:
        raise AttributeError(f"Backend '{backend_name}' does not have class '{class_name}': {e}")


def run_file(program_path, backend, debug_enabled=False):
    """Execute a BASIC program from file

    Args:
        program_path: Path to BASIC program file
        backend: UIBackend instance to use
        debug_enabled: Enable debug output
    """
    try:
        # Load the program using ProgramManager
        success, errors = backend.program.load_from_file(program_path)

        # Report any errors
        if errors:
            for line_num, error_msg in errors:
                print(f"Parse error at line {line_num}: {error_msg}", file=sys.stderr)

        if not success:
            print(f"Failed to load program: {program_path}", file=sys.stderr)
            sys.exit(1)

        # Enter interactive mode with program loaded
        # (Don't call cmd_run() here - it needs the event loop which starts in backend.start())
        backend.start()

    except FileNotFoundError:
        print(f"Error: File not found: {program_path}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        # Print traceback only in DEBUG mode
        if debug_enabled or os.environ.get('DEBUG'):
            import traceback
            traceback.print_exc()
        else:
            print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def main():
    """Main entry point with argument parsing"""
    parser = argparse.ArgumentParser(
        description='MBASIC 5.21 Interpreter',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ./mbasic                                  # Interactive mode (curses screen editor)
  ./mbasic program.bas                      # Run program and enter interactive mode
  ./mbasic --ui curses                      # Curses text UI (urwid, full-screen terminal) (default)
  ./mbasic --ui cli                         # CLI backend (line-based)
  ./mbasic --ui tk                          # Tkinter GUI (graphical)
  ./mbasic --ui web                         # Web UI (browser-based)
  ./mbasic --ui web --port 3000             # Web UI on custom port
  ./mbasic --debug                          # Enable debug output
        """
    )

    parser.add_argument(
        'program',
        nargs='?',
        help='BASIC program file to load and run'
    )

    parser.add_argument(
        '--ui',
        '--backend',  # Keep --backend as alias for backwards compatibility
        dest='backend',
        choices=['cli', 'curses', 'tk', 'web'],
        default='curses',
        help='UI to use (default: curses)'
    )

    parser.add_argument(
        '--debug',
        action='store_true',
        help='Enable debug output'
    )

    parser.add_argument(
        '--list-backends',
        action='store_true',
        help='List available backends and exit'
    )

    parser.add_argument(
        '--dump-keymap',
        action='store_true',
        help='Print keyboard shortcuts for the selected UI and exit'
    )

    parser.add_argument(
        '--port',
        type=int,
        default=8080,
        help='Port for web backend (default: 8080)'
    )

    parser.add_argument(
        '--compile-js', '--js',
        metavar='OUTPUT',
        dest='compile_js',
        help='Compile BASIC program to JavaScript (specify output file)'
    )

    parser.add_argument(
        '--html',
        action='store_true',
        help='Generate HTML wrapper for JavaScript output (use with --js)'
    )

    parser.add_argument(
        '--compile-c', '--cpm',
        metavar='OUTPUT',
        dest='compile_c',
        help='Compile BASIC program to C/Z80 for CP/M (specify output name without extension)'
    )

    parser.add_argument(
        '--cpu',
        choices=['z80', '8080'],
        default='z80',
        help='Target CPU for C compilation (default: z80)'
    )

    parser.add_argument(
        '--run',
        action='store_true',
        help='Run compiled program with tnylpo after compilation (use with --compile-c)'
    )

    args = parser.parse_args()

    # Handle --list-backends first (exit after showing)
    if args.list_backends:
        list_backends()
        sys.exit(0)

    # Handle --dump-keymap (exit after showing)
    if args.dump_keymap:
        from src.ui.keybinding_loader import dump_keymap
        dump_keymap(args.backend)
        sys.exit(0)

    # Handle --compile-js (compile and exit)
    if args.compile_js:
        if not args.program:
            print("Error: --compile-js requires a BASIC program file", file=sys.stderr)
            sys.exit(1)

        compile_to_javascript(
            args.program,
            args.compile_js,
            generate_html=args.html,
            debug=args.debug
        )
        sys.exit(0)

    # Handle --compile-c (compile to C/Z80 and exit)
    if args.compile_c:
        if not args.program:
            print("Error: --compile-c requires a BASIC program file", file=sys.stderr)
            sys.exit(1)

        compile_to_c(
            args.program,
            args.compile_c,
            cpu=args.cpu,
            run=args.run,
            debug=args.debug
        )
        sys.exit(0)

    # Create I/O handler based on backend choice
    if args.backend == 'cli':
        from iohandler.console import ConsoleIOHandler
        io_handler = ConsoleIOHandler(debug_enabled=args.debug)
    elif args.backend == 'curses':
        # Curses backend creates its own CursesIOHandler internally
        # Pass a dummy handler for initialization (will be replaced)
        from iohandler.console import ConsoleIOHandler
        io_handler = ConsoleIOHandler(debug_enabled=args.debug)
    elif args.backend == 'tk':
        # Tk backend uses console I/O for now (will implement TkIOHandler later)
        from iohandler.console import ConsoleIOHandler
        io_handler = ConsoleIOHandler(debug_enabled=args.debug)
    elif args.backend == 'visual':
        # Visual backend uses console I/O (stub)
        from iohandler.console import ConsoleIOHandler
        io_handler = ConsoleIOHandler(debug_enabled=args.debug)
        print("Note: Visual backend is a stub, using console I/O")
    else:
        # Fallback to console I/O
        from iohandler.console import ConsoleIOHandler
        io_handler = ConsoleIOHandler(debug_enabled=args.debug)

    # Create program manager
    from editing import ProgramManager
    program_manager = ProgramManager(create_default_def_type_map())

    # Web backend uses per-client architecture
    if args.backend == 'web':
        from src.ui.web.nicegui_backend import start_web_ui
        try:
            start_web_ui(port=args.port)
        except KeyboardInterrupt:
            print("\n\nMBASIC Web UI: Exiting due to Ctrl+C\n")
            sys.exit(0)
        return

    # Load other backends dynamically
    try:
        backend = load_backend(args.backend, io_handler, program_manager)
    except (ImportError, AttributeError) as e:
        print(f"Error loading backend: {e}", file=sys.stderr)
        sys.exit(1)

    # Run program or enter interactive mode
    if args.program:
        run_file(args.program, backend, debug_enabled=args.debug)
    else:
        backend.start()


if __name__ == '__main__':
    main()
