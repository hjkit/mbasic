# Code Behavior Changes (v13)

Generated by splitting docs_inconsistencies_report-v13.md
Contains: Code changes that affect behavior, validation, security, or implementation

## üîß Code Issues Requiring Fixes

### üî¥ High Severity

#### Code vs Documentation inconsistency

**Description:** SandboxedFileIO methods documented as STUB but list_files() is IMPLEMENTED

**Affected files:**
- `src/file_io.py`

**Details:**
src/file_io.py SandboxedFileIO class docstring states:
"Implementation status:
- list_files(): IMPLEMENTED - delegates to backend.sandboxed_fs
- load_file(): STUB - raises IOError (requires async refactor)
- save_file(): STUB - raises IOError (requires async refactor)
- delete_file(): STUB - raises IOError (requires async refactor)
- file_exists(): STUB - raises IOError (requires async refactor)"

However, the actual implementation shows:
- list_files() is implemented and delegates to backend.sandboxed_fs
- load_file() raises: "LOAD not yet implemented in web UI - requires async refactor"
- save_file() raises: "SAVE not yet implemented in web UI - requires async refactor"
- delete_file() raises: "DELETE not yet implemented in web UI - requires async refactor"
- file_exists() raises: "File existence check not yet implemented in web UI - requires async refactor"

The documentation correctly describes the implementation status.

---
#### Code vs Documentation inconsistency

**Description:** Security warning about user_id validation is in docstring but not enforced in code

**Affected files:**
- `src/filesystem/sandboxed_fs.py`

**Details:**
src/filesystem/sandboxed_fs.py SandboxedFileSystemProvider.__init__() docstring states:
"Args:
    user_id: Unique identifier for this user/session
            SECURITY: Must be securely generated/validated (e.g., session IDs)
            to prevent cross-user access. Do NOT use user-provided values."

And in the class docstring:
"Security:
- No access to real filesystem
- No path traversal (../ etc.)
- Resource limits enforced
- Per-user isolation via user_id keys in class-level storage
  IMPORTANT: Caller must ensure user_id is securely generated/validated
  to prevent cross-user access (e.g., use session IDs, not user-provided values)"

However, the __init__() method accepts user_id without any validation:
def __init__(self, user_id: str, max_files: int = 50, max_file_size: int = 1024 * 1024):
    self.user_id = user_id
    ...

The code relies entirely on the caller to provide a secure user_id, but there's no enforcement or validation. This is a security-critical documentation vs implementation gap - the documentation warns about security but the code doesn't enforce it.

---
#### code_vs_comment

**Description:** Extensive comment block about numbered line editing describes validation checks that don't match the actual code flow

**Affected files:**
- `src/immediate_executor.py`

**Details:**
Comment at lines ~95-103 states:
'This feature requires the following UI integration:
- interpreter.interactive_mode must reference the UI object (checked with hasattr)
- UI.program must have add_line() and delete_line() methods (validated, errors if missing)
- UI._refresh_editor() method to update the display (optional, checked with hasattr)
- UI._highlight_current_statement() for restoring execution highlighting (optional, checked with hasattr)
If interactive_mode doesn't exist or is falsy, returns error: "Cannot edit program lines in this mode".
If interactive_mode exists but required program methods are missing, returns error message.'

However, the actual code (lines ~109-145) performs validation checks in a different order and with different error messages:
1. First checks 'if not hasattr(ui, "program") or not ui.program' -> returns 'UI program manager not available'
2. Then checks for add_line/delete_line methods conditionally based on whether line_content exists
3. The validation happens AFTER checking interactive_mode, not as part of the initial check

The comment describes a validation flow that doesn't match the implementation.

---
#### code_vs_comment

**Description:** Comment in _renum_erl_comparison says implementation renumbers 'ANY binary operator' but then describes this as broader than manual specifies, creating confusion about whether this is correct behavior

**Affected files:**
- `src/interactive.py`

**Details:**
Lines 636-651:
MBASIC manual specifies: if ERL appears on left side of comparison operator
(=, <>, <, >, <=, >=), the right-hand number is a line number reference.

IMPORTANT: Current implementation renumbers for ANY binary operator with ERL on left,
including arithmetic (ERL + 100, ERL * 2). This is broader than the manual specifies.

Rationale: Without semantic analysis, we cannot distinguish ERL=100 (comparison)
from ERL+100 (arithmetic) at parse time. We conservatively renumber all cases
to avoid missing valid line number references in comparisons.

Known limitation: Arithmetic like "IF ERL+100 THEN..." will incorrectly renumber
the 100 if it happens to be an old line number. This is rare in practice.

This is a documented bug/limitation being treated as acceptable behavior. The comment admits the implementation is incorrect ('incorrectly renumber') but justifies it as 'rare in practice'. This should be flagged as a known bug, not described as intentional behavior.

---
#### code_vs_comment

**Description:** Comment in _sync_program_to_runtime says 'When paused_at_breakpoint=True, we let PC reset to halted (below) so that continuing execution will properly resume from the breakpoint location', but this logic seems backwards - resetting to halted would lose the breakpoint position

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~1230:
# Restore PC only if execution is running AND not paused at breakpoint
# When paused_at_breakpoint=True, we let PC reset to halted (below) so that
# continuing execution will properly resume from the breakpoint location.
# Otherwise ensure halted (don't accidentally start execution)

Code:
if self.running and not self.paused_at_breakpoint:
    # Execution is running - preserve execution state
    self.runtime.pc = old_pc
    self.runtime.halted = old_halted
else:
    # No execution in progress - ensure halted
    self.runtime.pc = PC.halted_pc()
    self.runtime.halted = True

The comment suggests resetting PC to halted when paused_at_breakpoint=True will help resume from breakpoint, but resetting PC would lose the breakpoint location. This appears to be a logic error in either the code or comment.

---
#### code_vs_comment

**Description:** _on_status_click() docstring says it shows 'breakpoint info for ‚óè' but the implementation shows a generic message, not actual breakpoint information

**Affected files:**
- `src/ui/tk_widgets.py`

**Details:**
Docstring says: 'Handle click on status column (show error details for ?, breakpoint info for ‚óè)'

But implementation shows generic message:
messagebox.showinfo(
    f"Breakpoint on Line {line_num}",
    f"Line {line_num} has a breakpoint set.\n\nUse the debugger menu or commands to manage breakpoints."
)

This is not 'breakpoint info' - it's just a confirmation message. No actual information about the breakpoint (when set, hit count, condition, etc.) is shown.

---
#### documentation_inconsistency

**Description:** Documentation claims MBASIC supports four UI backends (CLI, Curses, Tk, Web), but the codebase shows no CLI backend implementation

**Affected files:**
- `docs/help/README.md`
- `docs/help/common/debugging.md`
- `docs/help/common/editor-commands.md`

**Details:**
docs/help/README.md states: 'MBASIC supports four UI backends: CLI (command-line interface), Curses (terminal full-screen), Tk (desktop GUI), and Web (browser-based)'

However, examining the code files provided:
- src/ui/web/session_state.py - Web UI backend
- src/ui/web/web_settings_dialog.py - Web UI backend
- src/ui/web_help_launcher.py - References 'cli' as ui_type parameter

The documentation consistently mentions CLI as a separate backend with its own help section (docs/help/ui/cli/index.md), but no CLI backend implementation is shown in the source code. The 'cli' reference in web_help_launcher.py appears to be just a parameter value, not evidence of a CLI backend.

---
#### documentation_inconsistency

**Description:** Error code reference inconsistency - CVI/CVS/CVD uses different error code format

**Affected files:**
- `docs/help/common/language/appendices/error-codes.md`
- `docs/help/common/language/functions/cvi-cvs-cvd.md`

**Details:**
cvi-cvs-cvd.md states: "Error: Raises 'Illegal function call' (error code FC/5)" using the format 'FC/5', but error-codes.md consistently uses format 'FC' with number '5' in separate columns. The dual notation 'FC/5' is not used elsewhere in error-codes.md.

---
#### documentation_inconsistency

**Description:** Contradictory information about variable name significance and case sensitivity

**Affected files:**
- `docs/help/common/language/variables.md`
- `docs/help/common/settings.md`

**Details:**
variables.md: 'Note on Variable Name Significance: In the original MBASIC 5.21, only the first 2 characters of variable names were significant (AB, ABC, and ABCDEF would be the same variable). This Python implementation uses the full variable name for identification, allowing distinct variables like COUNT and COUNTER.'

variables.md also says: 'Case Sensitivity: Variable names are not case-sensitive by default (Count = COUNT = count), but the behavior when using different cases can be configured via the variables.case_conflict setting'

settings.md: 'variables.case_conflict ... BASIC is case-insensitive by default (Count = COUNT = count are the same variable)'

The contradiction: variables.md says full names are used (COUNT != COUNTER) but also says case doesn't matter (Count = COUNT). This needs clarification about what 'full variable name' means vs case sensitivity.

---
#### documentation_inconsistency

**Description:** Contradictory information about file persistence and auto-save behavior across UIs

**Affected files:**
- `docs/help/common/ui/curses/editing.md`
- `docs/help/common/ui/tk/index.md`
- `docs/help/mbasic/extensions.md`

**Details:**
curses/editing.md states 'Save often - Don't lose your work' implying persistence, and tk/index.md says 'Use Ctrl+S often - Save your work frequently' also implying persistence. However, extensions.md clarifies that Web UI files are 'stored in server-side session memory only (not persistent across page refreshes)' but doesn't clearly state whether CLI/Tk/Curses have persistent storage. The compatibility.md doc states 'CLI, Tk, and Curses UIs - Real filesystem access' and 'CLI/Tk/Curses: Save to local filesystem (persistent)' but this critical distinction is not made clear in the UI-specific editing documentation.

---
#### documentation_inconsistency

**Description:** Web UI file storage limits documented in only one place

**Affected files:**
- `docs/help/mbasic/compatibility.md`
- `docs/help/mbasic/extensions.md`

**Details:**
compatibility.md provides detailed Web UI file storage limitations: '50 file limit, 1MB per file', 'Must be simple names (no slashes, no paths)', 'Automatically uppercased by the virtual filesystem (CP/M style)', '8.3 format recommended but not required'. extensions.md mentions '50 file limit maximum' and '1MB per file maximum' and 'No path support (simple filenames only)' but does not mention the uppercasing behavior or 8.3 format recommendation. This critical information about file naming behavior should be consistent across both documents.

---
#### documentation_inconsistency

**Description:** LPRINT statement support is contradictory between documents

**Affected files:**
- `docs/help/mbasic/features.md`
- `docs/help/mbasic/not-implemented.md`

**Details:**
features.md states under 'Input/Output' section:
'LPRINT - Line printer output (Note: LPRINT statement is supported, but WIDTH LPRINT syntax is not)'

This implies LPRINT is implemented.

However, not-implemented.md does not list LPRINT as unsupported, which is consistent with features.md.

But the parenthetical note about 'WIDTH LPRINT syntax is not' supported is unclear - it's not clear if this is a limitation of the LPRINT implementation or a separate WIDTH statement issue.

---
#### documentation_inconsistency

**Description:** Web UI file storage limitations may be outdated or incorrect

**Affected files:**
- `docs/help/mbasic/features.md`

**Details:**
features.md 'Web UI' section states:
'Session-based storage - Files persist during browser session only (lost on page refresh)'
'In-memory filesystem - Virtual filesystem with limitations:
  - 50 file limit maximum
  - 1MB per file maximum
  - No path support (simple filenames only)
  - No persistent storage across sessions'

This describes very specific technical limitations (50 files, 1MB, no persistence). These numbers seem arbitrary and may be:
1. Outdated from an earlier implementation
2. Configurable values that should be documented as defaults
3. Incorrect if the Web UI was never fully implemented

Needs verification against actual Web UI implementation.

---
#### documentation_inconsistency

**Description:** Contradictory information about variable editing capability in Curses UI

**Affected files:**
- `docs/help/ui/curses/feature-reference.md`
- `docs/help/ui/curses/variables.md`

**Details:**
feature-reference.md states: "Edit Variable Value (Not implemented) ‚ö†Ô∏è Variable editing is not available in Curses UI. You cannot directly edit values in the variables window."

However, variables.md states: "Variable Editing (Limited)" with "Current Status: ‚ö†Ô∏è Partial Implementation" and lists "What Works" and "What Doesn't Work Yet", implying some editing capability exists.

These two documents contradict each other on whether variable editing is completely unavailable or partially implemented.

---
#### documentation_inconsistency

**Description:** Contradictory status of Find/Replace feature

**Affected files:**
- `docs/help/ui/curses/feature-reference.md`
- `docs/help/ui/curses/find-replace.md`

**Details:**
feature-reference.md states: "Find/Replace (Not yet implemented) Find and Replace functionality is not yet available in Curses UI via keyboard shortcuts."

find-replace.md states: "The Curses UI currently **does not have** Find/Replace functionality for the editor. This feature is planned for future implementation."

Both agree it's not implemented, but feature-reference.md says "not yet available via keyboard shortcuts" (implying it might be available another way), while find-replace.md says it "does not have" the functionality at all. The wording creates ambiguity.

---
#### documentation_inconsistency

**Description:** Feature count mismatch: feature-reference.md claims 37 features total, but only documents 31 features (8+6+6+6+7+4=37 claimed, but actual count is 31)

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/tk/features.md`

**Details:**
feature-reference.md header states: 'This document covers all 37 features available in the Tkinter (Tk) UI.'

But the documented features are:
- File Operations: 8 features
- Execution & Control: 6 features
- Debugging: 6 features
- Variable Inspection: 6 features
- Editor Features: 7 features
- Help System: 4 features
Total: 37 features claimed, but some sections may be overcounting or undercounting

---
#### documentation_inconsistency

**Description:** Settings dialog implementation status contradiction

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/tk/settings.md`

**Details:**
feature-reference.md lists 'Auto-Save' as a feature:
'Auto-Save
Tk UI supports auto-save functionality. Programs are periodically saved to prevent data loss.
- Configurable interval
- Creates backup files'

But settings.md states:
'Implementation Status: The Tk (Tkinter) desktop GUI is planned to provide the most comprehensive settings dialog. **The features described in this document represent planned/intended implementation and are not yet available.**'

And later: 'Current Status: Most features described below are not yet implemented.'

This creates confusion about whether auto-save is actually implemented or just planned.

---
#### documentation_inconsistency

**Description:** Feature implementation status inconsistency between UIs

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/web/features.md`

**Details:**
feature-reference.md presents all Tk features as currently available with no implementation status warnings.

But web/features.md clearly marks features with:
'**(Currently Implemented)** - Feature is available now'
'**(Planned)** - Feature is not yet available'
'**(Partially Implemented)** - Some aspects work'

The Tk documentation should follow the same pattern if many features are actually planned rather than implemented, as suggested by settings.md.

---
#### documentation_inconsistency

**Description:** Variable Inspector implementation status contradiction

**Affected files:**
- `docs/help/ui/web/features.md`
- `docs/help/ui/web/debugging.md`

**Details:**
web/features.md states under 'Variable Inspector':
'**Currently Implemented:**
- Basic variable viewing via Debug menu'

But web/debugging.md states:
'**Implementation Status:** Basic variable viewing via Debug menu is currently available. The detailed variable inspector panels, watch expressions, and interactive editing features described below are **planned for future releases** and not yet implemented.'

Then debugging.md shows a detailed 'Variables Panel (Planned)' section with tree view, which contradicts the 'currently available' statement in features.md.

---
#### documentation_inconsistency

**Description:** Ctrl+X shortcut conflict within same document

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`

**Details:**
feature-reference.md assigns Ctrl+X to two different functions:

1. Under 'Stop/Interrupt (Ctrl+X)':
'Stop a running program immediately.
- Shortcut: Ctrl+X'

2. Under 'Cut/Copy/Paste (Ctrl+X/C/V)':
'Standard clipboard operations with native OS clipboard integration.
- Cut: Ctrl+X'

The same keyboard shortcut cannot perform both Stop Program and Cut operations.

---
#### documentation_inconsistency

**Description:** Broken cross-reference to Games Library

**Affected files:**
- `docs/help/ui/web/index.md`
- `docs/library/games/index.md`
- `docs/library/business/index.md`
- `docs/library/data_management/index.md`
- `docs/library/demos/index.md`
- `docs/library/education/index.md`
- `docs/library/electronics/index.md`
- `docs/library/ham_radio/index.md`

**Details:**
index.md states: "Browse and run classic BASIC games: [Games Library](../../../library/games/index.md) - 113 classic CP/M era games ready to run!"

However, the actual games/index.md only lists 113 games, but the instructions say to 'Download' the .bas files and then 'Open' them in MBASIC.

This contradicts the 'ready to run' claim in index.md, as users must download and manually load files rather than running them directly from the web interface.

All library index files (business, data_management, demos, education, electronics, ham_radio) have the same pattern of requiring download and manual loading.

---
#### documentation_inconsistency

**Description:** README.md lists QUICK_REFERENCE.md as 'Curses UI specific' but doesn't list a Tk UI quick reference, yet TK_UI_QUICK_START.md exists and is listed separately

**Affected files:**
- `docs/user/README.md`
- `docs/user/TK_UI_QUICK_START.md`

**Details:**
README.md structure:
'### Reference Documentation
- **[QUICK_REFERENCE.md](QUICK_REFERENCE.md)** - Quick command reference (Curses UI specific)'

But under '### UI-Specific Guides':
'- **[TK_UI_QUICK_START.md](TK_UI_QUICK_START.md)** - Tk/Tkinter UI quick start'

This creates confusion about whether TK_UI_QUICK_START.md is the Tk equivalent of QUICK_REFERENCE.md or something different. The categorization should be consistent - either both are 'UI-Specific Guides' or both are 'Reference Documentation'.

---
### üü° Medium Severity

#### code_vs_documentation

**Description:** Docstring claims INPUT 'will fail at runtime' but implementation shows it fails when input() is called, not during parsing/execution setup

**Affected files:**
- `src/immediate_executor.py`

**Details:**
Class docstring and help text state: 'INPUT statement will fail at runtime in immediate mode (use direct assignment instead)'

OutputCapturingIOHandler.input() method comment states: 'Note: INPUT statements are parsed and executed normally, but fail at runtime when the interpreter calls this input() method.'

The second description is more accurate - INPUT statements are fully parsed and execution begins, but fail when the interpreter attempts to call the IOHandler's input() method. The first description could be misinterpreted as INPUT being blocked earlier in the process.

---
#### code_vs_comment

**Description:** Comment claims EDIT command 'cannot be parsed as BASIC statements' but code attempts to parse it through execute_immediate() before checking for EDIT

**Affected files:**
- `src/interactive.py`

**Details:**
Line 177-180 comment:
# Special commands that require direct handling
# AUTO and EDIT cannot be parsed as BASIC statements (no corresponding AST nodes),
# so they're handled directly here before attempting to parse.

But line 183-184 shows EDIT is checked AFTER the comment claims it should be handled:
elif command == "EDIT":
    self.cmd_edit(args)

The code structure matches the comment (EDIT is handled before execute_immediate), so this is not a bug, but the comment's explanation is misleading since it implies EDIT would fail if parsed, when actually it's just more efficient to handle it directly.

---
#### internal_inconsistency

**Description:** Inconsistent error handling between CLEAR and RESET for file closing

**Affected files:**
- `src/interpreter.py`

**Details:**
execute_clear (line ~1275) uses try/except to silently ignore file close errors:
try:
    file_obj = self.runtime.files[file_num]
    if hasattr(file_obj, 'close'):
        file_obj.close()
except:
    pass

execute_reset (line ~1735) allows errors to propagate:
for file_num in list(self.runtime.files.keys()):
    self.runtime.files[file_num]['handle'].close()
    del self.runtime.files[file_num]

The comment at line ~1730 claims this is intentional: "Unlike CLEAR (which silently ignores file close errors), RESET allows errors during file close to propagate to the caller."

However, this design decision is not documented anywhere else and seems arbitrary. Why should CLEAR ignore errors but RESET propagate them?

---
#### documentation_inconsistency

**Description:** execute_step() docstring claims it's a placeholder and not functional, but also describes working step infrastructure in tick_pc() that UIs should use directly

**Affected files:**
- `src/interpreter.py`

**Details:**
Docstring states: 'IMPORTANT: This method is a placeholder and does NOT actually perform stepping. The tick_pc() method DOES have working step infrastructure (modes 'step_statement' and 'step_line'), which is used by UI debuggers.'

This creates confusion about whether stepping functionality exists and where it should be used. The relationship between this STEP command and the tick_pc() stepping modes is unclear.

---
#### Code vs Documentation inconsistency

**Description:** web_io.py implements get_screen_size() method which is not part of the IOHandler base interface

**Affected files:**
- `src/iohandler/base.py`
- `src/iohandler/web_io.py`

**Details:**
base.py IOHandler defines the interface with methods: output, input, input_line, input_char, clear_screen, error, debug, locate, get_cursor_position

web_io.py adds: get_screen_size() with comment "Note: This is a web_io-specific method, not part of the IOHandler base interface."

This breaks the abstraction - code using IOHandler interface cannot portably call get_screen_size().

---
#### code_vs_comment

**Description:** Comment about DIM tracking as both read and write is inconsistent with typical semantics

**Affected files:**
- `src/runtime.py`

**Details:**
Line 619-627 in dimension_array(): "# Note: DIM is tracked as both read and write to provide consistent debugger display.
# While DIM is technically allocation/initialization (write-only operation), setting
# last_read to the DIM location ensures that debuggers/inspectors can show 'Last accessed'
# information even for arrays that have never been explicitly read. Without this, an
# unaccessed array would show no last_read info, which could be confusing. The DIM location
# provides useful context about where the array was created."

This is a design decision that treats DIM as a read operation for debugger convenience, but it's semantically incorrect. DIM is purely a write/allocation operation. The comment acknowledges this inconsistency but justifies it for debugger display purposes. This could confuse users who expect 'last_read' to mean actual read access.

---
#### code_vs_comment

**Description:** Comment in load() method claims settings remain flat, but code shows settings can be both flat and nested

**Affected files:**
- `src/settings.py`

**Details:**
Comment in load() method states:
"Loaded settings remain flat; settings modified via set() become nested; both work."

However, the code shows:
1. Settings loaded from disk are flat (e.g., {'editor.auto_number': True})
2. Settings modified via set() become nested (e.g., {'editor': {'auto_number': True}})
3. _get_from_dict() handles both formats

The comment is accurate but could be clearer that this is intentional mixed-format support, not a bug.

---
#### Code vs Comment conflict

**Description:** STEP command docstring describes statement-level stepping but implementation uncertainty

**Affected files:**
- `src/ui/cli_debug.py`

**Details:**
cmd_step() docstring states: 'Executes a single statement (not a full line). If a line contains multiple statements separated by colons, each statement is executed separately.'

However, _execute_single_step() includes this note:
'Note: The actual statement-level granularity depends on the interpreter\'s implementation of tick()/execute_next(). These methods are expected to advance the program counter by one statement, handling colon-separated statements separately. If the interpreter executes full lines instead, this method will behave as line-level stepping rather than statement-level.'

This creates ambiguity about whether STEP actually does statement-level or line-level stepping.

---
#### Documentation inconsistency

**Description:** Inconsistent terminology for stepping commands between CLI and curses UI

**Affected files:**
- `src/ui/cli_debug.py`
- `src/ui/curses_keybindings.json`

**Details:**
CLI cli_debug.py cmd_step() docstring:
'STEP command - execute one statement and pause. Executes a single statement (not a full line).'

curses_keybindings.json has TWO separate step commands:
- 'step_line' (Ctrl+K): 'Step Line (execute all statements on current line)'
- 'step' (Ctrl+T): 'Step statement (execute one statement)'

The CLI only has one STEP command but doesn't clarify if it's statement-level or line-level stepping. The curses UI distinguishes between both.

---
#### code_vs_comment

**Description:** Comment claims bug fix but code behavior doesn't match the described bug

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
In _update_display method:
"# DON'T increment counter here - that happens only on Enter
# Bug fix: Incrementing here caused next_auto_line_num to advance prematurely,
# displaying the wrong line number before the user typed anything"

However, the code never increments next_auto_line_num in _update_display at all - there's no code being prevented. The comment describes a bug that was fixed by removing code, but there's no evidence of that code ever being there (no commented-out increment). This suggests the comment is describing a historical bug fix but doesn't match current code structure.

---
#### code_internal_inconsistency

**Description:** Inconsistent handling of line number width assumptions across methods

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Multiple methods make different assumptions about line number width:

1. _format_line uses variable width: 'line_num_str = f"{line_num}"'
2. _sort_and_position_line defaults to column 7: 'target_column=7'
3. keypress comment assumes 5-digit numbers: 'status=1 char + number=5 digits + space=1 char'
4. _parse_line_number handles truly variable width: 'while pos < len(line) and line[pos].isdigit()'

The code correctly implements variable-width line numbers, but default values and comments assume fixed 5-digit width, creating confusion about the actual behavior.

---
#### code_vs_comment

**Description:** Comment about status bar updates contradicts actual implementation in multiple methods

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Multiple methods have comments like:
# (No status bar update - execution will show output in output window)
# (No status bar update - output will show in output window)

But then the code DOES update status bar:
- _debug_step() line ~650: self.status_bar.set_text(f"Paused at {pc_display}...")
- _debug_step_line() line ~750: self.status_bar.set_text(f"Paused at {pc_display}...")

The comments claim no status bar update, but the code clearly updates it when paused.

---
#### code_internal_inconsistency

**Description:** Inconsistent handling of start_line parameter in _setup_program and _run_program

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
_run_program accepts start_line parameter and passes it to _setup_program:
"def _run_program(self, start_line=None):
    if not self._setup_program(start_line):"

_setup_program accepts start_line and has logic to handle it:
"def _setup_program(self, start_line=None):
    ...
    if start_line is not None:
        from src.runtime import PC
        if start_line not in self.program.line_asts:
            self.output_buffer.append(f"?Undefined line {start_line}")
            ...
        self.runtime.pc = PC.from_line(start_line)"

However, the comment at line ~1195 says:
"# If start_line is specified (e.g., RUN 100), set PC to that line
# This must happen AFTER interpreter.start() because start() calls setup()
# which resets PC to the first line in the program."

But there's no visible caller in this file that passes start_line to _run_program. The feature appears implemented but unused, or the caller is in a different file not shown.

---
#### internal_inconsistency

**Description:** Inconsistent handling of program/runtime synchronization - some methods sync immediately, others preserve runtime state, with no clear pattern

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
_parse_editor_content updates self.editor_lines and self.editor.lines
_sync_program_to_runtime syncs from self.program to runtime with complex PC preservation logic
_execute_immediate syncs program to runtime before execution
cmd_delete and cmd_renum sync after modifications

There's no clear documentation of when to sync, what the source of truth is, or how PC preservation should work across these operations.

---
#### Code vs Documentation inconsistency

**Description:** STOP_KEY is defined as 'ctrl x' but is not included in KEYBINDINGS_BY_CATEGORY. However, it IS documented in the 'Debugger' category comment as being shown. The comment says it's 'Shown in debugger context in the Debugger category' but it's actually present in the dictionary.

**Affected files:**
- `src/ui/keybindings.py`

**Details:**
Line 181: STOP_KEY = 'ctrl x'

Line 196 comment: '# - STOP_KEY (Ctrl+X) - Shown in debugger context in the Debugger category'

But checking KEYBINDINGS_BY_CATEGORY['Debugger (when program running)'] (lines 215-220), STOP_KEY IS included:
(key_to_display(STOP_KEY), 'Stop execution (eXit)'),

The comment incorrectly suggests it's excluded when it's actually included.

---
#### Code duplication with inconsistency risk

**Description:** Path normalization logic duplicated between _follow_link() and _open_link_in_new_window() methods

**Affected files:**
- `src/ui/tk_help_browser.py`

**Details:**
In _follow_link() (line 244):
# Note: Path normalization logic is duplicated in _open_link_in_new_window().
# Both methods use similar approach: resolve relative paths, normalize to help_root,
# handle path separators. If modification needed, update both methods consistently.

In _open_link_in_new_window() (line 625):
# Note: Path normalization logic is duplicated from _follow_link().
# Both methods resolve paths relative to help_root with similar logic.
# If modification needed, update both methods consistently.

The code explicitly warns about duplication but the implementations differ slightly in their approach, creating risk of divergence.

---
#### code_vs_comment

**Description:** Comment describes _ImmediateModeToken usage at line 1194 but the file is truncated and that line is not visible

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Class docstring lines 22-28:
'This class is instantiated when editing variables via the variable inspector
(see _on_variable_edit() around line 1194). Used to mark variable changes that
originate from the variable inspector or immediate mode, not from program
execution. The line=-1 signals to runtime.set_variable() that this is a
debugger/immediate mode edit.'

The file ends at line 1194 with _edit_simple_variable() method, but _on_variable_edit() is not visible in the provided code. The reference to 'around line 1194' cannot be verified.

---
#### code_vs_comment_conflict

**Description:** Comment about when blank line removal occurs contradicts potential future behavior

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _remove_blank_lines method around line 1340:
Comment says: "Currently called only from _on_enter_key (after each Enter key press), not after pasting or other modifications."

This comment explicitly states current limitation but doesn't explain why pasting is excluded. If blank line removal is desirable after Enter, it's unclear why it wouldn't be desirable after paste. This suggests either:
1. The comment is documenting a known limitation/bug
2. There's a design reason not documented
3. The behavior is intentionally limited but the rationale is missing

---
#### code_vs_comment

**Description:** Comment about error state and Continue button contradicts validation logic

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1400: 'self.paused_at_breakpoint = True  # Allow Continue to work after error'
This sets paused_at_breakpoint=True to enable Continue button after errors. However, the comment at line ~1410 says 'Edit the line and click Continue to retry', implying the user should fix the error first. But there's no validation that the error was actually fixed before Continue is clicked - the code just resumes execution. This could lead to the same error recurring.

---
#### code_vs_comment

**Description:** _on_cursor_move() comment about scheduling deletion 'after_idle' gives detailed reasons but one reason (undo stack corruption) is not clearly demonstrated by the simple deletion operation

**Affected files:**
- `src/ui/tk_widgets.py`

**Details:**
Comment says: 'Schedule deletion after current event processing to avoid interfering with ongoing key/mouse event handling (prevents cursor position issues, undo stack corruption, and widget state conflicts during event processing)'

The code does: self.text.after_idle(self._delete_line, self.current_line)

While cursor position issues and widget state conflicts are plausible, 'undo stack corruption' is a specific claim. The text.delete() operation in _delete_line() should normally be added to the undo stack correctly. The comment may be overstating the risks or referring to a specific bug that was encountered, but without evidence this seems speculative.

---
#### code_vs_comment

**Description:** Comment claims RUN clears output, but code explicitly does NOT clear output

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Line ~1845 comment: 'Note: This implementation does NOT clear output (see comment at line ~1845 below).' but the actual comment at that location says: 'Don't clear output - continuous scrolling like ASR33 teletype
# Design choice: Unlike some modern BASIC interpreters that clear output on RUN,
# we preserve historical ASR33 behavior (continuous scrolling, no auto-clear).
# Note: Step commands (Ctrl+T/Ctrl+K) DO clear output for clarity when debugging'

However, the code for step commands (_menu_step_line and _menu_step_stmt) also has comment 'Note: Output is NOT cleared - continuous scrolling like ASR33 teletype' which contradicts the claim that step commands DO clear output.

---
#### documentation_inconsistency

**Description:** Version string 'MBASIC 5.21' in UI title doesn't match VERSION constant usage pattern

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
At line ~453:
ui.run(
    title='MBASIC 5.21 - Web IDE',
    ...
)

But earlier at line ~437:
sys.stderr.write(f"MBASIC Web UI Starting - Version {VERSION}\n")

The hardcoded '5.21' in the title should use the VERSION constant for consistency: title=f'MBASIC {VERSION} - Web IDE'

---
#### code_internal_inconsistency

**Description:** Inconsistent error handling between periodic save and disconnect save - both catch exceptions but one is described as 'won't crash' while other is just 'save on disconnect'

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
save_state_periodic() at ~459:
try:
    app.storage.client['session_state'] = backend.serialize_state()
except Exception as e:
    sys.stderr.write(f"Warning: Failed to save session state: {e}\n")

save_on_disconnect() at ~473:
try:
    app.storage.client['session_state'] = backend.serialize_state()
except Exception as e:
    sys.stderr.write(f"Warning: Failed to save final session state: {e}\n")

Both have identical error handling but different commentary about their reliability. The 'won't crash the UI' comment for periodic saves suggests higher confidence than warranted.

---
#### code_vs_documentation

**Description:** Redis settings isolation feature not documented for users

**Affected files:**
- `test_redis_settings.py`
- `docs/help/common/debugging.md`

**Details:**
test_redis_settings.py demonstrates a sophisticated per-session settings isolation feature:
'Test that different sessions have independent settings'
'Settings persist across SettingsManager instances with same session_id'

This is a significant feature for the Web UI (multiple users, load balancing), but it's not documented anywhere in the user-facing help documentation. Users and administrators would not know:
- That settings are per-session in Web UI
- How to configure Redis for this feature
- What NICEGUI_REDIS_URL environment variable does
- That file backend is used as fallback

---
#### documentation_inconsistency

**Description:** Double-precision range values differ between documents

**Affected files:**
- `docs/help/common/language/data-types.md`
- `docs/help/common/language/functions/cdbl.md`

**Details:**
data-types.md states double-precision range as: "¬±2.938736√ó10^-308 to ¬±1.797693√ó10^308" while cdbl.md states: "range from 2.938735877055719 x 10^-39 to 1.701411834604692 x 10^38". The cdbl.md range appears to be incorrect as it shows 10^-39 to 10^38 which is closer to single-precision range.

---
#### documentation_inconsistency

**Description:** Single-precision range values differ between documents

**Affected files:**
- `docs/help/common/language/data-types.md`
- `docs/help/common/language/functions/csng.md`

**Details:**
data-types.md states single-precision range as: "¬±2.938736√ó10^-39 to ¬±1.701412√ó10^38" while csng.md states: "range from 2.938736 x 10^-39 to 1.701412 x 10^38". The csng.md version omits the ¬± sign which could be misleading about negative number support.

---
#### documentation_inconsistency

**Description:** Loop example shows GOTO for early exit but doesn't mention EXIT FOR or other structured alternatives

**Affected files:**
- `docs/help/common/examples/loops.md`

**Details:**
The 'Breaking Out of Loops' section in loops.md states: "Use GOTO to exit early" and shows an example with GOTO 120. However, it doesn't mention whether BASIC-80 supports EXIT FOR or other structured loop exit mechanisms, which would be more modern and clearer than GOTO.

---
#### documentation_inconsistency

**Description:** Inconsistent formatting and detail level in 'Implementation Note' sections for unimplemented features

**Affected files:**
- `docs/help/common/language/functions/lpos.md`
- `docs/help/common/language/functions/inp.md`
- `docs/help/common/language/functions/peek.md`

**Details:**
lpos.md uses:
'‚ö†Ô∏è **Not Implemented**: This feature requires line printer hardware...'
'**Behavior**: Function always returns 0...'
'**Why**: Line printers are obsolete hardware...'
'**Alternative**: Use [POS](pos.md)...'
'**Historical Reference**: The documentation below...'

inp.md uses:
'‚ö†Ô∏è **Not Implemented**: This feature requires direct hardware I/O port access...'
'**Behavior**: Always returns 0'
'**Why**: Cannot access hardware I/O ports...'
'**Historical Reference**: The documentation below...'
(Missing **Alternative** section)

peek.md uses:
'‚ÑπÔ∏è **Emulated with Random Values**: PEEK does NOT read actual memory...'
'**Behavior**: Each call to PEEK returns a new random integer...'
'**Why**: Most legacy BASIC programs used PEEK to seed random number generators...'
'**Important Limitations**: (bullet list)'
'**Recommendation**: Use [RANDOMIZE]...'
(Different structure, uses ‚ÑπÔ∏è instead of ‚ö†Ô∏è, has 'Recommendation' instead of 'Alternative')

These should follow a consistent template for unimplemented/emulated features.

---
#### documentation_inconsistency

**Description:** Conflicting information about whether STOP closes files

**Affected files:**
- `docs/help/common/language/statements/close.md`
- `docs/help/common/language/statements/chain.md`

**Details:**
In close.md:
'The END statement and the NEW command always CLOSE all disk files automatically. (STOP does not close disk files.)'

But in chain.md, there's no mention of what happens to open files when STOP is executed before a CHAIN. This could lead to confusion about file handling across program control statements.

---
#### documentation_inconsistency

**Description:** Filename does not match content - inputi.md documents LINE INPUT# not INPUT#

**Affected files:**
- `docs/help/common/language/statements/inputi.md`

**Details:**
The file is named 'inputi.md' (suggesting INPUT#) but documents 'LINE INPUT#' statement. The syntax is 'LINE INPUT#<file number>,<string variable>' not 'INPUT#'. This creates confusion about which statement is documented where.

---
#### documentation_inconsistency

**Description:** Incorrect cross-reference for LINE INPUT# in See Also section

**Affected files:**
- `docs/help/common/language/statements/line-input.md`

**Details:**
line-input.md See Also section has:
- [LINE INPUT#](input_hash.md) - Read an entire line from a file

But input_hash.md would be for INPUT# (read data with delimiters), not LINE INPUT# (read entire line). The link should point to inputi.md based on the file structure.

---
#### documentation_inconsistency

**Description:** RSET and RESET have very similar names (one letter difference) but completely different purposes, no cross-reference warning

**Affected files:**
- `docs/help/common/language/statements/rset.md`
- `docs/help/common/language/statements/reset.md`

**Details:**
RSET: 'Right-justifies a string in a field for random file output'
RESET: 'Closes all open files'

Both are file-related but serve different purposes. Users typing 'RESET' when they meant 'RSET' (or vice versa) could cause data loss or unexpected behavior. No warning in either doc.

---
#### documentation_inconsistency

**Description:** Inconsistent implementation note formatting and detail level

**Affected files:**
- `docs/help/common/language/statements/wait.md`
- `docs/help/common/language/statements/width.md`

**Details:**
WAIT doc has brief note: '‚ö†Ô∏è Not Implemented: This feature requires direct hardware I/O port access and is not implemented in this Python-based interpreter.'

WIDTH doc has detailed note: '‚ö†Ô∏è Emulated as No-Op: This statement is parsed for compatibility but performs no operation.' with extensive explanation of what works and what doesn't.

Both are unimplemented features but documented with different levels of detail and different terminology (Not Implemented vs Emulated as No-Op).

---
#### documentation_inconsistency

**Description:** Inconsistent information about Web UI file storage persistence mechanism

**Affected files:**
- `docs/help/mbasic/compatibility.md`
- `docs/help/mbasic/extensions.md`

**Details:**
compatibility.md states 'Files stored in server-side memory (sandboxed filesystem per session)' and 'Files persist during browser session but are lost on page refresh' and 'Note: Settings (not files) can persist via Redis if configured'. However, it also says 'The uppercasing is a programmatic transformation for CP/M compatibility, not evidence of persistent storage' which seems to contradict the Redis mention. extensions.md says 'Files persist during browser session only (lost on page refresh)' without mentioning Redis at all. The relationship between session memory, Redis, and what actually persists is unclear.

---
#### documentation_inconsistency

**Description:** BREAK, STEP, and STACK commands availability inconsistently documented

**Affected files:**
- `docs/help/mbasic/extensions.md`
- `docs/help/common/ui/curses/editing.md`
- `docs/help/common/ui/tk/index.md`

**Details:**
extensions.md states these commands have different availability: 'BREAK: CLI (command form), Curses (Ctrl+B), Tk (UI controls)' and 'STEP: CLI (command form), Curses (Ctrl+T/Ctrl+K), Tk (UI controls)' and 'STACK: CLI (command form), Curses (menu access), Tk (stack window)'. However, the curses/editing.md and tk/index.md documents do not mention these debugging commands at all, nor do they document the keyboard shortcuts (Ctrl+B, Ctrl+T, Ctrl+K) or UI controls mentioned. Users reading the UI-specific docs would not know these features exist.

---
#### documentation_inconsistency

**Description:** PEEK/POKE behavior documented differently in two places

**Affected files:**
- `docs/help/mbasic/architecture.md`
- `docs/help/mbasic/compatibility.md`

**Details:**
architecture.md states under 'Hardware Compatibility Notes': 'PEEK/POKE - Emulated for compatibility: POKE: Parsed and executes successfully, but performs no operation (no-op), PEEK: Returns random integer 0-255 (for RNG seeding compatibility), PEEK does NOT return values written by POKE - no memory state is maintained'. compatibility.md has an identical section under 'Intentional Differences > 1. Hardware-Specific Features'. This is redundant documentation that could become inconsistent if one is updated without the other.

---
#### documentation_inconsistency

**Description:** Find/Replace feature availability unclear

**Affected files:**
- `docs/help/common/ui/curses/editing.md`
- `docs/help/mbasic/extensions.md`

**Details:**
curses/editing.md does not mention Find or Find/Replace functionality at all in its 'Navigation' or 'Keyboard Shortcuts' sections. extensions.md states 'Find and Replace (Tk only)' implying it's not available in Curses. However, tk/index.md lists 'Find (Ctrl+F)' in the Edit Menu but doesn't mention Replace. The actual availability and capabilities of Find/Replace across UIs is inconsistently documented.

---
#### documentation_inconsistency

**Description:** WIDTH statement behavior documented as no-op but syntax support unclear

**Affected files:**
- `docs/help/mbasic/compatibility.md`

**Details:**
compatibility.md states 'WIDTH 80 - Accepted (no-op)' and 'Note: WIDTH is parsed for compatibility but performs no operation. Terminal width is controlled by the UI or OS. The "WIDTH LPRINT" syntax is not supported.' This raises questions: Is 'WIDTH 80' the only accepted syntax? What about 'WIDTH 40' or other values? What error occurs if WIDTH LPRINT is used? The documentation should clarify what WIDTH syntax is accepted vs rejected.

---
#### documentation_inconsistency

**Description:** Features.md lists 'Web UI' as a supported interface, but cli/index.md only mentions CLI, Curses, and Tk UIs

**Affected files:**
- `docs/help/mbasic/features.md`
- `docs/help/ui/cli/index.md`

**Details:**
features.md states: 'MBASIC supports four interfaces: Curses UI (Default), CLI Mode, Tkinter GUI, Web UI'

cli/index.md Quick Start section shows: 'mbasic' command but doesn't mention --ui web option

features.md has entire 'Web UI' section describing browser-based IDE with session storage and 50 file limit, but this is not referenced in the CLI help index

---
#### documentation_inconsistency

**Description:** Debugging features availability differs between general features and CLI-specific documentation

**Affected files:**
- `docs/help/mbasic/features.md`
- `docs/help/ui/cli/debugging.md`

**Details:**
features.md lists under 'Debugging':
'TRON/TROFF - Line tracing
Breakpoints - Set/clear breakpoints (UI-dependent)
Step execution - Execute one line at a time (UI-dependent)
Variable watch - Monitor variables (UI-dependent)
Stack viewer - View call stack (UI-dependent)'

cli/debugging.md documents:
'BREAK - Breakpoint Management
STEP - Single-Step Execution
STACK - Call Stack Inspection'

But features.md marks these as '(UI-dependent)' suggesting they may not be available in all UIs, while cli/debugging.md clearly shows they ARE available in CLI. The '(UI-dependent)' note is misleading.

---
#### documentation_inconsistency

**Description:** Number of optimizations differs between documents

**Affected files:**
- `docs/help/mbasic/features.md`
- `docs/help/mbasic/index.md`

**Details:**
features.md 'Compiler Features' section states:
'The interpreter includes an advanced semantic analyzer with 18 optimizations:'
Then lists 18 numbered optimizations (1-18).

index.md 'About This Implementation' section states:
'Advanced semantic analyzer with 18 optimizations'

Both say 18, so this is consistent. However, it would be good to verify the actual code implements exactly 18.

---
#### documentation_inconsistency

**Description:** CLS and LOCATE commands status unclear

**Affected files:**
- `docs/help/mbasic/features.md`
- `docs/help/mbasic/not-implemented.md`

**Details:**
not-implemented.md lists under 'Graphics (Not in MBASIC 5.21)':
'CLS - Clear screen (GW-BASIC version)
LOCATE - Cursor positioning (GW-BASIC version)'

With note: 'Why not implemented: MBASIC 5.21 predates graphics BASIC. These features were added in GW-BASIC and later versions.'

However, features.md does not mention CLS or LOCATE at all. If they're not implemented, this is correct, but the parenthetical '(GW-BASIC version)' suggests there might be MBASIC versions of these commands that ARE supported, which is not documented.

---
#### documentation_inconsistency

**Description:** Find/Replace availability inconsistent

**Affected files:**
- `docs/help/mbasic/features.md`
- `docs/help/ui/cli/find-replace.md`

**Details:**
features.md 'Tkinter GUI' section lists:
'Find and Replace - Search and replace text (Ctrl+F/Ctrl+H)'

But cli/find-replace.md states:
'The CLI backend does not have built-in Find/Replace commands. The CLI follows the classic MBASIC-80 command set, which did not include these features.'

This is consistent (Tk has it, CLI doesn't), but features.md should clarify that Find/Replace is Tk-only, not available in CLI or Curses.

---
#### documentation_inconsistency

**Description:** Compiler vs Interpreter mode mentioned but not explained

**Affected files:**
- `docs/help/mbasic/features.md`

**Details:**
features.md 'Compiler Features' section states:
'See [Architecture](architecture.md) for details on interpreter vs. compiler modes.'

This implies there are two distinct modes (interpreter and compiler), but:
1. The features.md title is 'MBASIC Features' suggesting it's an interpreter
2. The section is called 'Compiler Features' but describes 'semantic analyzer' optimizations
3. It's unclear if these are compile-time or runtime optimizations
4. The distinction between 'interpreter mode' and 'compiler mode' is never clearly defined

This needs clarification about what 'compiler mode' means in the context of a Python-based BASIC interpreter.

---
#### documentation_inconsistency

**Description:** Inconsistent information about Execution Stack access method

**Affected files:**
- `docs/help/ui/curses/feature-reference.md`
- `docs/help/ui/curses/quick-reference.md`

**Details:**
feature-reference.md states: "Execution Stack: View the call stack showing: **Access methods:** - Via menu: Ctrl+U ‚Üí Debug ‚Üí Execution Stack - Via command: Type `STACK` in immediate mode (same as CLI)"

quick-reference.md lists under Global Commands: "Menu only | Toggle execution stack window"

The feature-reference suggests both menu AND command access, while quick-reference only mentions menu access. Also, feature-reference says "View" while quick-reference says "Toggle", implying different behaviors.

---
#### documentation_inconsistency

**Description:** Inconsistent keyboard shortcut documentation for Cut/Copy/Paste

**Affected files:**
- `docs/help/ui/curses/feature-reference.md`
- `docs/help/ui/curses/quick-reference.md`
- `docs/help/ui/curses/editing.md`

**Details:**
feature-reference.md states: "Cut/Copy/Paste (Not implemented) Standard clipboard operations are not available in the Curses UI due to keyboard shortcut conflicts: - **Ctrl+X** - Used for Stop/Interrupt (cannot be used for Cut) - **Ctrl+C** - Terminal signal to exit program (cannot be used for Copy) - **Ctrl+V** - Used for Save File (cannot be used for Paste; Ctrl+S is reserved by terminal for flow control)"

However, quick-reference.md does NOT list these shortcuts in the Editing section at all, and editing.md makes no mention of clipboard operations or their unavailability.

This creates confusion about whether these features exist or not, and the rationale is only explained in one document.

---
#### documentation_inconsistency

**Description:** Contradictory information about Variables Window availability

**Affected files:**
- `docs/help/ui/curses/variables.md`
- `docs/help/ui/index.md`

**Details:**
index.md comparison table shows: "Variables Window | Curses: ‚úì | CLI: ‚úó | Tkinter: ‚úì | Web: ‚úì"

However, cli/variables.md explicitly states: "## Variables Window (GUI UIs Only) The CLI does not have a Variables Window feature. For visual variable inspection, use: - **Curses UI** - Full-screen terminal with Variables Window (Ctrl+W)"

This is consistent. However, variables.md for Curses states the window has limitations and partial implementation, which is not reflected in the comparison table that simply shows a checkmark.

---
#### documentation_inconsistency

**Description:** Documented features that may not be implemented

**Affected files:**
- `docs/help/ui/curses/variables.md`

**Details:**
variables.md documents many advanced features with specific keyboard shortcuts:
- "Ctrl+Arrow: Move window"
- "Alt+Arrow: Resize window"
- "Ctrl+M: Maximize/restore"
- "Ctrl+X: Close window"
- "v: Toggle value truncation"
- "t: Toggle type display"
- "d: Show decimal/hex toggle"
- "w: Word wrap long strings"
- "p: Pin window"
- "e: Export to file"
- "Double-click variable name (if mouse enabled)"

These features are documented as if they exist, but there's no indication in other documentation that these are implemented. The feature-reference.md doesn't mention most of these capabilities. This suggests either over-documentation of planned features or missing implementation status notes.

---
#### documentation_inconsistency

**Description:** Broken cross-reference links

**Affected files:**
- `docs/help/ui/common/errors.md`
- `docs/help/ui/cli/variables.md`

**Details:**
errors.md contains: "See Also: - [ON ERROR GOTO](../../common/language/statements/on-error-goto.md) - Set up error handling - [ERR and ERL](../../common/language/statements/err-erl-variables.md) - Error information - [RESUME](../../common/language/statements/resume.md) - Continue after error - [Error Codes](../../common/language/appendices/error-codes.md) - Complete error code reference"

These links reference files that are not provided in the documentation set. Without verifying these files exist, these could be broken links. The documentation should be checked for link validity.

---
#### documentation_inconsistency

**Description:** Find/Replace keyboard shortcuts inconsistency

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/tk/features.md`

**Details:**
feature-reference.md states:
'Find/Replace (Ctrl+F / Ctrl+H)'
'Find: Ctrl+F'
'Replace: Ctrl+H'

But features.md states:
'Find text (Ctrl+F): Opens Find dialog'
'Replace text (Ctrl+H): Opens combined Find/Replace dialog'
'Note: Ctrl+F opens the Find dialog. Ctrl+H opens the Find/Replace dialog which includes both Find and Replace functionality.'

This suggests Ctrl+H opens a combined dialog, not a separate Replace dialog, which contradicts the feature-reference.md description of separate Find and Replace functions.

---
#### documentation_inconsistency

**Description:** Smart Insert (Ctrl+I) feature status unclear across documents

**Affected files:**
- `docs/help/ui/tk/features.md`
- `docs/help/ui/tk/workflows.md`
- `docs/help/ui/tk/tips.md`

**Details:**
features.md describes Smart Insert as a current feature:
'Smart Insert ({{kbd:smart_insert}})
**The fastest way to add code between existing lines!**'

workflows.md also describes it as current:
'Press **Ctrl+I** (Smart Insert) to insert blank line'

tips.md describes it as current:
'Use **Ctrl+I** (Smart Insert) to insert blank lines under each section'

But all three documents have notes stating:
'**Note:** Some features described below (Smart Insert, Variables Window, Execution Stack) are documented here based on the Tk UI design specifications. Check [Settings](settings.md) for current implementation status'

This creates ambiguity about whether Smart Insert is actually implemented or just planned.

---
#### documentation_inconsistency

**Description:** Renumber keyboard shortcut inconsistency

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/tk/workflows.md`

**Details:**
feature-reference.md states:
'Renumber (Ctrl+E)
Renumber program lines with specified start and increment.
- Menu: Edit ‚Üí Renumber
- Shortcut: Ctrl+E'

workflows.md states:
'Press **Ctrl+E** (Renumber)'

But workflows.md also has a note:
'**Note:** Some features described below (Smart Insert, Variables Window, Execution Stack, Renumber dialog) are documented here based on the Tk UI design specifications. Check [Settings](settings.md) for current implementation status'

This suggests Renumber might not be implemented, contradicting feature-reference.md which lists it as an available feature.

---
#### documentation_inconsistency

**Description:** Variables Window keyboard shortcut inconsistency

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/tk/features.md`

**Details:**
feature-reference.md states:
'Variables Window (Ctrl+W)'
'Shortcut: Ctrl+W'

features.md states:
'Variables Window ({{kbd:toggle_variables}})'

The use of {{kbd:toggle_variables}} template suggests the actual shortcut might be different from Ctrl+W, or that it's configurable. This inconsistency needs clarification.

---
#### documentation_inconsistency

**Description:** Execution Stack keyboard shortcut inconsistency

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/tk/features.md`

**Details:**
feature-reference.md states:
'Execution Stack (Ctrl+K)'
'Shortcut: Ctrl+K'

features.md states:
'Execution Stack ({{kbd:toggle_stack}})'

The use of {{kbd:toggle_stack}} template suggests the actual shortcut might be different from Ctrl+K, or that it's configurable.

---
#### documentation_inconsistency

**Description:** Debug keyboard shortcuts inconsistency between documents

**Affected files:**
- `docs/help/ui/web/features.md`
- `docs/help/ui/web/debugging.md`

**Details:**
web/features.md states:
'Step statement (Ctrl+T)'
'Step line (Ctrl+K)'

web/debugging.md states:
'Step Statement (Ctrl+T) - Execute one statement'
'Step Line (Ctrl+K) - Execute one line'

But debugging.md also states:
'**Note:** Function key shortcuts (F5, F10, F11, etc.) are not implemented in the Web UI.'

And later in debugging.md:
'**Planned for Future Releases:**
- `F5` - Start/Continue debugging
- `F9` - Toggle breakpoint
- `F10` - Step over
- `F11` - Step into'

This creates confusion because F10 is listed as planned, but Ctrl+K (Step Line) is listed as currently implemented. The relationship between these shortcuts needs clarification.

---
#### documentation_inconsistency

**Description:** File storage implementation status internal contradiction

**Affected files:**
- `docs/help/ui/web/features.md`

**Details:**
web/features.md states under 'Local Storage':
'**Currently Implemented:**
- Programs stored in Python server memory (session-only, lost on page refresh)'

But later under 'Data Protection (Currently Implemented)':
'**Currently Implemented:**
- Local storage only (browser localStorage)'

These two statements contradict each other - programs cannot be both in 'Python server memory' and in 'browser localStorage' at the same time.

---
#### documentation_inconsistency

**Description:** Stop execution keyboard shortcut inconsistency

**Affected files:**
- `docs/help/ui/web/features.md`
- `docs/help/ui/web/debugging.md`

**Details:**
web/features.md states:
'Stop (Ctrl+Q)'

web/debugging.md states:
'Use **Run ‚Üí Stop** or `Ctrl+Q` to stop'

But later in debugging.md under 'Keyboard Shortcuts':
'`Ctrl+Q` - Stop execution'

However, Ctrl+Q is conventionally used to quit applications in many systems. This might cause confusion or conflicts.

---
#### documentation_inconsistency

**Description:** Statement and function count inconsistency

**Affected files:**
- `docs/help/ui/tk/index.md`
- `docs/help/ui/tk/feature-reference.md`

**Details:**
tk/index.md states:
'**Statements** - All 63 BASIC-80 statements'
'**Functions** - All 40 BASIC-80 functions'

But feature-reference.md does not mention these counts anywhere, and there's no way to verify if the Tk UI actually supports all 63 statements and 40 functions as claimed.

---
#### documentation_inconsistency

**Description:** Recent files storage location inconsistency

**Affected files:**
- `docs/help/ui/web/features.md`

**Details:**
web/features.md states under 'Local Storage':
'**Currently Implemented:**
- Programs stored in Python server memory (session-only, lost on page refresh)
- Recent files list stored in browser localStorage'

This is inconsistent - if programs are lost on page refresh (server memory), how can a recent files list persist in localStorage? The recent files list would reference programs that no longer exist.

---
#### documentation_inconsistency

**Description:** Contradictory information about auto-save to localStorage

**Affected files:**
- `docs/help/ui/web/getting-started.md`
- `docs/help/ui/web/settings.md`

**Details:**
getting-started.md states: "Auto-save to browser localStorage is planned for a future release" (appears twice in the document)

But settings.md states: "By default, settings are stored in your browser's localStorage" and describes localStorage as the default storage mechanism that is already implemented.

This creates confusion about whether localStorage is currently used or planned for the future.

---
#### documentation_inconsistency

**Description:** Contradictory information about 'Open Example' feature

**Affected files:**
- `docs/help/ui/web/getting-started.md`
- `docs/help/ui/web/web-interface.md`

**Details:**
getting-started.md does not mention any limitation on opening example programs.

web-interface.md explicitly states: "Note: An 'Open Example' feature to choose from sample BASIC programs is planned for a future release."

This suggests the feature doesn't exist yet, but getting-started.md doesn't clarify this.

---
#### documentation_inconsistency

**Description:** Conflicting information about Calendar program location

**Affected files:**
- `docs/library/index.md`
- `docs/library/utilities/index.md`

**Details:**
docs/library/index.md lists 'Calendar' under Utilities featured programs: 'Featured programs: Calendar, Unit Converter, Sort, Search, Day of Week Calculator'

However, docs/library/utilities/index.md states: 'Note: A different calendar program is also available in the [Games Library](../games/index.md#calendar)'

This suggests there are TWO calendar programs (one in Utilities, one in Games), but the main index only mentions the Utilities category having Calendar as a featured program. The Games category featured programs list does not mention Calendar: 'Featured programs: Blackjack, Spacewar, Star Trek, Hangman, Roulette'

---
#### documentation_inconsistency

**Description:** Contradictory information about CLI debugging capabilities

**Affected files:**
- `docs/user/CHOOSING_YOUR_UI.md`

**Details:**
The document contains contradictory statements about CLI debugging:

In the 'CLI (Command Line Interface)' section under 'Unique advantages':
'Command-line debugging (BREAK, STEP, WATCH commands)'

But in the 'Limitations' section:
'No visual debugging (text commands only)'

Then there's a Note that attempts to clarify:
'Note: CLI has full debugging capabilities through commands (BREAK, STEP, WATCH, STACK), but lacks the visual debugging interface (Variables Window, clickable breakpoints, etc.) found in Curses, Tk, and Web UIs.'

The issue is that 'Unique advantages' lists 'Command-line debugging' as if it's unique to CLI, but the note clarifies that CLI has the SAME debugging commands as other UIs, just without the visual interface. This makes 'Command-line debugging' not actually a unique advantage of CLI.

---
#### documentation_inconsistency

**Description:** README.md describes keyboard-shortcuts.md as 'Curses UI specific' but the file title says 'MBASIC Curses UI Keyboard Shortcuts', creating ambiguity about whether it covers all UIs or just Curses

**Affected files:**
- `docs/user/README.md`
- `docs/user/keyboard-shortcuts.md`

**Details:**
README.md line: '- **[keyboard-shortcuts.md](keyboard-shortcuts.md)** - Keyboard shortcuts reference (Curses UI specific)'

keyboard-shortcuts.md title: '# MBASIC Curses UI Keyboard Shortcuts'

This is consistent, but TK_UI_QUICK_START.md has its own shortcuts table that differs from keyboard-shortcuts.md, suggesting there should be separate docs or a unified reference.

---
#### documentation_inconsistency

**Description:** SETTINGS_AND_CONFIGURATION.md shows boolean values in SET commands without quotes, but JSON examples use true/false

**Affected files:**
- `docs/user/SETTINGS_AND_CONFIGURATION.md`
- `docs/user/TK_UI_QUICK_START.md`

**Details:**
SETTINGS_AND_CONFIGURATION.md states:
'SET "editor.auto_number" true'
'Booleans: true or false (lowercase, no quotes in commands; use true/false in JSON files)'

But earlier in the same doc:
'**Using SET command (in BASIC):**
```basic
SET "variables.case_conflict" "error"
SET "editor.auto_number" true
```'

This is internally consistent, but TK_UI_QUICK_START.md doesn't mention the SET command syntax at all when discussing settings, only showing:
'SET "variables.case_conflict" "error"' without explaining boolean syntax.

---
#### documentation_inconsistency

**Description:** Inconsistent use of ‚ö†Ô∏è symbol - sometimes means 'partially implemented' and sometimes means 'limited/basic'

**Affected files:**
- `docs/user/UI_FEATURE_COMPARISON.md`

**Details:**
Legend states:
'| ‚ö†Ô∏è | Partially implemented (see Notes column for details) |'

But used for:
1. 'Syntax highlighting' in Curses: 'Curses: basic' (not partial, just basic)
2. 'Mouse support' in Curses: 'Curses: limited, terminal-dependent' (not partial, just limited)
3. 'Keyboard shortcuts' in CLI: 'CLI: limited' (not partial, just limited)
4. 'Recent files' in Web: 'Tk: menu, Web: localStorage' (fully implemented, just different)

These should use different symbols or the legend should be updated to include 'limited/basic' as a meaning.

---
#### documentation_inconsistency

**Description:** Document claims to describe 'Sequential File Handling' but only covers line endings and ^Z EOF marker, not general sequential file operations

**Affected files:**
- `docs/user/sequential-files.md`

**Details:**
Title: '# Sequential File Handling'

But content only covers:
- Line Ending Differences
- CP/M File Format and ^Z EOF Marker

Missing:
- How to open sequential files (OPEN "I" vs OPEN "O")
- INPUT# vs LINE INPUT# usage
- PRINT# for output
- CLOSE statement
- General sequential file workflow

The 'See Also' section references these topics but they're not covered in this doc. Title should be more specific like 'Sequential File Line Endings and EOF Markers' or content should be expanded.

---
#### documentation_inconsistency

**Description:** UI_FEATURE_COMPARISON.md shows Find/Replace as ‚ùå for Web UI but marks it as ‚ö†Ô∏è with 'Tk: implemented, Web: planned' in the Notes

**Affected files:**
- `docs/user/UI_FEATURE_COMPARISON.md`
- `docs/user/TK_UI_QUICK_START.md`

**Details:**
UI_FEATURE_COMPARISON.md table:
'| **Find/Replace** | ‚ùå | ‚ùå | ‚úÖ | ‚ö†Ô∏è | Tk: implemented, Web: planned |'

The Web column shows ‚ö†Ô∏è but the Notes say 'Web: planned', which should be üìã according to the legend:
'| üìã | Planned for future implementation (not yet available) |'

Inconsistent symbol usage.

---
#### documentation_inconsistency

**Description:** Feature matrix shows 'Edit variables' as ‚ö†Ô∏è for Curses with 'CLI: immediate mode only' in Notes, but CLI column shows ‚ùå

**Affected files:**
- `docs/user/UI_FEATURE_COMPARISON.md`

**Details:**
Table row:
'| **Edit variables** | ‚ùå | ‚ö†Ô∏è | ‚úÖ | ‚úÖ | CLI: immediate mode only |'

The Notes say 'CLI: immediate mode only' but the CLI column shows ‚ùå (not available). If CLI can edit variables in immediate mode, it should be ‚ö†Ô∏è with a note, not ‚ùå. This is contradictory.

---
### üü¢ Low Severity

#### documentation_inconsistency

**Description:** ChainStatementNode delete_range type annotation inconsistency

**Affected files:**
- `src/ast_nodes.py`

**Details:**
ChainStatementNode definition line 545:
'delete_range: Optional[Tuple[int, int]] = None  # (start_line_number, end_line_number) for DELETE option - tuple of int line numbers'

The comment redundantly specifies 'tuple of int line numbers' when the type annotation 'Tuple[int, int]' already makes this clear. More importantly, the comment format '(start_line_number, end_line_number)' uses underscores while other similar comments use spaces (e.g., 'line_number' vs 'line number'), creating minor inconsistency in documentation style.

---
#### documentation_inconsistency

**Description:** CaseKeeperTable supports multiple policies but case_string_handler.py only uses force_lower for keywords and always returns original for identifiers

**Affected files:**
- `src/case_keeper.py`
- `src/case_string_handler.py`

**Details:**
case_keeper.py implements 8 different policies (first_wins, force_lower, force_upper, force_capitalize, prefer_upper, prefer_lower, prefer_mixed, error) but case_string_handler.py hardcodes policy='force_lower' for keywords and ignores policy entirely for identifiers. This suggests either incomplete implementation or unused features.

---
#### documentation_inconsistency

**Description:** Module docstring mentions UI display but doesn't specify which UI or how formatted messages are consumed

**Affected files:**
- `src/debug_logger.py`

**Details:**
Line 3-5: "returned as formatted strings for UI display when debugging with IDEs or other development tools" - unclear what UI is being referenced or how the returned strings are actually used. No examples of UI integration provided.

---
#### documentation_inconsistency

**Description:** Help text mentions 'Ctrl+H (UI help)' but this is UI-specific and may not be available in all contexts

**Affected files:**
- `src/immediate_executor.py`

**Details:**
In _show_help() method, the help text ends with:
'Press Ctrl+H (UI help) for keyboard shortcuts and UI features.'

This assumes a specific UI implementation with Ctrl+H bound to help, but ImmediateExecutor is designed to be UI-agnostic. The help text should either be generic or note that this is specific to certain UIs.

---
#### code_vs_comment

**Description:** Docstring for cmd_edit says 'Count prefixes ([n]D, [n]C) and search commands ([n]S, [n]K) are not yet implemented' but then describes digit behavior as 'INTENTIONAL BEHAVIOR' that 'preserves MBASIC compatibility'

**Affected files:**
- `src/interactive.py`

**Details:**
Lines 682-688:
Note: Count prefixes ([n]D, [n]C) and search commands ([n]S, [n]K) are not yet implemented.
INTENTIONAL BEHAVIOR: When digits are entered, they are silently ignored (no output, no
cursor movement, no error). This preserves MBASIC compatibility where digits are reserved
for count prefixes in the full EDIT implementation. Future enhancement will parse and
use digit prefixes to repeat commands.

The 'not yet implemented' suggests it's a missing feature, but 'INTENTIONAL BEHAVIOR' and 'preserves MBASIC compatibility' suggests it's working as designed. These statements are contradictory - either it's unimplemented (a gap) or it's intentionally compatible (working correctly).

---
#### code_vs_comment_conflict

**Description:** Comment in execute_list() warns about ProgramManager sync issues, but doesn't specify what operations might fail to maintain sync

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment: 'If ProgramManager fails to maintain this sync, LIST output may show stale or incorrect line text.'

The comment mentions 'add_line, delete_line, RENUM, MERGE' as operations that should maintain sync, but doesn't clarify if there are known cases where sync fails or if this is just a general warning.

---
#### code_vs_comment_conflict

**Description:** Comment in evaluate_functioncall() explains debugger_set=True usage but the actual code uses get_variable_for_debugger() for reading, not set_variable with debugger_set

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment states: 'Note: get_variable_for_debugger() and debugger_set=True are used to avoid triggering variable access tracking.'

However, the save code uses: 'saved_vars[param_name] = self.runtime.get_variable_for_debugger(param.name, param.type_suffix)'

And the restore code uses: 'self.runtime.set_variable(base_name, type_suffix, saved_value, debugger_set=True)'

The comment groups these together but they're different mechanisms - one for reading, one for writing.

---
#### Code vs Documentation inconsistency

**Description:** input_line() limitation about not preserving spaces is documented as platform limitation, but implementations don't attempt any workarounds

**Affected files:**
- `src/iohandler/base.py`
- `src/iohandler/console.py`
- `src/iohandler/curses_io.py`
- `src/iohandler/web_io.py`

**Details:**
base.py says: "KNOWN LIMITATION (not a bug - platform limitation):
Current implementations (console, curses, web) CANNOT fully preserve
leading/trailing spaces due to underlying platform API constraints"

But the implementations simply delegate to input() or getstr() without any attempt to work around the limitation (e.g., by prompting user to type a delimiter, or using raw input modes). The limitation is accepted without exploration of alternatives.

---
#### code_vs_documentation_inconsistency

**Description:** Default parameter value in __init__ doesn't match any preset configuration exactly

**Affected files:**
- `src/resource_limits.py`

**Details:**
The ResourceLimits.__init__() method has default values like:
- max_total_memory: int = 10*1024*1024  # 10MB default
- max_execution_time: float = 60.0  # 60 seconds

But the preset configurations use different values:
- create_web_limits(): 5MB, 30 seconds
- create_local_limits(): 100MB, 300 seconds
- create_unlimited_limits(): 1GB, 3600 seconds

The __init__ defaults (10MB, 60s) don't match any preset. This isn't necessarily wrong, but it means direct instantiation without using presets gives a configuration that's not documented as a recommended profile. The module docstring shows usage with presets but doesn't mention direct instantiation.

---
#### code_vs_comment

**Description:** Comment about line=-1 usage is inconsistent between different locations

**Affected files:**
- `src/runtime.py`

**Details:**
Line 47-52 in __init__ comment: "Note: line -1 in last_write indicates non-program execution sources:
1. System/internal variables (ERR%, ERL%) via set_variable_raw() with FakeToken(line=-1)
2. Debugger/interactive prompt via set_variable() with debugger_set=True and token.line=-1
Both use line=-1, making them indistinguishable from each other in last_write alone.
However, line=-1 distinguishes these special sources from normal program execution (line >= 0)."

Line 425-432 in set_variable_raw() comment: "The line=-1 marker in last_write indicates system/internal variables.
However, debugger sets also use line=-1 (via debugger_set=True),
making them indistinguishable from system variables in last_write alone.
Both are distinguished from normal program execution (line >= 0)."

These comments are consistent with each other, but the distinction between system/internal variables and debugger sets is mentioned as important yet they're stored identically. This may indicate a design issue where these should be distinguishable.

---
#### code_vs_comment

**Description:** Comment about token requirements is verbose and could be clearer

**Affected files:**
- `src/runtime.py`

**Details:**
Line 289-299 in get_variable(): "Token object is required but its attributes are optional:
- token.line: Preferred for tracking, falls back to self.pc.line_num if missing
- token.position: Preferred for tracking, falls back to None if missing

This allows robust handling of tokens from various sources (lexer, parser,
fake tokens) while enforcing that some token object must be provided.
For debugging without token requirements, use get_variable_for_debugger()."

This comment is accurate but the fallback behavior (using self.pc.line_num when token.line is missing) is not consistently documented elsewhere. The set_variable() method has similar token handling but less detailed comments.

---
#### Code vs Documentation inconsistency

**Description:** BREAK command docstring mentions RUN but doesn't document relationship with enhanced_run

**Affected files:**
- `src/ui/cli_debug.py`

**Details:**
cmd_break() docstring states:
'Breakpoints can be set at any time (before or during execution). They are checked during program execution at each statement. Use RUN to start the program, and it will pause when reaching breakpoints.'

However, the code shows that breakpoint functionality requires enhance_run_command() to be called, which installs _install_breakpoint_handler(). The docstring doesn't mention this implementation detail or that RUN command is enhanced.

---
#### Documentation inconsistency

**Description:** cmd_step docstring references curses UI implementation details

**Affected files:**
- `src/ui/cli_debug.py`

**Details:**
cmd_step() docstring states:
'This implements statement-level stepping similar to the curses UI \'Step Statement\' command (Ctrl+T). The curses UI also has a separate \'Step Line\' command (Ctrl+K) which is not available in the CLI.'

This cross-references curses UI implementation in CLI debug module documentation, which creates coupling between documentation of separate modules. If curses keybindings change, this docstring would become outdated.

---
#### code_vs_comment

**Description:** Comment says 'Status bar stays at default' but code shows it's updated in some paths

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
In _debug_step() and _debug_step_line(), comments say:
# Status bar stays at default (STATUS_BAR_SHORTCUTS) - error message is in output
# Status bar stays at default (STATUS_BAR_SHORTCUTS) - completion message is in output

But in the paused path, status bar IS updated:
self.status_bar.set_text(f"Paused at {pc_display} - {key_to_display(STEP_KEY)}=Step...")

The comment is only accurate for error/completion paths, not the paused path.

---
#### Documentation inconsistency

**Description:** Comment on line 172 says CONTINUE_KEY is used for 'Go to line' in editor mode and 'Continue execution (Go)' in debugger mode, but the JSON key name is 'goto_line'. This dual-purpose nature is documented in comments but may be confusing.

**Affected files:**
- `src/ui/keybindings.py`

**Details:**
Lines 172-176:
# Go to line (also used for Continue execution in debugger context)
# Note: This key serves dual purpose - "Go to line" in editor mode and
# "Continue execution (Go)" in debugger mode. The JSON key is 'goto_line'
# to reflect its primary function, but CONTINUE_KEY name reflects debugger usage.
_continue_from_json = _get_key('editor', 'goto_line')

---
#### Documentation inconsistency

**Description:** KEYBINDINGS_BY_CATEGORY comment lists several keys as 'not included' but doesn't explain why SETTINGS_KEY (Ctrl+P) IS included in 'Global Commands' category despite being defined similarly to other excluded keys.

**Affected files:**
- `src/ui/keybindings.py`

**Details:**
Lines 189-199 comment lists excluded keys:
- CLEAR_BREAKPOINTS_KEY (menu only)
- STOP_KEY (shown in debugger context)
- MAXIMIZE_OUTPUT_KEY (menu-only)
- STACK_KEY (menu-only)
- Dialog-specific keys
- Context-specific keys

But SETTINGS_KEY = 'ctrl p' (line 183) IS included in KEYBINDINGS_BY_CATEGORY under 'Global Commands' (line 203). No explanation for why this one is included while others aren't.

---
#### Code inconsistency

**Description:** The _format_key_display function converts 'Ctrl+' notation to '^' notation, but keybindings.py already has key_to_display() function that does similar conversion. This creates two different sources of truth for key display formatting.

**Affected files:**
- `src/ui/keymap_widget.py`

**Details:**
keymap_widget.py lines 8-21:
def _format_key_display(key_str):
    if key_str.startswith('Ctrl+'):
        return '^' + key_str[5:]
    elif key_str.startswith('Shift+Ctrl+'):
        return 'Shift+^' + key_str[11:]
    return key_str

keybindings.py lines 127-149 has key_to_display() that converts urwid keys to display format:
def key_to_display(urwid_key):
    # Returns '^A', '^Shift+B', etc.

These two functions handle different input formats (Ctrl+ vs urwid format) but serve similar purposes, potentially causing confusion.

---
#### Code duplication with inconsistency risk

**Description:** Table formatting logic may be duplicated in markdown_renderer.py

**Affected files:**
- `src/ui/tk_help_browser.py`
- `src/ui/markdown_renderer.py`

**Details:**
In _format_table_row() method (line 663):
# Note: This implementation may be duplicated in src/ui/markdown_renderer.py.
# If both implementations exist and changes are needed to table formatting logic,
# consider extracting to a shared utility module to maintain consistency.

The comment suggests potential duplication but uses uncertain language ('may be duplicated'). This creates ambiguity about whether the duplication actually exists.

---
#### code_vs_comment

**Description:** _redraw() docstring mentions _parse_line_number() validation but doesn't explain what happens when validation fails

**Affected files:**
- `src/ui/tk_widgets.py`

**Details:**
Docstring says: 'See _parse_line_number() for the regex-based extraction logic that validates line number format (requires whitespace or end-of-line after the number).'

But in _redraw() code:
basic_line_num = self._parse_line_number(line_text)
if basic_line_num and basic_line_num in self.line_metadata:
    metadata = self.line_metadata[basic_line_num]
    status = metadata['status']
else:
    status = ' '

When validation fails (basic_line_num is None), the status is set to ' ' (space). This behavior is not documented in the docstring, which only mentions the validation exists but not what happens on failure.

---
#### documentation_inconsistency

**Description:** Inconsistent version number references - hardcoded '5.21' vs imported VERSION

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Multiple locations reference version numbers:
1. Line ~558: # Note: '5.21' is the MBASIC language version (intentionally hardcoded)
2. Line ~560: ui.label('MBASIC 5.21 Web IDE').classes('text-lg')
3. Line ~561: ui.label(f'{VERSION}').classes('text-md text-gray-600 mb-4')
4. Line ~1000: self.output_text = f'MBASIC 5.21 Web IDE - {VERSION}\n'
5. Line ~1063: ui.page_title('MBASIC 5.21 - Web IDE')

The comment clarifies '5.21' is the language version and VERSION is the implementation version, but this distinction is not consistently documented throughout the file.

---
#### code_internal_inconsistency

**Description:** Inconsistent handling of editor placeholder clearing

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
In OpenFileDialog._open_file() at line ~467:
# Clear placeholder once content is loaded
if content:
    self.backend.editor_has_been_used = True
    self.backend.editor.props('placeholder=""')

However, editor_has_been_used is set but never initialized in __init__ (line ~976-1024). This suggests either:
1. Missing initialization
2. Attribute is set elsewhere
3. Code relies on Python's dynamic attribute creation

---
#### documentation_inconsistency

**Description:** Inconsistent keyboard shortcut documentation for toggling breakpoints

**Affected files:**
- `docs/help/common/debugging.md`
- `docs/help/common/editor-commands.md`

**Details:**
docs/help/common/debugging.md states:
'Tk UI: Click line number gutter, or **Ctrl+B** on line'
'Curses UI: Position cursor on line and press **b**'

But docs/help/common/editor-commands.md in the Debugging Commands table shows:
'**b** | **Ctrl+B** | Toggle breakpoint (Curses: **b**, Tk: **Ctrl+B**)'

The editor-commands.md suggests 'b' is an alternative to Ctrl+B, but debugging.md clarifies they are UI-specific (Curses uses 'b', Tk uses 'Ctrl+B'). The 'Alternative' column in editor-commands.md is misleading.

---
#### code_vs_documentation

**Description:** Settings dialog shows auto-save settings not mentioned in debugging documentation

**Affected files:**
- `src/ui/web/web_settings_dialog.py`
- `docs/help/common/debugging.md`

**Details:**
src/ui/web/web_settings_dialog.py and src/ui/web/session_state.py both reference auto-save settings:
- auto_save_enabled: bool = True
- auto_save_interval: int = 30

However, docs/help/common/debugging.md and other documentation files make no mention of auto-save functionality. Users would not know this feature exists or how to configure it.

---
#### documentation_inconsistency

**Description:** Inconsistent key binding documentation format

**Affected files:**
- `docs/help/common/editor-commands.md`

**Details:**
In the Program Commands table:
'**b** | **Ctrl+O** | Load program'

But 'b' is also listed in Debugging Commands as:
'**b** | **Ctrl+B** | Toggle breakpoint (Curses: **b**, Tk: **Ctrl+B**)'

The same key 'b' is documented for two different functions (Load program and Toggle breakpoint) without clarification about context or UI-specific behavior. This could confuse users about when 'b' does what.

---
#### code_vs_comment

**Description:** Version comment claims automatic increment but manual verification needed

**Affected files:**
- `src/version.py`

**Details:**
Comment states:
'VERSION is automatically incremented by utils/checkpoint.sh after each commit.
Manual edits to VERSION will be overwritten by the next checkpoint.'

However, VERSION = '1.0.756' is a hardcoded string in the file. Without seeing utils/checkpoint.sh or git history, we cannot verify if this automation actually works or if the comment is aspirational. The comment also says 'This appears in debug output so Claude can verify the user has latest code' which is an unusual comment suggesting AI-assisted development workflow.

---
#### documentation_inconsistency

**Description:** PI computation precision note appears in both files with slightly different wording

**Affected files:**
- `docs/help/common/language/appendices/math-functions.md`
- `docs/help/common/language/functions/atn.md`

**Details:**
math-functions.md states: "PI can be computed with ATN(1) * 4\n' (Note: ATN is evaluated in single precision, ~7 digits)" while atn.md states: "Note: When computing PI with ATN(1) * 4, the result is limited to single precision (~7 digits). For higher precision, use ATN(CDBL(1)) * 4 to get double precision." The atn.md version provides more complete information about the workaround.

---
#### documentation_inconsistency

**Description:** Error handling cross-reference points to section that may not exist

**Affected files:**
- `docs/help/common/language/appendices/index.md`
- `docs/help/common/language/appendices/error-codes.md`

**Details:**
index.md states: "Error handling references (see [Error Handling](../statements/index.md#error-handling) for detailed examples)" but this cross-reference format assumes a specific anchor exists in statements/index.md which is not provided in the documentation files shown.

---
#### documentation_inconsistency

**Description:** Duplicate basic language information with different organization

**Affected files:**
- `docs/help/common/language.md`
- `docs/help/common/getting-started.md`

**Details:**
Both language.md and getting-started.md cover basic BASIC concepts like PRINT, INPUT, FOR...NEXT, and IF...THEN, but with different levels of detail and organization. language.md is more reference-style while getting-started.md is tutorial-style, but there's no clear indication of which to use when or how they relate.

---
#### documentation_inconsistency

**Description:** Index page lists functions in 'By Category' section but some categorizations may be debatable

**Affected files:**
- `docs/help/common/language/functions/index.md`

**Details:**
SPC and TAB are listed under 'String Functions' but they are actually PRINT statement modifiers/functions that control output formatting, not string manipulation functions. They might be better categorized under a 'File I/O Functions' or 'Output Functions' category, or their own 'Formatting Functions' category.

---
#### documentation_inconsistency

**Description:** HEX$ and OCT$ have slightly different example styles

**Affected files:**
- `docs/help/common/language/functions/hex_dollar.md`
- `docs/help/common/language/functions/oct_dollar.md`

**Details:**
hex_dollar.md example:
```basic
10 INPUT X
20 A$ = HEX$(X)
30 PRINT X; "DECIMAL IS "; A$; " HEXADECIMAL"
RUN
? 32
32 DECIMAL IS 20 HEXADECIMAL
Ok
```

oct_dollar.md has TWO examples:
1. Similar to HEX$ with INPUT
2. A simpler direct PRINT example

For consistency, both should have similar example structures, or both should have multiple examples showing different use cases.

---
#### documentation_inconsistency

**Description:** STRING$ example output formatting is inconsistent with typical BASIC output

**Affected files:**
- `docs/help/common/language/functions/string_dollar.md`

**Details:**
In string_dollar.md Example:
```basic
10 X$ = STRING$(10, 45)
20 PRINT X$ "MONTHLY REPORT" X$
```

Output:
```
---
#### documentation_inconsistency

**Description:** CLOAD and CSAVE documentation titles include 'THIS COMMAND IS NOT INCLUDED IN THE DEC VT180 VERSION' but don't clarify if they're implemented in this interpreter

**Affected files:**
- `docs/help/common/language/statements/cload.md`
- `docs/help/common/language/statements/csave.md`

**Details:**
Both cload.md and csave.md have titles like:
'CLOAD - THIS COMMAND IS NOT INCLUDED IN THE DEC VT180 VERSION'

But unlike CALL, USR, and VARPTR which have clear 'Implementation Note' sections stating they're not implemented, these cassette commands don't have such notes. It's unclear if they're implemented in this Python interpreter or not.

---
#### documentation_inconsistency

**Description:** Index page lists 'LINE INPUT#' with link to inputi.md but the actual file is input_hash.md

**Affected files:**
- `docs/help/common/language/statements/index.md`

**Details:**
In the alphabetical listing under 'I':
[LINE INPUT#](inputi.md) - Input entire line from file

But in the 'File I/O' category:
[LINE INPUT#](inputi.md) - Line input from file

However, the actual INPUT# documentation file is named input_hash.md, not inputi.md. There may be a missing file or incorrect link.

---
#### documentation_inconsistency

**Description:** DEFINT/SNG/DBL/STR example shows conflicting type declarations without explaining precedence clearly

**Affected files:**
- `docs/help/common/language/statements/defint-sng-dbl-str.md`

**Details:**
Example line 50 shows:
50 AMOUNT$ = "100"  ' String (has $ suffix, overrides DEFSTR)

But line 20 already declared:
20 DEFSTR A

The comment says '$ suffix overrides DEFSTR' but AMOUNT$ starts with A, so DEFSTR A would already make it a string. The example is confusing because it suggests the $ is overriding something when both would make it a string anyway. A better example would show a type suffix overriding a DIFFERENT DEFtype declaration.

---
#### documentation_inconsistency

**Description:** EDIT documentation references non-existent line editor commands

**Affected files:**
- `docs/help/common/language/statements/edit.md`

**Details:**
The documentation states:
'The traditional MBASIC single-character edit mode commands (I, D, C, L, Q, etc.) are **not implemented**'

But then says:
'Simply edit program lines directly in the full-screen editor.'

This is confusing because it mentions commands that don't exist, then says to use a different editor. It would be clearer to simply state that EDIT is not implemented or redirects to the full-screen editor, without mentioning the historical commands at all.

---
#### documentation_inconsistency

**Description:** GOSUB and GOTO have inconsistent 'See Also' sections

**Affected files:**
- `docs/help/common/language/statements/gosub-return.md`
- `docs/help/common/language/statements/goto.md`

**Details:**
GOSUB-RETURN.md references:
- FOR...NEXT
- GOTO
- IF...THEN...ELSE
- ON...GOSUB/ON...GOTO
- WHILE...WEND

GOTO.md references:
- FOR ‚Ä¢‚Ä¢‚Ä¢ NEXT (with bullets)
- GOSUB ‚Ä¢.. RETURN (with bullets)
- IF ‚Ä¢‚Ä¢‚Ä¢ THEN[ ‚Ä¢‚Ä¢‚Ä¢ ELSE] AND IF ‚Ä¢‚Ä¢‚Ä¢ GOTO (different format)
- ON ‚Ä¢‚Ä¢‚Ä¢ GOSUB AND ON ‚Ä¢‚Ä¢‚Ä¢ GOTO (different format)
- WHILE ‚Ä¢‚Ä¢‚Ä¢ WEND (with bullets)

The formatting is inconsistent (bullets vs no bullets, different title formats). They should use consistent formatting.

---
#### documentation_inconsistency

**Description:** Contradictory information about file closing behavior

**Affected files:**
- `docs/help/common/language/statements/load.md`
- `docs/help/common/language/statements/merge.md`

**Details:**
load.md states:
'**LOAD** (without ,R): Closes all open files and deletes all variables and program lines currently in memory before loading'
'**LOAD** with **,R** option: Program is RUN after loading, and all open data files are **kept open** for program chaining'
'Compare with **MERGE**: Never closes files (see [MERGE](merge.md))'

merge.md states:
'**File handling:** Unlike LOAD (without ,R), MERGE does **NOT close open files**. Files that are open before MERGE remain open after MERGE completes. (Compare with [LOAD](load.md) which closes files except when using the ,R option.)'

These are consistent with each other, but the phrasing could be clearer about the three cases: LOAD without ,R (closes files), LOAD with ,R (keeps files open), and MERGE (keeps files open).

---
#### documentation_inconsistency

**Description:** RENUM example shows unchanged output after renumbering

**Affected files:**
- `docs/help/common/language/statements/renum.md`

**Details:**
In renum.md Example 1:
'```basic
10 PRINT "START"
20 GOTO 40
30 PRINT "SKIP THIS"
40 PRINT "END"

RENUM

10 PRINT "START"
20 GOTO 40
30 PRINT "SKIP THIS"
40 PRINT "END"
```'

The output after RENUM is identical to the input, which doesn't demonstrate what RENUM does. This appears to be a documentation error - the output should show the renumbered lines.

---
#### documentation_inconsistency

**Description:** Semantic analyzer status claims contradictory

**Affected files:**
- `docs/help/mbasic/architecture.md`

**Details:**
architecture.md states 'Semantic Analyzer: ‚úÖ Complete (18 optimizations)' and 'The semantic analyzer is production-ready' but also says 'Code Generation: ‚ùå Not implemented (future work)'. Later it says 'Current status: Analysis only (no code generation yet)'. The claim of being 'production-ready' and 'Complete' is misleading when it's only the analysis phase without code generation - it cannot actually produce optimized code, only analyze and report.

---
#### documentation_inconsistency

**Description:** Inconsistent listing of supported UIs between documents

**Affected files:**
- `docs/help/mbasic/features.md`
- `docs/help/mbasic/getting-started.md`

**Details:**
features.md lists: 'Curses UI (Default), CLI Mode, Tkinter GUI, Web UI' (4 interfaces)

getting-started.md 'Choosing a User Interface' section lists: 'Curses UI (Default), CLI Mode, Tkinter GUI, Web UI' (4 interfaces)

But getting-started.md 'Quick Reference' only shows 3: 'CLI, Curses, Tkinter' - missing Web UI

---
#### documentation_inconsistency

**Description:** STEP INTO/OVER documented but marked as not implemented in same document

**Affected files:**
- `docs/help/ui/cli/debugging.md`

**Details:**
cli/debugging.md 'STEP - Single-Step Execution' section shows syntax:
'STEP [n] - Execute n statements (default: 1)
STEP INTO - Step into subroutines
STEP OVER - Step over subroutine calls'

But later under 'Limitations' section:
'STEP INTO/OVER not yet implemented (use STEP)'

This is contradictory within the same document.

---
#### documentation_inconsistency

**Description:** Different command examples for starting MBASIC

**Affected files:**
- `docs/help/mbasic/getting-started.md`
- `docs/help/ui/cli/index.md`

**Details:**
getting-started.md shows:
'mbasic' (no python3 prefix)
'mbasic --ui cli'
'mbasic --ui tk'
'mbasic --ui web'

cli/index.md shows:
'mbasic' (no python3 prefix)

But getting-started.md 'Quick Install' section shows:
'python3 mbasic' (with python3 prefix)

Inconsistent about whether to use 'python3 mbasic' or just 'mbasic' command.

---
#### documentation_inconsistency

**Description:** Settings commands not listed in main features document

**Affected files:**
- `docs/help/ui/cli/settings.md`
- `docs/help/mbasic/features.md`

**Details:**
cli/settings.md documents:
'SHOWSETTINGS [filter]'
'SETSETTING key value'

These are CLI commands for managing settings, but features.md does not list them under 'Program Control' or 'Direct Commands' sections. They should be documented as available commands.

---
#### documentation_inconsistency

**Description:** Installation instructions reference non-existent requirements.txt

**Affected files:**
- `docs/help/mbasic/getting-started.md`

**Details:**
getting-started.md 'Quick Install' section shows:
'# Install optional dependencies
pip install -r requirements.txt'

But no requirements.txt file is provided in the documentation files. This file path should be verified to exist in the actual project, or the documentation should specify the correct path or list dependencies explicitly.

---
#### documentation_inconsistency

**Description:** Incomplete keyboard shortcuts for Variables Window

**Affected files:**
- `docs/help/ui/curses/quick-reference.md`
- `docs/help/ui/curses/variables.md`

**Details:**
quick-reference.md lists Variables Window keys: "s | Cycle sort mode, d | Toggle sort direction, f | Cycle filter mode, / | Search for variable, n | Next search match, N | Previous search match"

variables.md lists additional keys not in quick-reference: "v | Toggle value truncation, t | Toggle type display, d | Show decimal/hex toggle, w | Word wrap long strings, r | Refresh, u | Toggle auto-update, e | Export to file, h | Help, p | Pin window, q | Close"

The quick-reference is missing many documented keyboard shortcuts for the Variables Window.

---
#### documentation_inconsistency

**Description:** Run Program keyboard shortcut presentation inconsistency

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/tk/getting-started.md`

**Details:**
feature-reference.md states:
'Run Program (Ctrl+R or F5)'
'Shortcuts: Ctrl+R or F5'

getting-started.md states:
'Run it: Press {{kbd:run_program}} or Run ‚Üí Run Program'

The template {{kbd:run_program}} should expand to show both shortcuts for consistency.

---
#### documentation_inconsistency

**Description:** Stop/Interrupt keyboard shortcut inconsistency with standard conventions

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`

**Details:**
feature-reference.md states:
'Stop/Interrupt (Ctrl+X)
Stop a running program immediately.
- Menu: Run ‚Üí Stop
- Shortcut: Ctrl+X'

But Ctrl+X is conventionally used for 'Cut' in most applications. The Quick Reference table at the bottom of the same document confirms:
'Ctrl+X | Stop Program'

This might conflict with the Cut operation mentioned elsewhere in the document under 'Cut/Copy/Paste (Ctrl+X/C/V)'.

---
#### documentation_inconsistency

**Description:** Default UI inconsistency

**Affected files:**
- `docs/help/ui/tk/getting-started.md`
- `docs/help/ui/tk/index.md`

**Details:**
getting-started.md states:
'Or to use the default curses UI:
```bash
mbasic [filename.bas]
```'

This implies curses is the default UI. However, index.md states:
'**Start the GUI:**
```bash
mbasic --ui tk [filename.bas]
```'

The documentation should clarify which UI is actually the default when no --ui flag is specified.

---
#### documentation_inconsistency

**Description:** Visual indicator color inconsistency

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`

**Details:**
feature-reference.md states under 'Visual Indicators':
'**‚óè** - Breakpoint on line'

But under 'Breakpoints' section:
'Visual indicator: ‚óè symbol'

And in features.md:
'Blue ‚óè appears'

The color of the breakpoint indicator should be consistently documented. feature-reference.md doesn't specify the color.

---
#### documentation_inconsistency

**Description:** Syntax error indicator inconsistency

**Affected files:**
- `docs/help/ui/tk/feature-reference.md`
- `docs/help/ui/tk/features.md`

**Details:**
feature-reference.md states:
'**Red underline** - Syntax error'

features.md states:
'Red **?** appears in gutter for errors'

These describe different visual indicators for syntax errors (underline vs. ? symbol in gutter).

---
#### documentation_inconsistency

**Description:** Inconsistent Settings dialog access instructions

**Affected files:**
- `docs/help/ui/web/getting-started.md`
- `docs/help/ui/web/settings.md`

**Details:**
getting-started.md does not mention how to access the Settings dialog in the main interface overview section.

settings.md states: "Click the ‚öôÔ∏è Settings icon in the navigation bar" or "Click menu ‚Üí Settings"

The getting-started.md should mention the Settings icon/menu in the Interface Overview section for consistency.

---
#### documentation_inconsistency

**Description:** Incomplete information about Settings tabs

**Affected files:**
- `docs/help/ui/web/settings.md`

**Details:**
settings.md describes two tabs: 'Editor Tab' and 'Limits Tab'

The dialog interface diagram shows: "üìù Editor    üìä Limits"

However, the document doesn't clarify if there are any other tabs or if this is the complete set. The web-interface.md mentions 'Settings - Configure auto-numbering, case handling, and other interpreter options' which suggests more settings than just auto-numbering and limits.

---
#### documentation_inconsistency

**Description:** Inconsistent variable name in example code

**Affected files:**
- `docs/user/CASE_HANDLING_GUIDE.md`

**Details:**
In the 'Problem 1: Accidental Typos' section, the example shows:
'10 TotalCount = 0
20 FOR I = 1 TO 10
30   TotalCont = TotalCont + I   ‚Üê Typo! Missing 'u'
40 NEXT I
50 PRINT TotalCount'

The comment says 'Missing 'u'' but the actual typo is that 'TotalCont' is missing the 'u' to be 'TotalCount'. However, line 30 shows 'TotalCont = TotalCont + I' which means it's consistently using the misspelled version on both sides of the assignment. The example would be clearer if it showed: 'TotalCont = TotalCount + I' to demonstrate that the typo creates a NEW variable that doesn't get printed.

---
#### documentation_inconsistency

**Description:** Incomplete file extension list

**Affected files:**
- `docs/user/FILE_FORMAT_COMPATIBILITY.md`

**Details:**
The 'File Extensions' section lists:
'- `.bas` - Standard BASIC program files (recommended)
- `.BAS` - Uppercase variant (also supported)
- `.txt` - Plain text files containing BASIC code'

However, the section title says 'MBASIC recognizes these file extensions' but doesn't clarify if this is an exhaustive list or if other extensions might also work. Additionally, it's unclear if files without extensions are supported (e.g., just 'program' with no extension).

---
#### documentation_inconsistency

**Description:** Different keyboard shortcuts documented for same actions across UIs without clear cross-reference

**Affected files:**
- `docs/user/TK_UI_QUICK_START.md`
- `docs/user/keyboard-shortcuts.md`

**Details:**
TK_UI_QUICK_START.md shows:
- Ctrl+H for Find and Replace
- Ctrl+? for Help
- No Ctrl+U mentioned

keyboard-shortcuts.md (Curses) shows:
- ^U for Activate menu bar
- ^F for Help (not Ctrl+?)
- ^P for Settings

These differences are expected between UIs but there's no clear statement that keyboard-shortcuts.md is ONLY for Curses UI, and TK_UI_QUICK_START.md doesn't have a complete shortcuts reference.

---
#### documentation_inconsistency

**Description:** TK_UI_QUICK_START.md mentions 'Ctrl+?' for help but this shortcut is not standard across platforms

**Affected files:**
- `docs/user/TK_UI_QUICK_START.md`

**Details:**
Document states:
'| **Ctrl+?** | Show/hide Variables Window |' (in table)
And later: '- **In-app help**: Press **Ctrl+?** or use Help menu'

Ctrl+? is not a standard keyboard shortcut and may not work on all platforms (? requires Shift on most keyboards, making it Ctrl+Shift+/). This should be clarified or changed to a more standard shortcut like F1.

---
#### documentation_inconsistency

**Description:** Settings file location uses ~ for home directory but doesn't explain this is Unix/Linux notation

**Affected files:**
- `docs/user/SETTINGS_AND_CONFIGURATION.md`

**Details:**
Document states:
'**Location:**
- **Linux/Mac:** `~/.mbasic/settings.json`
- **Windows:** `%APPDATA%/mbasic/settings.json`'

The ~ notation is explained implicitly by context but Windows users unfamiliar with Unix might not understand it. Should add '(home directory)' or similar clarification.

---
#### documentation_inconsistency

**Description:** Document mentions 'Stmt' toolbar button but doesn't explain what 'Stmt' means or how it differs from 'Step'

**Affected files:**
- `docs/user/TK_UI_QUICK_START.md`

**Details:**
Document states:
'Click the **Stmt** toolbar button (step statement) to move through each part:'

And later:
'Click the **Step** toolbar button (step line) to execute the entire line at once.'

The abbreviation 'Stmt' is not explained until used in context. Should define 'Stmt = Statement' earlier or use full word 'Statement' in toolbar button description.

---
#### documentation_inconsistency

**Description:** Document shows 'interpreter.max_execution_time' default as 30 seconds but doesn't explain what happens when time limit is reached

**Affected files:**
- `docs/user/SETTINGS_AND_CONFIGURATION.md`

**Details:**
Document states:
'### interpreter.max_execution_time

**Controls:** Maximum program execution time in seconds

**Type:** Integer (1-3600)

**Default:** `30`

**Example:**
```basic
SET "interpreter.max_execution_time" 60
' Program will stop after 60 seconds
```

Set to `0` for unlimited execution time (use with caution).'

Doesn't explain:
- What error message appears when time limit is reached
- Whether program can be resumed
- Whether this applies to all UIs or just some
- Whether debugging (stepping) counts toward time limit

---