# Documentation Changes (v13)

Generated by splitting docs_inconsistencies_report-v13.md
Contains: Documentation and comment fixes (no code behavior changes)

## ðŸ“‹ Documentation Inconsistencies

### ðŸ”´ High Severity

#### Documentation inconsistency

**Description:** Contradictory information about ProgramManager.load_from_file() return value

**Affected files:**
- `src/editing/manager.py`
- `src/file_io.py`

**Details:**
src/editing/manager.py docstring states:
"Note: ProgramManager.load_from_file() returns (success, errors) tuple where errors
is a list of (line_number, error_message) tuples for direct UI error reporting,
while FileIO.load_file() returns raw file text."

But the actual implementation in manager.py returns:
"Returns:
    Tuple of (success, errors)
    success: True if at least one line loaded successfully
    errors: List of (line_number, error_message) for failed lines"

This matches the docstring claim. However, the module docstring emphasizes this distinction as if it's a key architectural difference, but both abstractions serve completely different purposes (ProgramManager parses and stores lines, FileIO just returns raw text), so the comparison seems misleading.

---
#### code_vs_comment

**Description:** Comment claims CLEAR silently ignores file close errors, but code uses bare except

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line ~1273 states:
"# Close all open files
# Note: Errors during file close are silently ignored (bare except: pass)"

Code at line ~1275:
for file_num in list(self.runtime.files.keys()):
    try:
        file_obj = self.runtime.files[file_num]
        if hasattr(file_obj, 'close'):
            file_obj.close()
    except:
        pass

However, execute_reset at line ~1730 has a different comment:
"# Note: Unlike CLEAR (which silently ignores file close errors), RESET allows
# errors during file close to propagate to the caller."

But execute_reset code at line ~1735 also silently closes files without try/except, so errors would propagate. The inconsistency is that CLEAR's comment claims intentional error suppression, while RESET's comment claims intentional error propagation, but the actual difference is CLEAR has try/except and RESET doesn't.

---
#### Code vs Documentation inconsistency

**Description:** auto_save.py module exists but is not referenced in base.py UIBackend documentation

**Affected files:**
- `src/ui/auto_save.py`
- `src/ui/base.py`

**Details:**
base.py documents UIBackend interface and lists potential backend types (CLIBackend, CursesBackend, TkBackend, WebBackend, BatchBackend) but makes no mention of auto-save functionality. The auto_save.py module provides AutoSaveManager class with comprehensive auto-save features, but there's no documentation about how/if UI backends should integrate with it.

---
#### code_vs_comment

**Description:** Critical inconsistency: _check_line_syntax comment says empty lines are valid, but code rejects line 0

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
In _update_syntax_errors:
"# Skip empty code lines
if not code_area.strip() or line_number is None:
    # Clear error status for empty lines, but preserve breakpoints
    # Note: line_number > 0 check handles edge case of line 0 (if present)
    # Consistent with _check_line_syntax which treats all empty lines as valid
    if line_number is not None and line_number > 0:"

The comment claims consistency with _check_line_syntax treating 'all empty lines as valid', but the code explicitly excludes line_number == 0 from this treatment. This means line 0 (if it exists) would NOT get its error status cleared even if empty, which contradicts the 'all empty lines' claim.

---
#### code_vs_comment_conflict

**Description:** Both files load keybindings from the same JSON file but have different comments explaining the purpose. help_macros.py says it's for macro expansion (different from help_widget.py event handling), while keybinding_loader.py says it's for UI event handling (different from help_macros.py documentation generation). These comments create circular confusion.

**Affected files:**
- `src/ui/help_macros.py`
- `src/ui/keybinding_loader.py`

**Details:**
help_macros.py line ~30 comment:
"Load keybindings configuration for current UI.

Note: This is generic keybinding loading for macro expansion in help content (e.g., {{kbd:run}} -> '^R'). This is different from help_widget.py which uses hardcoded keys for its own navigation. HelpMacros needs full keybindings to expand {{kbd:action}} macros in documentation, not for actual event handling."

keybinding_loader.py line ~30 comment:
"Load keybindings configuration for current UI.

Note: This loads keybindings for UI event handling (binding keys to actions). This is different from help_macros.py which loads the same JSON for macro expansion in help content (e.g., {{kbd:run}} -> '^R'). These serve different purposes: KeybindingLoader for runtime event handling, HelpMacros for documentation generation."

Both load from the same JSON but claim opposite purposes, creating confusion about the architecture.

---
#### code_vs_comment

**Description:** Comment claims control characters modify text via deletion, but backspace/delete are not control characters in the ASCII sense

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1048: 'Allow control characters (backspace, delete) - these modify text via deletion, not by inserting printable characters, so they pass validation'
Code: 'if char_code in (8, 127):  # Backspace (0x08) or Delete (0x7F)'
Backspace (0x08) is technically a control character, but Delete (0x7F) is DEL, not a typical 'control character'. The comment conflates these concepts. More importantly, the comment justifies allowing them because they 'modify text via deletion' but this is misleading - they're allowed because they're editing commands, not because of how they modify text. The validation logic should be clearer.

---
#### code_vs_comment

**Description:** Comment about statement highlighting uses incorrect terminology for character positions

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1320: 'Lines are displayed exactly as stored in program manager (see _refresh_editor), so char_start/char_end from runtime are directly usable as Tk text indices'
This comment claims char positions from runtime can be 'directly' used as Tk indices, but Tk text indices are in format 'line.column'. The code does use them directly (line ~1330: 'start_idx = f"{editor_line_idx}.{char_start}"'), but this only works because the code assumes char_start is a column offset. The comment should clarify this assumption.

---
#### code_vs_comment

**Description:** Complex comment about avoiding interpreter.start() may indicate fragile code design

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _execute_immediate() method around line 1115:
"# Initialize interpreter state for execution
# NOTE: Don't call interpreter.start() because it calls runtime.setup()
# which resets PC to the first statement. The RUN command has already
# set PC to the correct line (e.g., RUN 120 sets PC to line 120).
# We only need to clear the halted flag and mark this as first line.
# This avoids the full initialization that start() does:
#   - runtime.setup() (rebuilds tables, resets PC)
#   - Creates new InterpreterState
#   - Sets up Ctrl+C handler
self.runtime.halted = False  # Clear halted flag to start execution
self.interpreter.state.is_first_line = True"

This comment describes working around the normal initialization flow, which suggests either:
1. The interpreter.start() API is not designed correctly for this use case
2. The code is bypassing proper initialization in a fragile way
3. There should be a separate API method for resuming vs starting

This needs architectural review.

---
#### code_vs_comment

**Description:** Comment in serialize_statement() claims REMARK is converted to REM during parsing, but code handles REMARK as a comment_type

**Affected files:**
- `src/ui/ui_helpers.py`

**Details:**
Comment in RemarkStatementNode handling states:
"# Preserve comments using original syntax (REM or ')
# Note: REMARK is converted to REM during parsing, not here"

However, the code checks stmt.comment_type for 'APOSTROPHE' vs else (which includes REM, REMARK, or default). The comment suggests REMARK should never appear here because it's converted during parsing, but the code structure (using else for 'REM, REMARK, or default') implies REMARK could be a valid comment_type value. This is contradictory.

---
#### code_vs_comment

**Description:** Breakpoint implementation comment describes PC objects exclusively but code handles both PC objects and plain integers

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
In _update_breakpoint_display() comment says: 'Note: self.runtime.breakpoints is a set that can contain:
#   - PC objects (statement-level breakpoints, created by _toggle_breakpoint)
#   - Plain integers (line-level breakpoints, legacy/compatibility)
# This implementation uses PC objects exclusively, but handles both for robustness.'

However, _toggle_breakpoint() creates PC objects with stmt_offset=0 for line-level breakpoints, not plain integers. The comment suggests plain integers are used for line-level, but the code uses PC(line_num, 0) instead.

---
#### code_vs_comment

**Description:** Comment claims _get_input_async uses two mechanisms but the actual implementation and flow is unclear

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~1577 says:
"Provide input to interpreter via TWO mechanisms (both may be needed depending on code path):
1. interpreter.provide_input() - Used when interpreter is waiting synchronously
   (checked via interpreter.state.input_prompt). Stores input for retrieval.
2. input_future.set_result() - Used when async code is waiting via asyncio.Future
   (see _get_input_async method). Only one path is active at a time, but we
   attempt both to ensure the waiting code receives input regardless of which path it used."

However, the comment says 'Only one path is active at a time' but then says 'we attempt both'. This is contradictory. Additionally, the code attempts both mechanisms unconditionally, which could cause issues if both are active simultaneously despite the comment claiming only one is active.

---
#### documentation_inconsistency

**Description:** LINE INPUT# documentation has incorrect filename and cross-reference

**Affected files:**
- `docs/help/common/language/statements/inputi.md`
- `docs/help/common/language/statements/line-input.md`

**Details:**
File inputi.md has title 'LINE INPUT# (File)' but the See Also section references 'LINE INPUT#' with link to input_hash.md (which is for INPUT#, not LINE INPUT#). The line-input.md file correctly documents LINE INPUT (console version) and references LINE INPUT# with link to input_hash.md, but input_hash.md is actually about INPUT# not LINE INPUT#. There appears to be no separate documentation file for LINE INPUT# despite it being referenced.

---
#### documentation_inconsistency

**Description:** Inconsistent documentation about file closure behavior across RUN, STOP, and SYSTEM commands

**Affected files:**
- `docs/help/common/language/statements/run.md`
- `docs/help/common/language/statements/stop.md`
- `docs/help/common/language/statements/system.md`

**Details:**
RUN doc: 'All open files are closed (unlike STOP, which keeps files open)'
STOP doc: 'Unlike the END statement, the STOP statement does not close files.'
SYSTEM doc: 'When SYSTEM is executed: - All open files are closed'

RUN says STOP keeps files open, but doesn't mention what END does. STOP says END closes files. This creates a chain of references that could be clearer with a comparison table.

---
#### documentation_inconsistency

**Description:** UI_FEATURE_COMPARISON.md shows 'Save (interactive)' as unavailable (âŒ) for CLI, but doesn't clarify that SAVE command works - this contradicts the Notes column explanation

**Affected files:**
- `docs/user/UI_FEATURE_COMPARISON.md`
- `docs/user/TK_UI_QUICK_START.md`

**Details:**
UI_FEATURE_COMPARISON.md table shows:
'| **Save (interactive)** | âŒ | âœ… | âœ… | âœ… | Ctrl+S prompts for filename |'

But later states:
'**Limitations:**
- No interactive save prompt (must use SAVE "filename" command instead)'

And in 'Known Gaps':
'- CLI: No interactive save prompt (use SAVE "filename" command instead)'

The table entry is misleading because it suggests CLI can't save at all, when it just lacks the interactive prompt. The Notes column says 'Ctrl+S prompts for filename' but doesn't clarify that CLI has SAVE command.

---
### ðŸŸ¡ Medium Severity

#### documentation_inconsistency

**Description:** Version number inconsistency between setup.py and ast_nodes.py documentation

**Affected files:**
- `setup.py`
- `src/ast_nodes.py`

**Details:**
setup.py line 3: 'Setup script for MBASIC 5.21 Interpreter (version 0.99.0)'
setup.py line 5: 'Package version 0.99.0 reflects approximately 99% implementation status (core complete).'
setup.py line 16: 'version="0.99.0"'

ast_nodes.py line 3: 'Note: 5.21 refers to the Microsoft BASIC-80 language version, not this package version.'

The setup.py conflates MBASIC 5.21 (the language being interpreted) with package version 0.99.0 (the interpreter implementation). The ast_nodes.py correctly clarifies that 5.21 is the language version, not the package version. This creates confusion about what '5.21' means in different contexts.

---
#### code_vs_comment_conflict

**Description:** LineNode docstring claims no source_text field to avoid duplication, but design note contradicts actual regeneration mechanism

**Affected files:**
- `src/ast_nodes.py`

**Details:**
LineNode docstring lines 149-157:
'The AST is the single source of truth. Text is always regenerated from the AST using statement token information (each statement has char_start/char_end and tokens preserve original_case for keywords and identifiers).

Design note: This class intentionally does not have a source_text field to avoid maintaining duplicate copies that could get out of sync with the AST during editing. Text regeneration is handled by the position_serializer module which reconstructs source text from statement nodes and their token information. Each StatementNode has char_start/char_end offsets that indicate the character position within the regenerated line text.'

This claims text is regenerated from 'statement token information' and 'tokens preserve original_case', but PrintStatementNode comment (line 237) says 'keyword_token fields... are not currently used by position_serializer, which handles keyword case through case_keepy_string() instead'. This suggests tokens are NOT used for regeneration as the LineNode docstring claims.

---
#### code_vs_comment

**Description:** Comment in EOF() method describes mode 'I' as 'Input' but implementation comment says it's 'binary input mode'

**Affected files:**
- `src/basic_builtins.py`

**Details:**
Line ~570: Comment says "Mode 'I' means 'Input' in MBASIC syntax" but later says "Mode 'I' = binary input mode, where files are opened in binary mode ('rb')". The distinction between 'Input' (sequential text) vs 'binary input' is unclear. The code checks for ^Z (ASCII 26) which is CP/M binary EOF marker, suggesting 'I' is specifically binary mode, not general input.

---
#### code_vs_comment

**Description:** Comment about trailing_minus_only behavior is inconsistent with variable name and usage

**Affected files:**
- `src/basic_builtins.py`

**Details:**
Line ~145: Comment says "trailing_minus_only: - at end, adds - for negative or space for non-negative (always 1 char)" but the implementation at line ~280 shows it adds '-' for negative and ' ' for positive, which matches the comment. However, the variable name 'trailing_minus_only' suggests it only adds minus (not space), creating semantic confusion.

---
#### code_vs_comment

**Description:** EOF() implementation checks next_byte[0] assuming binary mode returns bytes, but doesn't verify mode is actually binary

**Affected files:**
- `src/basic_builtins.py`

**Details:**
Line ~575: Code does "next_byte[0] == 26" which assumes next_byte is bytes object (binary mode). Comment says mode 'I' is binary, but if file was opened in text mode by mistake, next_byte would be string and next_byte[0] would be a character, not an integer. No type checking or error handling for this case.

---
#### Documentation inconsistency

**Description:** Duplicate two-letter error codes mentioned in error_codes.py but not relevant to file I/O modules

**Affected files:**
- `src/file_io.py`
- `src/filesystem/base.py`

**Details:**
src/error_codes.py states:
"Note: Some two-letter codes are duplicated (e.g., DD, CN, DF) across different
numeric error codes. This matches the original MBASIC 5.21 specification where
the two-letter codes alone are ambiguous - the numeric code is authoritative."

The error codes show:
- DD appears at code 10 ("Duplicate definition") and code 68 ("Device unavailable")
- CN appears at code 17 ("Can't continue") and code 69 ("Communication buffer overflow")
- DF appears at code 25 ("Device fault") and code 61 ("Disk full")

However, neither src/file_io.py nor src/filesystem/base.py reference error_codes.py or use these error codes. They raise generic Python exceptions (FileNotFoundError, IOError, OSError, PermissionError) instead of MBASIC error codes. This is an architectural inconsistency - file operations should potentially use MBASIC error codes for consistency.

---
#### Code vs Comment conflict

**Description:** InMemoryFileHandle.flush() comment describes behavior that differs from standard file flush()

**Affected files:**
- `src/filesystem/sandboxed_fs.py`

**Details:**
The flush() method has this comment:
"Flush write buffers (no-op for in-memory files).

Note: This calls StringIO/BytesIO flush() which are no-ops.
Content is only saved to the virtual filesystem on close().
Unlike standard file flush() which persists buffered writes to disk,
in-memory file writes are already in memory, so flush() has no effect."

The code implementation:
def flush(self):
    if hasattr(self.file_obj, 'flush'):
        self.file_obj.flush()

This is correct - StringIO/BytesIO flush() are indeed no-ops. However, the comment could be misleading because it suggests flush() does nothing, but the actual semantic difference is that in-memory files don't need flushing since writes are immediately in memory. The comment is accurate but could be clearer about the architectural difference.

---
#### Documentation inconsistency

**Description:** Inconsistent terminology for storage location in Web UI

**Affected files:**
- `src/file_io.py`
- `src/filesystem/base.py`
- `src/filesystem/sandboxed_fs.py`

**Details:**
src/file_io.py SandboxedFileIO docstring states:
"Storage location: Python server memory (NOT browser localStorage)."

src/filesystem/sandboxed_fs.py SandboxedFileSystemProvider docstring states:
"Features:
- All files stored in memory (no disk access)"

Both describe in-memory storage, but src/file_io.py explicitly contrasts with "browser localStorage" while src/filesystem/sandboxed_fs.py doesn't mention this distinction. For consistency, both should clarify the storage location is Python server memory, not browser storage.

---
#### code_vs_comment

**Description:** Comment claims PC is not saved/restored, but this contradicts the documented behavior for control flow statements

**Affected files:**
- `src/immediate_executor.py`

**Details:**
Comment at line ~200 states: 'Note: We do not save/restore the PC before/after execution. This allows statements like RUN to change execution position. Control flow statements (GOTO, GOSUB) can also modify PC but may produce unexpected results (see help text).'

However, the help text in _show_help() states: 'GOTO, GOSUB, and control flow statements are not recommended (they will execute but may produce unexpected results)'

The comment suggests this is intentional design to allow RUN to work, but doesn't explain why control flow produces 'unexpected results' or what those results are. The implementation executes statements at line 0, so GOTO/GOSUB would try to jump to other line numbers, which may not exist in the immediate context.

---
#### code_vs_comment

**Description:** Comment about numbered line editing says 'add_line expects complete line text with line number' but then constructs it

**Affected files:**
- `src/immediate_executor.py`

**Details:**
Comment at line ~124 states:
'# Add/update line - add_line expects complete line text with line number'

Then the code constructs:
complete_line = f"{line_num} {line_content}"
success, error = ui.program.add_line(line_num, complete_line)

This is redundant - if add_line expects the complete line WITH the line number, why pass line_num as a separate parameter? Either:
1. add_line(line_num, line_content) - line_num separate, content without number
2. add_line(complete_line) - complete line including number

The current signature add_line(line_num, complete_line) where complete_line includes the number is unusual and the comment doesn't explain why both are needed.

---
#### code_vs_comment

**Description:** Comment in cmd_merge says 'Error message from merge_from_file - format may vary' but then formats it with '?' prefix, suggesting a specific format is expected

**Affected files:**
- `src/interactive.py`

**Details:**
Lines 476-478:
# Error message from merge_from_file - format may vary
print(f"?{error}")

If the format 'may vary', why is the code adding a '?' prefix? This suggests the code expects a specific format (error message without '?' prefix) but the comment says format varies. Either the comment should say 'format is plain text without prefix' or the code shouldn't assume it can add '?'.

---
#### documentation_inconsistency

**Description:** Docstring for cmd_chain describes 'delete_range' parameter but the actual DELETE option syntax and behavior is not fully documented

**Affected files:**
- `src/interactive.py`

**Details:**
Line 493 docstring:
delete_range: Delete line range after merge (DELETE option)

Lines 545-560 show the implementation:
if delete_range and merge:
    # delete_range is a tuple of (start_expr, end_expr)
    # We need to evaluate them if they're expressions
    start_expr, end_expr = delete_range
    # For now, assume they're NumberNodes - full implementation would evaluate

The docstring doesn't explain that delete_range is a tuple of expressions, or that the implementation currently only handles NumberNodes. The comment 'full implementation would evaluate' suggests incomplete implementation not mentioned in docstring.

---
#### code_vs_comment

**Description:** Comment in cmd_delete says 'Returns list of deleted line numbers (not used by this command)' but doesn't explain why the return value exists if it's not used

**Affected files:**
- `src/interactive.py`

**Details:**
Lines 389-391:
Delegates to ui_helpers.delete_lines_from_program() which handles:
...
- Returns list of deleted line numbers (not used by this command)

If the return value is not used, why does the function return it? This suggests either: (1) the return value is used elsewhere and the comment is incomplete, (2) the function should be refactored to not return unused data, or (3) the return value is for future use and should be documented as such.

---
#### code_vs_comment_conflict

**Description:** Comment claims GOTO/GOSUB in immediate mode 'may be unexpected' and 'not recommended', but the code fully implements and supports this functionality with specific semantics

**Affected files:**
- `src/interactive.py`

**Details:**
Comment at line ~125 states:
'This is the intended behavior but may be unexpected, hence "not recommended".'

However, the code deliberately implements GOTO/GOSUB support:
1. Executes the jump during execute_statement()
2. Restores PC afterward to preserve CONT
3. This is described as 'intended behavior'

The comment suggests this is problematic ('not recommended'), but the implementation treats it as a designed feature with specific semantics.

---
#### code_vs_comment_conflict

**Description:** Comment describes GOTO/GOSUB behavior as if it's a side effect, but code deliberately implements this as a feature

**Affected files:**
- `src/interactive.py`

**Details:**
Comment at lines ~119-124:
'# Note: GOTO/GOSUB in immediate mode work but have special semantics:
# They execute and jump during execute_statement(), but we restore the
# original PC afterward to preserve CONT functionality. This means:
# - The jump happens and target code runs during execute_statement()
# - The final PC change is then reverted, preserving the stopped position
# - CONT will resume at the original stopped location, not the GOTO target'

The phrasing 'work but have special semantics' and the detailed explanation suggest this might be unintended behavior or a workaround. However, the code deliberately saves old_pc, executes, and restores it - this is intentional design, not a quirk. The comment tone doesn't match the deliberate implementation.

---
#### code_vs_comment

**Description:** Comment describes skip_next_breakpoint_check behavior incorrectly - says it's set AFTER returning state, but code sets it BEFORE returning

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line 62-65 says:
"Set to True AFTER halting at a breakpoint (set after returning state).
On next execution, if still True, allows stepping past the breakpoint once,
then clears itself to False. Prevents re-halting on same breakpoint."

But code at lines 449-452 shows:
if at_breakpoint:
    if not self.state.skip_next_breakpoint_check:
        self.runtime.halted = True
        self.state.skip_next_breakpoint_check = True
        return self.state

The flag is set to True BEFORE returning state (line 451), not after.

---
#### code_vs_comment

**Description:** Comment at line 1046 says 'return_stmt is 0-indexed offset' but then describes len(statements) as valid, which would be out of bounds for 0-indexed array

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at lines 1046-1054 says:
"return_stmt is 0-indexed offset into statements array.
Valid range: 0 to len(statements) (inclusive).
- 0 to len(statements)-1: Normal statement positions
- len(statements): Special sentinel - GOSUB was last statement on line, so RETURN
  continues at next line. This value is valid because PC can point one past the
  last statement to indicate 'move to next line' (handled by statement_table.next_pc).
Values > len(statements) indicate the statement was deleted (validation error)."

This is internally consistent but confusing terminology. If it's '0-indexed offset', then len(statements) is not a valid index (it's one past the end). The comment should say 'position' or 'offset that can be one past the end' rather than '0-indexed offset' which implies array indexing semantics.

---
#### code_vs_comment

**Description:** Comment describes RESUME 0 as distinct from RESUME, but code treats them identically

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line ~1090 states:
"# RESUME or RESUME 0 - retry the statement that caused the error
# Note: MBASIC allows both 'RESUME' and 'RESUME 0' as equivalent syntactic forms.
# Parser preserves the distinction (None vs 0) for source text regeneration,
# but runtime execution treats both identically."

Code at line ~1093:
if stmt.line_number is None or stmt.line_number == 0:
    # RESUME or RESUME 0 - retry the statement that caused the error

The comment correctly describes the behavior, but the phrasing "RESUME 0" in the first line could be misleading since it suggests 0 is special when actually both None and 0 are treated the same.

---
#### code_vs_comment

**Description:** Comment about NEXT validation contradicts actual validation logic

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line ~1005 states:
"# return_stmt is 0-indexed offset into statements array.
# Valid range:
#   - 0 to len(statements)-1: Normal statement positions (existing statements)
#   - len(statements): Special sentinel value - FOR was last statement on line,
#                      continue execution at next line (no more statements to execute on current line)
#   - > len(statements): Invalid - indicates the statement was deleted
#
# Validation: Check for strictly greater than (== len is OK as sentinel)"

Code at line ~1013:
if return_stmt > len(line_statements):
    raise RuntimeError(f"NEXT error: FOR statement in line {return_line} no longer exists")

The comment correctly describes the validation, but the description of "len(statements)" as a "special sentinel value" is misleading. It's not a sentinel - it's just the natural result of incrementing past the last statement index. The comment makes it sound like len(statements) is intentionally stored as a special marker.

---
#### code_vs_comment

**Description:** Comment about RUN halting behavior is confusing and potentially incorrect

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line ~1550 states:
"# In non-interactive context, restart from beginning
# Note: RUN without args sets halted=True to stop current execution.
# The caller (e.g., UI tick loop) should detect halted=True and restart
# execution from the beginning if desired. This is different from
# RUN line_number which sets halted=False to continue execution inline."

Code at line ~1555:
self.runtime.clear_variables()
self.runtime.halted = True

The comment suggests halted=True is intentional to signal the caller to restart, but this is inconsistent with RUN line_number behavior which sets halted=False. The comment implies a design pattern where halted=True means "restart needed" but this is not a standard pattern elsewhere in the codebase.

---
#### code_vs_comment

**Description:** INPUT statement comment describes state machine but doesn't mention file input bypass

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line ~1360 states:
"State machine for keyboard input (file input is synchronous):
1. If state.input_buffer has data: Use buffered input (from provide_input())
2. Otherwise: Set state.input_prompt, input_variables, input_file_number and return (pauses execution)
3. UI calls provide_input() with user's input line
4. On next tick(), buffered input is used (step 1) and input_prompt/input_variables are cleared

File input bypasses the state machine and reads synchronously."

The comment correctly describes the behavior, but the phrase "File input bypasses the state machine" at the end is somewhat redundant with "(file input is synchronous)" at the beginning. More importantly, the comment doesn't explain WHY file input is synchronous (files don't need user interaction) which would be helpful context.

---
#### code_vs_comment_conflict

**Description:** Comment in execute_stop() claims 'BreakException handler does not update PC', but this contradicts the documented behavior that both STOP and Break should allow CONT to resume

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment states: 'Note: execute_stop() moves NPC to PC for resume, while BreakException handler does not update PC, which affects whether CONT can resume properly.'

This suggests inconsistent behavior between STOP and Break (Ctrl+C) for CONT resumption, but the comment also says 'Both STOP and Break (Ctrl+C) set runtime.stopped=True and runtime.halted=True. The stopped flag allows CONT to resume from the saved position.' These statements appear contradictory.

---
#### code_vs_comment_conflict

**Description:** execute_midassignment() docstring states 'start_idx == len(current_value) is considered out of bounds', but this contradicts typical BASIC behavior where you can append at the end

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment: 'Note: start_idx == len(current_value) is considered out of bounds (can't start replacement past end)'

Code: 'if start_idx < 0 or start_idx >= len(current_value): return'

This means MID$(A$, LEN(A$)+1, 1) = "X" would be rejected, but in some BASIC implementations this would append. The comment claims this is 'MBASIC 5.21 behavior' but this needs verification.

---
#### Code vs Documentation inconsistency

**Description:** Console input_char() Windows fallback uses input() which waits for Enter, contradicting the method's purpose of single-character input

**Affected files:**
- `src/iohandler/console.py`

**Details:**
Method docstring says: "Input single character from console."

But Windows fallback code has:
"# WARNING: This fallback calls input() which:
# - Waits for Enter key (defeats the purpose of single-char input)
# - Returns the entire line, not just one character"

This means on Windows without msvcrt, input_char() doesn't actually do single-character input at all. This is documented in comments but creates a severe API contract violation.

---
#### Code vs Comment conflict

**Description:** Comment claims identifiers use original_case field but code also uses original_case_keyword for keywords

**Affected files:**
- `src/lexer.py`

**Details:**
Comment at line ~360 states:
"# Preserve original case for display. Identifiers use the original_case field
# to store the exact case as typed. Keywords use original_case_keyword to store
# the case determined by the keyword case policy (see Token class in tokens.py)."

However, the code at lines ~330-335 shows:
token.original_case_keyword = display_case  # Use policy-determined case

And at lines ~350-355:
token.original_case_keyword = display_case

The comment correctly describes the behavior, but it's placed in the identifier section when it actually describes both keyword and identifier behavior across multiple code sections.

---
#### code_vs_comment

**Description:** Comment claims RND and INKEY$ are the only functions that can be called without parentheses in MBASIC 5.21, but this is contradicted by the code implementation

**Affected files:**
- `src/parser.py`

**Details:**
Comment at line 11-12 states:
"Exception: Only RND and INKEY$ can be called without parentheses in MBASIC 5.21
  (this is specific to these two functions, not a general MBASIC feature)"

However, the code at lines 1044-1055 shows RND can be called without parentheses:
"# RND can be called without parentheses - MBASIC 5.21 compatibility feature"

And at lines 1057-1063 shows INKEY$ can be called without parentheses:
"# INKEY$ can be called without parentheses - MBASIC 5.21 compatibility feature"

But the comment says this is 'specific to these two functions', while the implementation suggests it's a general MBASIC feature being emulated. The phrasing is contradictory.

---
#### code_vs_comment

**Description:** Comment about semicolon handling contradicts MBASIC behavior description

**Affected files:**
- `src/parser.py`

**Details:**
At line 387, the comment states:
"# Allow trailing semicolon at end of line only (treat as no-op).
# Context matters: Semicolons WITHIN PRINT/LPRINT are item separators (parsed there),
# but semicolons BETWEEN statements are NOT valid in MBASIC.
# MBASIC uses COLON (:) to separate statements, not semicolon (;)."

However, the code then advances past the semicolon and checks if there's more content:
"self.advance()
# If there's more after the semicolon (except another colon or newline), it's an error
if not self.at_end_of_line() and not self.match(TokenType.COLON):
    token = self.current()
    raise ParseError(f"Expected : or newline after ;, got {token.type.name}", token)"

This suggests semicolons ARE being handled as potential statement separators (with validation), which contradicts the comment saying they are 'NOT valid in MBASIC' between statements. The implementation is more nuanced than the comment suggests.

---
#### code_vs_comment

**Description:** Comment about comma after file number being optional contradicts typical MBASIC syntax

**Affected files:**
- `src/parser.py`

**Details:**
At line 1186 in parse_print(), the comment states:
"# Optionally consume comma after file number
# Note: MBASIC 5.21 typically uses comma (PRINT #1, "text").
# Our parser makes the comma optional for flexibility.
# If semicolon appears instead of comma, it will be treated as an item
# separator in the expression list below (not as a file number separator)."

This suggests the parser is intentionally deviating from MBASIC 5.21 behavior for 'flexibility'. However, the docstring at the top of the file (line 3) states this is a 'Parser for MBASIC 5.21', implying strict compatibility. Making the comma optional could cause parsing ambiguities and is inconsistent with the stated goal of MBASIC 5.21 compatibility.

---
#### code_vs_comment

**Description:** Comment describes INPUT; syntax incorrectly - claims it suppresses '?' prompt, but the actual behavior is more nuanced

**Affected files:**
- `src/parser.py`

**Details:**
Comment at line ~1070 states:
"Note: The semicolon immediately after INPUT keyword (INPUT;) suppresses
the default '?' prompt."

However, later comment at lines ~1088-1093 provides more detailed explanation:
"# Note: In MBASIC 5.21, the separator after prompt affects '?' display:
# - INPUT "Name"; X  displays "Name? " (semicolon AFTER prompt shows '?')
# - INPUT "Name", X  displays "Name " (comma AFTER prompt suppresses '?')
# Different behavior: INPUT; (semicolon IMMEDIATELY after INPUT keyword, no prompt)
# suppresses the default '?' prompt entirely (tracked by suppress_question flag above)."

The first comment is incomplete and potentially misleading - it doesn't clarify that INPUT; only suppresses the '?' when there's NO prompt string, versus the semicolon AFTER a prompt string which actually SHOWS the '?'.

---
#### code_vs_comment

**Description:** Comment about DIM dimension expressions contradicts typical BASIC behavior claim

**Affected files:**
- `src/parser.py`

**Details:**
Comment at lines ~1768-1771 states:
"Dimension expressions: This implementation matches MBASIC 5.21 behavior by accepting
any expression for array dimensions (e.g., DIM A(X*2, Y+1)). Dimensions are evaluated
at runtime. Note: Some compiled BASICs (GW-BASIC, QuickBASIC) require constants only."

This comment claims the implementation 'matches MBASIC 5.21 behavior' but then notes that 'some compiled BASICs' require constants. However, GW-BASIC is mentioned as requiring constants, but GW-BASIC is actually an interpreter, not a compiler. This is factually incorrect and could mislead developers about BASIC dialect differences.

---
#### code_vs_comment

**Description:** Comment about DEFTYPE behavior claims it 'always updates def_type_map during parsing, regardless of mode' but doesn't explain what 'mode' means

**Affected files:**
- `src/parser.py`

**Details:**
Comment at lines ~1876-1881 states:
"Note: This method always updates def_type_map during parsing, regardless of mode.
The type map is shared between parsing passes in batch mode and affects variable
type inference throughout the program. The AST node is created for program
serialization/documentation."

The comment mentions 'regardless of mode' and 'batch mode' but these terms are not defined in the visible code context. This suggests there may be different parsing modes (interactive vs batch?) but the comment doesn't clarify what these modes are or how they differ.

---
#### code_vs_comment

**Description:** Comment claims CALL statement primarily uses numeric address form in MBASIC 5.21, but code fully implements extended syntax with arguments

**Affected files:**
- `src/parser.py`

**Details:**
Comment in parse_call() states:
"Note: MBASIC 5.21 primarily uses the simple numeric address form, but this
parser fully supports both forms for broader compatibility."

However, the implementation fully parses both forms:
- Simple numeric address: CALL 16384
- Extended with arguments: CALL ROUTINE(X,Y)

The code handles both equally, converting FunctionCallNode and VariableNode with subscripts into CallStatementNode with arguments. The comment suggests the extended form is for compatibility, but the code treats both as first-class features.

---
#### code_vs_comment

**Description:** PC class docstring describes stmt_offset as '0-based index' but also calls it 'offset' which is confusing terminology

**Affected files:**
- `src/pc.py`

**Details:**
Docstring says: 'The stmt_offset is a 0-based index into the statements list for a line...Note: stmt_offset is the list index (position in the statements array). The term "offset" is used for historical reasons but it\'s simply the array index.'

This acknowledges the terminology is misleading but doesn't fix it. Throughout the codebase it's consistently used as an index (0, 1, 2...) not an offset in the traditional sense.

---
#### code_vs_comment

**Description:** serialize_let_statement docstring describes both explicit LET and implicit assignment, but the implementation doesn't emit 'LET' keyword

**Affected files:**
- `src/position_serializer.py`

**Details:**
Docstring says: 'LetStatementNode represents both:
- Explicit LET statements: LET A=5
- Implicit assignments: A=5 (without LET keyword)'

But the implementation only serializes: variable = expression
It never emits the 'LET' keyword, even for explicit LET statements. There's no check for whether the original statement had 'LET' or not, and no code path that would emit it.

---
#### code_vs_documentation

**Description:** PC.from_line docstring says it creates PC for 'GOTO target' but it's a general factory method

**Affected files:**
- `src/pc.py`

**Details:**
Docstring: 'Create PC for GOTO target - start of line (offset 0).'

This suggests the method is specifically for GOTO statements, but it's a general factory method that creates a PC pointing to the first statement of any line. It could be used for any purpose, not just GOTO targets. The docstring is misleadingly specific.

---
#### code_vs_comment_conflict

**Description:** Comment about MBASIC 5.21 array sizing convention may not match actual implementation behavior

**Affected files:**
- `src/resource_limits.py`

**Details:**
In check_array_allocation() method, line ~165:

Comment says: "# Note: DIM A(N) creates N+1 elements (0 to N) in MBASIC 5.21
# This implements the MBASIC array sizing convention (called by execute_dim() in interpreter.py)"

Code implements: "total_elements *= (dim_size + 1)  # +1 for 0-based indexing (0 to N)"

The comment claims this implements MBASIC 5.21 convention and references execute_dim() in interpreter.py, but we cannot verify:
1. Whether execute_dim() actually exists in interpreter.py
2. Whether the +1 convention is correctly applied at the right layer
3. Whether this matches actual MBASIC 5.21 behavior

This could be correct, but needs verification against the actual interpreter.py implementation.

---
#### code_vs_comment

**Description:** Comment claims 'original_case' stores the original case, but code actually stores the canonical/resolved case

**Affected files:**
- `src/runtime.py`

**Details:**
Line 48-51 comment: "'original_case' stores the canonical case for display (determined by case_conflict policy).
Despite the name 'original_case', this field stores the resolved canonical case variant,
not necessarily the first case seen."

Line 265: "self._variables[full_name]['original_case'] = canonical_case  # Store canonical case for display (see _check_case_conflict)"

Line 283: "# Always update original_case to canonical (for prefer_upper/prefer_lower/prefer_mixed policies)
# Note: 'original_case' field name is misleading - it stores the canonical case, not the original"

Line 368: "self._variables[full_name]['original_case'] = canonical_case  # Store canonical case for display (see _check_case_conflict)"

Line 373: "# Always update original_case to canonical (for prefer_upper/prefer_lower/prefer_mixed policies)
# Note: 'original_case' field name is misleading - it stores the canonical case, not the original"

The field name 'original_case' is misleading throughout the codebase. It should be renamed to 'canonical_case' or 'display_case' to match its actual purpose.

---
#### Code vs Documentation inconsistency

**Description:** get_variables() docstring claims to return array tracking info but implementation may return None for uninitialized fields

**Affected files:**
- `src/runtime.py`

**Details:**
Docstring states arrays include:
"'last_read': {'line': int, 'position': int, 'timestamp': float} or None"
"'last_write': {'line': int, 'position': int, 'timestamp': float} or None"

Code uses:
"'last_read': array_data.get('last_read')"
"'last_write': array_data.get('last_write')"

If these keys don't exist in array_data, .get() returns None (correct). However, the docstring doesn't document the additional fields 'last_read_subscripts', 'last_write_subscripts', 'last_accessed_value', and 'last_accessed_subscripts' that are also added to the result for arrays. These fields are implemented but not documented in the Returns section.

---
#### code_vs_comment

**Description:** SettingsManager class has unused _get_global_settings_path and _get_project_settings_path methods

**Affected files:**
- `src/settings.py`

**Details:**
The SettingsManager class defines:
- _get_global_settings_path()
- _get_project_settings_path()

But these methods are never called in the class. The __init__ method comment says:
"# Paths (for backward compatibility, may not be used with Redis backend)
self.global_settings_path = getattr(backend, 'global_settings_path', None)
self.project_settings_path = getattr(backend, 'project_settings_path', None)"

The paths are retrieved from the backend, not from these methods. These methods appear to be dead code left over from refactoring.

---
#### code_vs_comment

**Description:** Token dataclass comment claims fields are mutually exclusive but implementation doesn't enforce it

**Affected files:**
- `src/tokens.py`

**Details:**
Token dataclass docstring states:
"Note: These fields serve different purposes and should be mutually exclusive
(identifiers use original_case, keywords use original_case_keyword):
- original_case: For identifiers (user variables) - preserves what user typed
- original_case_keyword: For keywords - stores policy-determined display case

The dataclass doesn't enforce exclusivity (both can be set) for implementation flexibility,
but the lexer/parser maintain this convention: only one field is populated per token."

This is a design decision documented in comments, but the comment acknowledges the code doesn't enforce what it describes. The comment says 'should be mutually exclusive' but then says 'both can be set'. This is internally contradictory documentation.

---
#### code_vs_comment

**Description:** get() method docstring describes precedence including file settings but implementation shows file_settings is always empty in normal usage

**Affected files:**
- `src/settings.py`

**Details:**
get() method docstring:
"Precedence: file > project > global > definition default > provided default

Note: File-level settings infrastructure is fully implemented and functional.
The file_settings dict can be set programmatically and is checked first in precedence.
However, no UI or command exists to manage per-file settings. In normal usage,
file_settings is empty and precedence falls through to project/global settings."

The docstring correctly describes the precedence order and notes file_settings is empty in normal usage. However, it's misleading to list 'file' first in the precedence when it's never populated. The precedence in practice is: project > global > definition default > provided default.

---
#### Code vs Comment conflict

**Description:** Footer text comment claims to use constants but hardcodes arrow symbols

**Affected files:**
- `src/ui/curses_settings_widget.py`

**Details:**
Comment states:
'# Note: All shortcuts use constants from keybindings module to ensure
# footer display matches actual key handling in keypress() method'

But the footer_text includes hardcoded arrow symbols:
'footer_text = urwid.Text(
    f"â†‘â†“ {key_to_display(ENTER_KEY)}=OK  "'

The 'â†‘â†“' arrows are hardcoded, not using constants from keybindings module. This contradicts the comment's claim that ALL shortcuts use constants.

---
#### Code vs Comment conflict

**Description:** Comment about actual value vs display label is inconsistent with implementation

**Affected files:**
- `src/ui/curses_settings_widget.py`

**Details:**
In _on_reset() method, comment states:
'# Note: Compares actual value (stored in _actual_value) not display label
# since display labels have \'force_\' prefix stripped (see _create_setting_widget)'

But in _create_setting_widget(), the code shows:
'display_label = choice.removeprefix(\'force_\')'

This only strips 'force_' prefix, not all display label transformations. The comment implies a broader distinction between actual values and display labels than what's actually implemented.

---
#### Code vs Documentation inconsistency

**Description:** CapturingIOHandler not documented in base.py UIBackend interface

**Affected files:**
- `src/ui/capturing_io_handler.py`

**Details:**
base.py UIBackend.__init__() docstring states:
'Args:
    io_handler: IOHandler instance for I/O operations
    program_manager: ProgramManager instance for program storage'

But capturing_io_handler.py provides CapturingIOHandler which is used by UI backends for output buffering. This specialized IOHandler type is not mentioned in the UIBackend documentation.

---
#### code_vs_comment

**Description:** Comment claims line numbers use 1-5 digits, but code supports variable width up to 99999

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Class docstring says:
"Display format: 'S<linenum> CODE' where:
- Field 2 (variable width): Line number (1-5 digits, no padding)"

But code in _on_auto_number_renumber_response and elsewhere uses 99999 as max:
"if next_num >= 99999 or attempts > 10:"

This is 5 digits max, but the comment '1-5 digits' suggests it could be 1, 2, 3, 4, OR 5 digits, which is correct. However, the implementation actually enforces a hard limit of 99999 (exactly 5 digits max), not a variable 1-5 digit range.

---
#### code_vs_comment

**Description:** Comment about 'use None instead of not' is technically incorrect

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
In _display_syntax_errors:
"# Check if output walker is available (use 'is None' instead of 'not' to avoid false positive on empty walker)
if self._output_walker is None:"

The comment suggests that using 'not self._output_walker' would give a false positive on an empty walker. However, an empty walker (a list-like object with length 0) would correctly evaluate to False with 'not', which is the desired behavior. The 'is None' check is correct for checking if the walker was never set, but the comment's reasoning about 'false positive on empty walker' is misleading - an empty walker should be treated differently than a None walker.

---
#### code_vs_comment

**Description:** Comment claims editor_lines stores execution state while editor.lines stores editing state, but code shows they are synchronized and serve overlapping purposes

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~130 says:
# Note: self.editor_lines stores execution state (lines loaded from file for RUN)
# self.editor.lines (in ProgramEditorWidget) stores the actual editing state
# These serve different purposes and are synchronized as needed

However, _save_editor_to_program() (line ~95) syncs editor.lines -> program, and _refresh_editor() (line ~165) syncs program -> editor.lines. The _sync_program_to_editor() method (referenced at line ~245) would sync program -> editor_lines. This suggests both store similar data and are kept in sync, not serving truly different purposes.

---
#### code_vs_comment

**Description:** Comment describes IO handler lifecycle but implementation shows immediate_io is recreated while comment suggests it's temporary

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at lines ~150-165 says:
# IO Handler Lifecycle:
# 1. self.io_handler (CapturingIOHandler) - Used for RUN program execution
#    Created ONCE here, reused throughout session (NOT recreated in start())
# 2. immediate_io (OutputCapturingIOHandler) - Used for immediate mode commands
#    Created here temporarily, then RECREATED in start() with fresh instance each time

But then at line ~230 in start() method:
immediate_io = OutputCapturingIOHandler()
self.immediate_executor = ImmediateExecutor(self.runtime, self.interpreter, immediate_io)

The comment accurately describes the behavior, but the rationale for recreating immediate_io each time in start() is not explained, while self.io_handler is created once. This asymmetry needs clarification.

---
#### code_vs_comment

**Description:** Comment claims breakpoints are stored in editor as authoritative source and re-applied after reset, but code shows breakpoints are stored in both editor.breakpoints AND interpreter, with potential sync issues

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~1180 says:
"Note: reset_for_run() clears variables and resets PC. Breakpoints are STORED in
the editor (self.editor.breakpoints) as the authoritative source, not in runtime.
This allows them to persist across runs. After reset_for_run(), we re-apply them
to the interpreter below via set_breakpoint() calls so execution can check them."

However, the code shows:
1. _toggle_breakpoint_current_line() modifies self.editor.breakpoints but doesn't sync to interpreter
2. _clear_all_breakpoints() clears self.editor.breakpoints AND calls self.interpreter.clear_breakpoints()
3. _setup_program() re-applies breakpoints from editor to interpreter

This suggests breakpoints exist in TWO places (editor and interpreter) and must be kept in sync, not that editor is the sole authoritative source.

---
#### code_vs_comment

**Description:** Comment about status bar behavior contradicts actual code implementation

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Multiple locations have comments like:
"# Status bar stays at default - error is displayed in output" (lines ~1175, ~1215, ~1235, ~1330)
"# No status bar update - status bar stays at default" (line ~1220)
"# No status bar update - program output will show in output window" (line ~1245)

However, the code shows status bar IS updated in many error cases:
- Line ~1330: self.status_bar.set_text("Internal error - See output")
- Line ~1360: self._update_status_with_errors("Ready")
- Line ~1368: self.status_bar.set_text(f"Paused at line {state.current_line} - ...")

The comments claim status bar stays at default, but code actively sets status bar text in error/completion scenarios.

---
#### code_vs_comment

**Description:** Comment claims ESC sets stopped=True similar to STOP statement, but code actually sets runtime.stopped=True which has different semantics than a BASIC STOP

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~1090:
# Note: This sets stopped=True similar to a BASIC STOP statement, but the semantics
# differ - STOP is a deliberate program action, while ESC is user cancellation

Code sets: self.runtime.stopped = True

The comment acknowledges the semantics differ but claims it's 'similar' when ESC is actually user cancellation, not a program STOP. The comment is somewhat contradictory.

---
#### code_vs_comment

**Description:** Comment says 'No status bar update - program output will show in output window' but there's no clear reason why status bar shouldn't be updated when starting execution from immediate mode

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~1590:
# No status bar update - program output will show in output window
self.running = True
# Start the tick loop
self.loop.set_alarm_in(0.01, lambda loop, user_data: self._execute_tick())

The comment suggests intentionally not updating status bar, but when execution starts from immediate mode (e.g., RUN command), the status bar should probably reflect that the program is running.

---
#### code_vs_comment

**Description:** Comment in _execute_immediate says 'NOTE: Don't call interpreter.start() here' but the reasoning is unclear - it claims immediate executor already called it, but there's no guarantee of that

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~1575:
# NOTE: Don't call interpreter.start() here - the immediate executor already
# called it if needed (e.g., 'RUN 120' called interpreter.start(start_line=120)
# to set PC to line 120). Calling it again would reset PC to the beginning.

This assumes immediate executor called start(), but the code doesn't verify this. If immediate executor didn't call start() for some reason, execution might fail. The comment makes an assumption that may not always hold.

---
#### code_vs_comment_conflict

**Description:** Comment claims help navigation keys are hardcoded and not loaded from keybindings, but HelpMacros does load keybindings from JSON for macro expansion. The comment is misleading about the relationship.

**Affected files:**
- `src/ui/help_widget.py`

**Details:**
Comment at line ~90 states:
"Note: Help navigation keys are hardcoded here and in keypress() method, not loaded from keybindings. The help widget uses fixed keys (U for back, / for search, ESC/Q to exit) to avoid dependency on keybinding configuration. HelpMacros does load the full keybindings from JSON (for {{kbd:action}} macro expansion in help content), but the help widget itself doesn't use those loaded keybindings."

This is accurate but creates confusion because:
1. HelpMacros loads keybindings in help_macros.py line ~30
2. The comment correctly distinguishes between macro expansion vs event handling
3. However, the phrasing "HelpMacros does load the full keybindings" might mislead readers into thinking there's an inconsistency when there isn't one

---
#### documentation_inconsistency

**Description:** help_macros.py docstring says macros use format {{macro_name}} or {{macro_name:context}}, but the implementation and _expand_kbd docstring use 'arg' terminology instead of 'context'.

**Affected files:**
- `src/ui/help_macros.py`

**Details:**
Module docstring line ~6:
"Macros use the format: {{macro_name}} or {{macro_name:context}}"

But _expand_macro method line ~67:
"arg: Optional argument (e.g., 'help' for {{kbd:help}})"

And _expand_kbd method line ~82:
"key_name: Name of key action (e.g., 'help', 'save', 'run')."

The term 'context' vs 'arg' vs 'key_name' is inconsistent across documentation.

---
#### code_vs_comment_conflict

**Description:** Comment at line ~90 says 'MAINTENANCE: If help navigation keys change, update: 1. This footer text (line below) 2. The keypress() method (handle_key mapping around line 150+) 3. Help documentation that mentions these keys'. However, the keypress() method doesn't have a 'handle_key mapping' - it directly handles keys in if/elif blocks. The comment references a non-existent structure.

**Affected files:**
- `src/ui/help_widget.py`

**Details:**
Comment references 'handle_key mapping around line 150+' but the keypress() method starting around line 280 uses direct if/elif conditionals:

if key in ('q', 'Q', 'esc'):
elif key == '/':
elif key == 'enter':
elif key == 'u' or key == 'U':

There is no 'handle_key mapping' data structure.

---
#### code_vs_comment_conflict

**Description:** The _create_text_markup_with_links docstring says 'Links are marked with [text] in the rendered output. This method finds ALL [text] patterns for display/navigation, but uses the renderer's links for target mapping when following links.' However, the regex pattern also matches [text](url) format, not just [text].

**Affected files:**
- `src/ui/help_widget.py`

**Details:**
Docstring line ~220:
"Links are marked with [text] in the rendered output. This method finds ALL [text] patterns for display/navigation"

But the regex at line ~240:
link_pattern = r'\[([^\]]+)\](?:\([^)]+\))?'

This pattern matches both [text] and [text](url) formats. The docstring is incomplete.

---
#### Code vs Comment conflict

**Description:** Comment claims QUIT_KEY has no keyboard shortcut, but QUIT_ALT_KEY (Ctrl+C) is documented as an alternative quit method. The comment says 'No dedicated keyboard shortcut' but then immediately describes Ctrl+C as an alternative.

**Affected files:**
- `src/ui/keybindings.py`

**Details:**
Lines 145-153:
# Quit - No dedicated keyboard shortcut (most Ctrl keys intercepted by terminal or already assigned)
# Primary method: Use menu (Ctrl+U -> File -> Quit)
# Alternative: Ctrl+C (interrupt signal) will also quit - see QUIT_ALT_KEY below
QUIT_KEY = None  # No keyboard shortcut

# Alternative quit via interrupt signal (Ctrl+C)
# Note: This is not a standard keybinding but a signal handler, hence "alternative"
_quit_alt_from_json = _get_key('editor', 'quit')
QUIT_ALT_KEY = _ctrl_key_to_urwid(_quit_alt_from_json) if _quit_alt_from_json else 'ctrl c'

---
#### Code vs Documentation inconsistency

**Description:** In-page search keybindings documented in code comments but missing from tk_keybindings.json

**Affected files:**
- `src/ui/tk_help_browser.py`
- `src/ui/tk_keybindings.json`

**Details:**
tk_help_browser.py lines 109-113 document Return and Escape keys for in-page search:
# Return key in search box navigates to next match (local widget binding)
# Note: This binding is specific to the in-page search entry widget and is not
# documented in tk_keybindings.json, which only documents global application
# keybindings. Local widget bindings are documented in code comments only.
# ESC key closes search bar (local widget binding, not in tk_keybindings.json)

However, tk_keybindings.json only documents Ctrl+F for opening in-page search under help_browser section. The Return (next match) and Escape (close search) bindings are not documented in the JSON file, even though they are user-facing keybindings.

---
#### code_vs_comment

**Description:** Comment states immediate_history and immediate_status are 'always None' but code explicitly sets them to None with defensive programming justification

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Lines 293-297 comment: 'Note: immediate_history and immediate_status are always None in Tk UI (see lines 293-297)'
Lines 293-297 code:
# Set immediate_history and immediate_status to None
# These attributes are not currently used but are set to None for defensive programming
# in case future code tries to access them (will get None instead of AttributeError)
self.immediate_history = None
self.immediate_status = None

The comment at line 293 references itself ('see lines 293-297') which is circular. The comment suggests these are 'always None' but the defensive programming note suggests they might be used in the future, creating ambiguity about their purpose.

---
#### code_vs_comment

**Description:** Variables window heading text shows 'Last Accessed' but comment says it matches 'accessed' column with descending sort

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Code line 1099:
tree.heading('#0', text='â†“ Variable (Last Accessed)')

Comment lines 1098-1099:
'# Set initial heading text with down arrow (matches self.variables_sort_column='accessed', descending)'

Code line 109:
self.variables_sort_column = 'accessed'  # Current sort column (default: 'accessed' for last-accessed timestamp)

The heading text 'Last Accessed' is consistent with the sort column 'accessed', but the comment's phrasing 'matches self.variables_sort_column' is slightly ambiguous about whether it's describing the heading text or the sort behavior.

---
#### code_vs_comment_conflict

**Description:** Comment claims formatting may occur elsewhere, but code explicitly avoids formatting to preserve MBASIC compatibility

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _refresh_editor method around line 1150:
Comment says: "(Note: 'formatting may occur elsewhere' refers to the Variables and Stack windows, which DO format data for display - not the editor/program text itself)"

This parenthetical note appears to be defending against a concern that doesn't exist - the code already preserves text exactly as stored. The comment creates confusion by mentioning formatting that occurs in other windows, which is irrelevant to this method's purpose.

---
#### code_vs_comment

**Description:** Comment claims blank lines are removed after key press, but code only schedules removal without guaranteeing execution

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1050: '# Schedule blank line removal after key is processed'
Code: 'self.root.after(10, self._remove_blank_lines)'
The comment implies blank lines WILL be removed, but after() only schedules it - if user types rapidly or other events occur, the removal may be delayed or skipped. The comment should clarify this is scheduled/asynchronous.

---
#### code_vs_comment

**Description:** Comment about cursor movement and line change detection is incomplete

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1100: '# If no previous line tracked, just update tracking'
The logic here initializes tracking on first call, but the comment doesn't explain WHY this is needed or what happens if last_edited_line_index is None. The subsequent comment at line ~1130 explains 'Don't trigger sort when old_line_num is None' but this connection isn't clear from the first comment.

---
#### code_vs_comment

**Description:** Comment about paste handling describes two cases but implementation has three distinct code paths

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~950: '# Multi-line paste or single-line paste into blank line - use auto-numbering logic
# Both cases use the same logic (split by \n, process each line):
# 1. Multi-line paste: sanitized_text contains \n â†’ multiple lines to process
# 2. Single-line paste into blank line: current_line_text empty â†’ one line to process'
However, the code has THREE paths:
1. Simple inline paste (line ~935-945) - single line, existing content
2. Multi-line paste (line ~950+) - contains newlines
3. Single-line paste into blank line (line ~950+) - no newlines, blank line
The comment claims cases 2 and 3 use 'the same logic' but doesn't mention case 1 at all, making the flow confusing.

---
#### code_vs_comment

**Description:** Comment about smart insert line behavior contradicts actual implementation regarding blank line saving

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1280: 'DON'T save to program yet - the line is blank and would be filtered out by _save_editor_to_program() which skips blank lines.'
But earlier in the same file, _on_enter_key (line ~800) calls _save_editor_to_program() which does filter blank lines. The comment is correct about the behavior, but the implementation is inconsistent - sometimes blank lines are immediately filtered (_on_enter_key), sometimes they're left in editor (_smart_insert_line). This inconsistency isn't explained.

---
#### code_vs_comment

**Description:** Comment claims immediate mode execution doesn't echo commands, but this contradicts typical BASIC behavior documentation

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _execute_immediate() method around line 1090:
Comment states: "Execute without echoing (GUI design choice that deviates from typical BASIC behavior: command is visible in entry field, and 'Ok' prompt is unnecessary in GUI context - only results are shown. Traditional BASIC echoes to output.)"

This comment acknowledges a deviation from documented BASIC behavior but doesn't clarify if this is intentional or if documentation should be updated to reflect GUI-specific behavior.

---
#### documentation_inconsistency

**Description:** Inconsistent documentation about INPUT vs LINE INPUT behavior strategy

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
TkIOHandler class docstring states:
"Input strategy:
- INPUT statement: Uses inline input field when backend available,
  otherwise uses modal dialog (not a preference, but availability-based)
- LINE INPUT statement: Always uses modal dialog for consistent UX"

But the input() method docstring states:
"Prefers inline input field below output pane when backend is available,
but falls back to modal dialog if backend is not available."

While the input_line() method docstring states:
"Unlike input() which prefers inline input field, this ALWAYS uses
a modal dialog regardless of backend availability."

The word 'prefers' vs 'uses when available' creates ambiguity about whether this is a preference or a hard requirement based on availability.

---
#### code_vs_comment

**Description:** Comment claims has_work() is only called in one location, but this is a maintenance assertion that could become outdated

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _execute_immediate() method around line 1125:
"# Use has_work() to check if the interpreter is ready to execute (e.g., after RUN command).
# This is the only location in tk_ui.py that calls has_work()."

This type of comment creates a maintenance burden - if has_work() is called elsewhere in the future, this comment becomes incorrect. Such assertions should be verified by tooling, not comments.

---
#### code_vs_comment

**Description:** Comment about race condition prevention uses redundant checks that may indicate unclear state management

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _update_immediate_status() method around line 1020:
"# Check if safe to execute - use both can_execute_immediate() AND self.running flag
# The 'not self.running' check prevents immediate mode execution when a program is running,
# even if the tick hasn't completed yet. This prevents race conditions where immediate
# mode could execute while the program is still running but between tick cycles.
can_exec_immediate = self.immediate_executor.can_execute_immediate()
can_execute = can_exec_immediate and not self.running"

The comment suggests that can_execute_immediate() alone is insufficient and requires an additional self.running check. This indicates either:
1. can_execute_immediate() is not correctly checking all necessary conditions
2. There's unclear ownership of execution state between components
3. The state management design has race conditions that require defensive checks

---
#### code_vs_comment

**Description:** Comment in set_error() docstring claims it 'automatically handles' showing breakpoint after error is cleared, but this is misleading - the method explicitly checks has_breakpoint flag and updates status, not automatic

**Affected files:**
- `src/ui/tk_widgets.py`

**Details:**
Class docstring says: 'After fixing error, â— becomes visible (automatically handled by set_error() method which checks has_breakpoint flag when clearing errors)'

But set_error() implementation explicitly checks and updates:
if metadata['has_error']:
    metadata['status'] = '?'
elif metadata['has_breakpoint']:
    metadata['status'] = 'â—'
else:
    metadata['status'] = ' '

This is explicit conditional logic, not 'automatic' handling. The comment makes it sound like some implicit mechanism exists.

---
#### code_vs_comment

**Description:** _delete_line() docstring has confusing dual numbering explanation that contradicts the parameter usage

**Affected files:**
- `src/ui/tk_widgets.py`

**Details:**
Docstring says: 'Args:
    line_num: Tkinter text widget line number (1-based sequential index),
             not BASIC line number (e.g., 10, 20, 30).
             Note: This class uses dual numbering - editor line numbers for
             text widget operations, BASIC line numbers for line_metadata lookups.'

But the function only uses line_num for text widget operations (self.text.get(f'{line_num}.0', ...), self.text.delete(f'{line_num}.0', ...)) and never looks up line_metadata. The 'Note' about dual numbering is irrelevant to this specific function and adds confusion.

---
#### code_vs_comment

**Description:** _on_status_click() uses different regex pattern than _parse_line_number() for extracting BASIC line numbers, creating inconsistency

**Affected files:**
- `src/ui/tk_widgets.py`

**Details:**
_parse_line_number() uses: r'^(\d+)(?:\s|$)'

_on_status_click() uses: r'^\s*(\d+)'

The second pattern allows leading whitespace in the capture but doesn't enforce whitespace or end-of-string after the number. This means _on_status_click() would match '10REM' and extract '10', while _parse_line_number() would reject it. This inconsistency could cause the status click handler to show info for lines that don't actually have valid BASIC line numbers according to the parsing logic used elsewhere.

---
#### code_vs_comment

**Description:** Comment in serialize_line() describes fallback behavior that doesn't match actual implementation logic

**Affected files:**
- `src/ui/ui_helpers.py`

**Details:**
Comment states: "Note: If source_text doesn't match pattern (or is unavailable), falls back to relative_indent=1.
When does this occur?
1. Programmatically inserted lines (no source_text attribute)
2. Lines where source_text doesn't start with line_number + spaces (edge case)"

However, the code only sets relative_indent=1 as initial default before checking source_text. If source_text exists but doesn't match the pattern, relative_indent remains 1 (the default), but the comment implies this is a deliberate fallback case. The code doesn't explicitly handle the 'doesn't match pattern' case separately from the 'no source_text' case.

---
#### documentation_inconsistency

**Description:** update_line_references() docstring describes two-pass approach but implementation uses single-pass with two regex patterns

**Affected files:**
- `src/ui/ui_helpers.py`

**Details:**
Docstring states:
"Uses regex-based approach (fast, good for most cases)."
and
"# Two-pass approach using different regex patterns:
# Pattern 1: Match keyword + first line number (GOTO/GOSUB/THEN/ELSE/ON...GOTO/ON...GOSUB)
# Pattern 2: Match comma-separated line numbers (for ON...GOTO/GOSUB lists)"

The implementation applies both patterns sequentially to the same code string (not two passes over different data), which is technically a single-pass with two regex substitutions. The term 'two-pass' is misleading - it's more accurately 'two-stage regex substitution'.

---
#### code_vs_comment

**Description:** serialize_statement() error handling comment describes prevention strategy but implementation may not prevent all corruption

**Affected files:**
- `src/ui/ui_helpers.py`

**Details:**
Comment states:
"# For unhandled statement types, raise an error to prevent silent data corruption
# Prevention strategy: Explicitly fail (with ValueError) rather than silently omitting
# statements during RENUM, which would corrupt the program.
# All statement types must be handled above - if we reach here, serialization failed."

However, the function is used in serialize_line() which is called during RENUM. If a ValueError is raised during RENUM, it could leave the program in a partially renumbered state (some lines renumbered, some not), which is also a form of corruption. The comment claims this prevents corruption, but it may just change the type of corruption from 'missing statements' to 'inconsistent line numbers'.

---
#### Code vs Documentation inconsistency

**Description:** Comment in cmd_run() claims 'Runtime accesses program.line_asts directly, no need for program_ast variable' but this is misleading - the code does pass program.line_asts to Runtime constructor, so there IS a need to access it, just not to store it in a separate variable first.

**Affected files:**
- `src/ui/visual.py`

**Details:**
Comment says: '(Runtime accesses program.line_asts directly, no need for program_ast variable)'
Code shows: 'self.runtime = Runtime(self.program.line_asts, self.program.lines)'
The comment suggests Runtime accesses it directly without passing, but the code explicitly passes it as a constructor argument.

---
#### Code vs Comment conflict

**Description:** The value property getter has a comment 'Sometimes event args are dict - return empty string' suggesting defensive programming, but there's no explanation of why event args would be a dict when the setter and internal handler treat it as a string.

**Affected files:**
- `src/ui/web/codemirror5_editor.py`

**Details:**
Property getter:
        if isinstance(self._value, dict):
            # Sometimes event args are dict - return empty string
            return ''
        return self._value or ''

This suggests a known issue where _value can become a dict, but the setter and change handler both treat it as a string. This inconsistency is not explained.

---
#### code_vs_comment

**Description:** Comment claims input echoing happens naturally via editable textarea, but code shows input field is separate from output textarea

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~70 says:
# Note: Input echoing (displaying what user typed) happens naturally because
# the user types directly into the output textarea, which is made editable
# by _enable_inline_input() in the NiceGUIBackend class.

However, the UI structure shows separate elements:
- self.input_row (line ~1009)
- self.input_label (line ~1010)
- self.input_field (line ~1011)
- self.input_submit_btn (line ~1012)

These are separate UI elements for inline input, not making the output textarea editable.

---
#### code_vs_comment

**Description:** VariablesDialog sort defaults claim to match Tk UI but may differ

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~127:
# Sort state (matches Tk UI defaults: see sort_mode and sort_reverse in src/ui/tk_ui.py)
self.sort_mode = 'accessed'  # Current sort mode
self.sort_reverse = True  # Sort direction

This references tk_ui.py for verification, but without seeing that file, cannot confirm if defaults actually match. The comment suggests they should be identical.

---
#### code_vs_comment

**Description:** Comment about INPUT prompt handling contradicts itself

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
In _execute_tick() around line 1932, there are two identical comments that say: 'Note: We don't append the prompt to output here because the interpreter
# has already printed it via io.output() before setting input_prompt state.
# Verified: INPUT statement calls io.output(prompt) before awaiting user input.'

This comment appears twice in the same method (once at the beginning of input handling, once later), suggesting copy-paste duplication.

---
#### code_vs_comment

**Description:** Comment about interpreter/runtime object reuse is placed in wrong location

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
In _menu_step_stmt() there's a comment: 'Note: Interpreter/runtime objects are reused across runs (not recreated each time).
# The runtime.reset_for_run() call above clears variables but preserves breakpoints.'

This comment appears in the step_stmt method but describes behavior that applies to all execution methods (run, step_line, step_stmt). It should be in a more general location or repeated in all relevant methods.

---
#### code_vs_comment

**Description:** Comment about char_end calculation references wrong variable name

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
In _update_breakpoint_display() comment says: 'Use the same logic as current_statement_char_end for consistency'

But the code is calculating char_end for breakpoint highlighting, not referencing any variable called current_statement_char_end. The comment seems to reference a pattern from elsewhere but doesn't match the local context.

---
#### code_vs_comment

**Description:** Comment claims _sync_program_to_runtime conditionally preserves PC based on exec_timer state, but code logic doesn't match the described behavior for 'preventing accidental starts'

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~1090 says:
"PC handling (conditional preservation):
- If exec_timer is active (execution in progress): Preserves PC and halted state,
  allowing program to resume from current position after rebuild.
- Otherwise (no active execution): Resets PC to halted state, preventing
  unexpected execution when LIST/edit commands modify the program."

However, the code at lines ~1110-1120:
if self.exec_timer and self.exec_timer.active:
    self.runtime.pc = old_pc
    self.runtime.halted = old_halted
else:
    self.runtime.pc = PC.halted_pc()
    self.runtime.halted = True

The comment says resetting to halted state 'prevents unexpected execution when LIST/edit commands run', but setting halted=True doesn't prevent execution - it just marks the state. The actual prevention would need to check this flag elsewhere. The comment then contradicts itself by saying 'This logic is about PRESERVING vs RESETTING state, not about preventing accidental starts' at line ~1112.

---
#### code_vs_comment

**Description:** Comment describes paste detection threshold as arbitrary but provides specific reasoning that may not match actual behavior

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~1225 says:
"Detect paste: large content change (threshold: >5 chars)
This heuristic helps clear auto-number prompts before paste content merges with them.
The 5-char threshold is arbitrary - balances detecting small pastes while avoiding
false positives from rapid typing (e.g., typing 'PRINT' quickly = 5 chars but not a paste)."

The comment claims typing 'PRINT' quickly equals 5 chars but wouldn't trigger paste detection, yet the code checks if content_diff > 5, meaning 6+ chars would trigger it. Typing 'PRINT' (5 chars) wouldn't trigger, but typing 'PRINT ' (6 chars) would. The threshold explanation is slightly misleading.

---
#### code_vs_comment

**Description:** Comment describes _check_auto_number as preventing re-numbering but acknowledges it could still happen under certain conditions

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~1663 says:
"Check if we should auto-number lines without line numbers.

Auto-numbers a line at most once per content state - tracks last snapshot to avoid
re-numbering lines while user is typing. However, if content changes significantly
(e.g., line edited after numbering, then un-numbered again), the line could be
re-numbered by this logic."

The comment claims 'at most once per content state' but then admits the line 'could be re-numbered' under certain conditions. This is contradictory - either it's once per state or it can happen multiple times.

---
#### code_vs_comment

**Description:** Comment in _sync_program_from_editor uses sys.stderr.write but claims to avoid logging infrastructure, yet log_web_error is used elsewhere

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~1943 says:
"Using sys.stderr.write directly (not log_web_error) to avoid dependency on logging
infrastructure during critical serialization path."

However, throughout the rest of the file, log_web_error is used extensively (e.g., lines 1050, 1075, 1145, 1180, etc.). If logging infrastructure is available and used everywhere else, why avoid it specifically during serialization? This suggests either:
1. The comment is outdated and logging is now safe during serialization
2. There's a real issue with logging during serialization that should be documented more clearly
3. The approach is inconsistent

---
#### code_vs_comment

**Description:** Comment claims 'errors are caught and logged, won't crash the UI' but the timer callback save_state_periodic() could still raise exceptions that propagate

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~467: '# Save state periodically (errors are caught and logged, won't crash the UI)'

But the timer is set up as:
ui.timer(5.0, save_state_periodic)

The save_state_periodic function has try/except, but if ui.timer itself or the serialization in serialize_state() raises an exception outside the try block, it could still crash. The comment overstates the error handling robustness.

---
#### code_vs_documentation

**Description:** Help launcher code contradicts documentation about help system architecture

**Affected files:**
- `src/ui/web_help_launcher.py`
- `docs/help/README.md`

**Details:**
src/ui/web_help_launcher.py contains a deprecated class 'WebHelpLauncher_DEPRECATED' with comment:
'Legacy class kept for compatibility - new code should use direct web URL instead
The help site is already built and served at http://localhost/mbasic_docs

Migration guide for code using this class:
OLD: launcher = WebHelpLauncher(); launcher.open_help("statements/print")
NEW: Open http://localhost/mbasic_docs/statements/print.html directly in browser
NEW: In NiceGUI backend, use: ui.navigate.to('/mbasic_docs/statements/print.html', new_tab=True)'

This suggests the help system has been migrated to a pre-built static site, but docs/help/README.md still describes the old architecture with markdown files in docs/help/ directories that UIs should 'Load common help content' and 'Add UI-specific help sections'.

---
#### documentation_inconsistency

**Description:** Compiler documentation exists but no compiler implementation shown in codebase

**Affected files:**
- `docs/help/common/compiler/index.md`
- `docs/help/common/compiler/optimizations.md`

**Details:**
docs/help/common/compiler/index.md and optimizations.md provide extensive documentation about 'Compiled BASIC-80' with 27 optimization techniques.

However, none of the provided source code files show any compiler implementation:
- No compiler modules
- No code generation
- No optimization passes
- Only interpreter-related code (session_state.py, settings, UI)

The documentation states 'Status: In Progress' for code generation, but the extensive optimization documentation suggests this is either:
1. Planned future work documented prematurely
2. Implemented in code files not provided
3. Outdated documentation from a removed feature

---
#### documentation_inconsistency

**Description:** ATN precision documentation inconsistency - loops.md example shows computing PI without mentioning precision limitation

**Affected files:**
- `docs/help/common/examples/loops.md`
- `docs/help/common/language/functions/atn.md`

**Details:**
In loops.md, the 'Multiplication Table' example uses basic arithmetic without any precision considerations. However, atn.md explicitly states: 'When computing PI with ATN(1) * 4, the result is limited to single precision (~7 digits). For higher precision, use ATN(CDBL(1)) * 4 to get double precision.' This precision limitation is not mentioned in any examples that might use PI or trigonometric functions in loops.md.

---
#### documentation_inconsistency

**Description:** LOC and LOF function descriptions are swapped/contradictory between files

**Affected files:**
- `docs/help/common/language/functions/index.md`
- `docs/help/common/language/functions/loc.md`
- `docs/help/common/language/functions/lof.md`

**Details:**
In loc.md: 'LOC returns the next record number to be used' and 'With sequential files, LOC returns the number of sectors (128 byte blocks)'

In lof.md: 'Returns the total file SIZE in bytes (LOC returns current POSITION/record number)'

In loc.md See Also: 'LOF - Returns the total file SIZE in bytes (LOC returns current POSITION/record number)'

The descriptions are inconsistent - loc.md says LOC returns 'next record number' while lof.md's See Also says LOC returns 'current POSITION/record number'. Also, loc.md doesn't mention that LOF returns size in bytes in its own description.

---
#### documentation_inconsistency

**Description:** CLEAR documentation has conflicting information about parameter meanings between MBASIC 5.21 and earlier versions

**Affected files:**
- `docs/help/common/language/statements/clear.md`

**Details:**
The CLEAR documentation states:

'In MBASIC 5.21 (BASIC-80 release 5.0 and later):
- expression1: If specified, sets the highest memory location available for BASIC to use
- expression2: Sets the stack space reserved for BASIC'

But then notes:
'Historical note: In earlier versions of BASIC-80 (before release 5.0), the parameters had different meanings:
- expression1 set the amount of string space
- expression2 set the end of memory'

This is confusing because the documentation should be consistent for MBASIC 5.21 specifically. The historical note creates ambiguity about which version's behavior is being documented.

---
#### documentation_inconsistency

**Description:** DEF FN documentation claims multi-character function names are an extension over MBASIC 5.21, but DEF USR documentation doesn't mention this is also preserved from original MBASIC 5.21

**Affected files:**
- `docs/help/common/language/statements/def-fn.md`
- `docs/help/common/language/statements/def-usr.md`

**Details:**
DEF FN states:
**Original MBASIC 5.21**: Function names were limited to a single character after FN
**This implementation (extension)**: Function names can be multiple characters

However, DEF USR documentation footer states:
**Historical Reference**: The documentation above is preserved from the original MBASIC 5.21 manual for historical reference.

This suggests DEF USR documentation IS from original MBASIC 5.21, but DEF FN claims multi-char names are an extension. Need to verify if multi-char function names were actually in original MBASIC 5.21 or are truly an extension.

---
#### documentation_inconsistency

**Description:** FOR-NEXT loop termination explanation is confusing and potentially contradictory

**Affected files:**
- `docs/help/common/language/statements/for-next.md`

**Details:**
The documentation states:
'Loop terminates when the variable passes the ending value'
Then gives examples:
'FOR I = 1 TO 10 terminates when I > 10 (after I reaches 10 and increments to 11)'
'FOR I = 10 TO 1 STEP -1 terminates when I < 1 (after I reaches 1 and decrements to 0)'

This suggests the loop body executes when I=10 in the first case and I=1 in the second case, then increments/decrements BEFORE testing. However, standard BASIC tests AFTER incrementing but BEFORE executing the loop body on subsequent iterations. The wording 'after I reaches 10 and increments to 11' is ambiguous about whether the body executes with I=10 or not.

---
#### documentation_inconsistency

**Description:** DEF FN Example 4 has incorrect explanation of bitwise operation

**Affected files:**
- `docs/help/common/language/statements/def-fn.md`

**Details:**
Example 4 states:
'AND &H5F clears bit 5, converting lowercase to uppercase'

This is incorrect. &H5F is 01011111 in binary. ANDing with this value clears bit 5 (the 0x20 bit), which converts LOWERCASE to UPPERCASE. However, the explanation says it 'clears bit 5' which is correct, but bit 5 (counting from 0) is the 6th bit. The operation actually clears bit 5 (0-indexed), which is the difference between uppercase and lowercase ASCII. The explanation is technically correct but could be clearer about bit numbering.

---
#### documentation_inconsistency

**Description:** FIELD and GET documentation have inconsistent cross-references

**Affected files:**
- `docs/help/common/language/statements/field.md`
- `docs/help/common/language/statements/get.md`

**Details:**
FIELD.md 'See Also' section includes:
[GET](get.md) - Read a random file record

GET.md 'See Also' section includes:
[FIELD](field.md) - Define field variables for random file

However, FIELD.md also references:
[MKI$, MKS$, MKD$](../functions/mki_dollar-mks_dollar-mkd_dollar.md)
[CVI, CVS, CVD](../functions/cvi-cvs-cvd.md)

But GET.md only references:
[CVI, CVS, CVD](../functions/cvi-cvs-cvd.md)

GET.md should also reference the MKI$/MKS$/MKD$ functions for consistency since they're used together with FIELD operations.

---
#### documentation_inconsistency

**Description:** INPUT# documentation title has inconsistent formatting

**Affected files:**
- `docs/help/common/language/statements/input_hash.md`

**Details:**
The title field shows:
title: "INPUT# (File)"

But other file I/O commands don't have the '(File)' suffix in their titles (e.g., PRINT#, LINE INPUT#). This inconsistency in naming convention should be standardized.

---
#### documentation_inconsistency

**Description:** LPRINT references PRINT USING but PRINT documentation doesn't cover USING

**Affected files:**
- `docs/help/common/language/statements/lprint-lprint-using.md`
- `docs/help/common/language/statements/print.md`

**Details:**
lprint-lprint-using.md states:
'LPRINT USING works exactly like PRINT USING except output goes to the line printer.'

And See Also includes:
'- [PRINT USING](print.md) - Formatted output to the screen'

But print.md only documents basic PRINT statement, not PRINT USING. The title in print.md is just 'PRINT' and there's no USING syntax or examples.

---
#### documentation_inconsistency

**Description:** RESET and RESTORE documentation both use 'reset' keyword in descriptions, creating potential confusion between two completely different commands

**Affected files:**
- `docs/help/common/language/statements/reset.md`
- `docs/help/common/language/statements/restore.md`

**Details:**
RESET doc: 'description: Closes all open files' with keywords: ['reset', 'close', 'file', 'disk', 'buffer']
RESTORE doc: 'description: Resets the DATA pointer' with keywords: ['restore', 'data', 'read', 'reset', 'pointer']

Both use 'reset' in keywords but serve completely different purposes (file I/O vs DATA pointer). The RESTORE doc uses 'reset' in description which could confuse users looking for file operations.

---
#### documentation_inconsistency

**Description:** SAVE documentation mentions file extensions but RUN documentation doesn't clarify extension handling

**Affected files:**
- `docs/help/common/language/statements/save.md`
- `docs/help/common/language/statements/run.md`

**Details:**
SAVE doc: '(With CP/M, the default extension .BAS is supplied.)'
RUN doc: 'File extension defaults to .BAS if not specified'

SAVE only mentions CP/M specifically, RUN is more general. Inconsistent about whether this is CP/M-specific or general behavior.

---
#### documentation_inconsistency

**Description:** SWAP documentation doesn't mention arrays, but variables.md shows arrays are supported

**Affected files:**
- `docs/help/common/language/statements/swap.md`
- `docs/help/common/language/variables.md`

**Details:**
SWAP doc: 'Any type variable may be SWAPped (integer, single precision, double precision, string)'
Variables doc shows arrays are a major feature.

SWAP doc doesn't clarify if array elements can be swapped (e.g., SWAP A(1), A(2)). This is a common use case that should be documented.

---
#### documentation_inconsistency

**Description:** Keyboard shortcuts documentation incomplete for CLI interface

**Affected files:**
- `docs/help/common/shortcuts.md`
- `docs/help/common/ui/cli/index.md`

**Details:**
shortcuts.md says: 'For UI-specific details, see: - [Curses UI Shortcuts](ui/curses/editing.md) - Keyboard-focused shortcuts - [Tk UI Shortcuts](ui/tk/index.md) - Keyboard + mouse shortcuts - Web UI - Click-based interface (toolbar buttons and menus)'

But CLI is not mentioned in the UI-specific list, even though cli/index.md has a 'Keyboard Shortcuts' section with Ctrl+C, Ctrl+D, Ctrl+Z, Up/Down.

shortcuts.md should either include CLI or explain why it's excluded.

---
#### documentation_inconsistency

**Description:** RESUME documentation has inconsistent error code table

**Affected files:**
- `docs/help/common/language/statements/resume.md`

**Details:**
The 'Error Codes Reference' table shows:
'| ERR | Error |
|-----|-------|
| 2 | Syntax error |
| 6 | Overflow |
| 11 | Division by zero |
...

But Example 5 uses 'ERR = 8' for 'Line does not exist' and 'ERR = 6' for 'Overflow'. The table doesn't include ERR = 8, creating an incomplete reference.

---
#### documentation_inconsistency

**Description:** Inconsistent sort mode descriptions

**Affected files:**
- `docs/help/ui/curses/variables.md`
- `docs/help/ui/curses/feature-reference.md`

**Details:**
feature-reference.md states: "Variable Sorting (s key in variables window) Cycle through different sort orders: - **Accessed**: Most recently accessed (read or written) - newest first - **Written**: Most recently written to - newest first - **Read**: Most recently read from - newest first - **Name**: Alphabetically by variable name"

variables.md states: "Press `s` to cycle through sort orders: - **Accessed**: Most recently accessed (read or written) - shown first - **Written**: Most recently written to - shown first - **Read**: Most recently read from - shown first - **Name**: Alphabetical by variable name"

The descriptions differ slightly: "newest first" vs "shown first", and "Alphabetically" vs "Alphabetical". While minor, this inconsistency could be confusing.

---
#### documentation_inconsistency

**Description:** Inconsistent description of Command area behavior

**Affected files:**
- `docs/help/ui/web/getting-started.md`
- `docs/help/ui/web/web-interface.md`

**Details:**
getting-started.md states: "Important: The Command area does NOT auto-number. It executes immediately."

web-interface.md states: "No automatic line numbering - commands run immediately"

Both say the same thing but getting-started.md uses 'does NOT' (emphasis) while web-interface.md is more neutral. The emphasis should be consistent, especially since this is an important distinction users need to understand.

---
### ðŸŸ¢ Low Severity

#### code_vs_comment_conflict

**Description:** Comment claims keyword_token fields are not used, but they exist in multiple statement nodes

**Affected files:**
- `src/ast_nodes.py`

**Details:**
PrintStatementNode line 237: 'keyword_token: Optional[Token] = None  # Token for PRINT keyword (legacy, not currently used)'

IfStatementNode lines 295-297:
'keyword_token: Optional[Token] = None  # Token for IF keyword
then_token: Optional[Token] = None     # Token for THEN keyword
else_token: Optional[Token] = None     # Token for ELSE keyword (if present)'

ForStatementNode lines 311-313:
'keyword_token: Optional[Token] = None  # Token for FOR keyword
to_token: Optional[Token] = None       # Token for TO keyword
step_token: Optional[Token] = None     # Token for STEP keyword (if present)'

The PrintStatementNode comment says these fields are 'legacy, not currently used' and explains they were 'intended for case-preserving keyword regeneration but are not currently used by position_serializer'. However, IfStatementNode and ForStatementNode have similar fields without the 'legacy' or 'not used' disclaimer, creating inconsistency about whether these fields are actually used.

---
#### documentation_inconsistency

**Description:** Inconsistent documentation of INPUT statement semicolon behavior

**Affected files:**
- `src/ast_nodes.py`

**Details:**
InputStatementNode docstring lines 260-271:
'Note: The suppress_question field controls "?" display:
- suppress_question=False (default): Adds "?" after prompt
  Examples: INPUT var â†’ "? ", INPUT "Name", var â†’ "Name? "
- suppress_question=True: No "?" added (but custom prompt string still displays if present)
  Examples: INPUT; var â†’ "" (no prompt), INPUT "Name"; var â†’ "Name" (prompt without "?")

Semicolon position determines suppress_question value:
- INPUT "prompt"; var â†’ semicolon after prompt is just separator (suppress_question=False, shows "?")
- INPUT; var â†’ semicolon immediately after INPUT (suppress_question=True, no "?")'

The explanation is confusing: it says 'INPUT "prompt"; var' has 'suppress_question=False' and 'shows "?"', but earlier it says 'INPUT "Name"; var â†’ "Name" (prompt without "?")'. These statements contradict each other about whether INPUT "prompt"; var shows the question mark.

---
#### code_vs_comment_conflict

**Description:** CallStatementNode has unused arguments field with conflicting documentation

**Affected files:**
- `src/ast_nodes.py`

**Details:**
CallStatementNode docstring lines 826-841:
'Implementation Note: The \'arguments\' field is currently unused (always empty list). It exists for potential future support of BASIC dialects that allow CALL with arguments (e.g., CALL ROUTINE(args)). Standard MBASIC 5.21 only accepts a single address expression in the \'target\' field. Code traversing the AST can safely ignore the \'arguments\' field for MBASIC 5.21 programs.'

CallStatementNode definition lines 842-845:
'target: \'ExpressionNode\'  # Memory address expression
arguments: List[\'ExpressionNode\']  # Reserved for future (parser always sets to empty list)'

The field exists but is documented as always empty and unused. This creates maintenance burden and potential confusion. The comment says 'parser always sets to empty list' but doesn't explain why the field exists at all if it's never used.

---
#### code_vs_comment_conflict

**Description:** VariableNode type_suffix documentation is verbose and potentially confusing

**Affected files:**
- `src/ast_nodes.py`

**Details:**
VariableNode docstring lines 1027-1038:
'Type suffix handling:
- type_suffix: The actual suffix character ($, %, !, #) - always set to indicate variable type
- explicit_type_suffix: Boolean indicating the origin of type_suffix:
    * True: suffix appeared in source code (e.g., "X%" in "X% = 5")
    * False: suffix inferred from DEFINT/DEFSNG/DEFDBL/DEFSTR (e.g., "X" with DEFINT A-Z)

Example: In "DEFINT A-Z: X=5", variable X has type_suffix=\'%\' and explicit_type_suffix=False.
The suffix must be tracked for type checking but not regenerated in source code.
Both fields must always be examined together to correctly handle variable typing.'

VariableNode definition lines 1040-1044:
'name: str  # Normalized lowercase name for lookups
type_suffix: Optional[str] = None  # $, %, !, # - The actual suffix (see explicit_type_suffix for origin)
subscripts: Optional[List[\'ExpressionNode\']] = None  # For array access
original_case: Optional[str] = None  # Original case as typed by user (for display)
explicit_type_suffix: bool = False  # True if type_suffix was in original source, False if inferred from DEF'

The docstring says 'type_suffix... always set to indicate variable type' but the field definition has 'Optional[str] = None', meaning it can be None. This is contradictory.

---
#### documentation_inconsistency

**Description:** Inconsistent comment style for statement nodes with keyword tokens

**Affected files:**
- `src/ast_nodes.py`

**Details:**
PrintStatementNode line 237: 'keyword_token: Optional[Token] = None  # Token for PRINT keyword (legacy, not currently used)'

IfStatementNode lines 295-297:
'keyword_token: Optional[Token] = None  # Token for IF keyword
then_token: Optional[Token] = None     # Token for THEN keyword
else_token: Optional[Token] = None     # Token for ELSE keyword (if present)'

ForStatementNode lines 311-313:
'keyword_token: Optional[Token] = None  # Token for FOR keyword
to_token: Optional[Token] = None       # Token for TO keyword
step_token: Optional[Token] = None     # Token for STEP keyword (if present)'

PrintStatementNode includes detailed explanation about legacy status and position_serializer, while IfStatementNode and ForStatementNode have minimal comments. This inconsistency makes it unclear whether the keyword_token fields in IF and FOR statements are also legacy/unused.

---
#### code_vs_comment

**Description:** Comment says identifier_table exists but is not used for identifiers

**Affected files:**
- `src/basic_builtins.py`

**Details:**
Line ~100 in case_string_handler.py: Comment states "An identifier_table infrastructure exists (see get_identifier_table) but is not currently used for identifiers". This suggests dead code or incomplete implementation. The get_identifier_table() method exists but serves no purpose if identifiers always return original_text.

---
#### documentation_inconsistency

**Description:** Module docstring references tokens.py for MBASIC 5.21 specification but tokens.py is not included in provided files

**Affected files:**
- `src/basic_builtins.py`

**Details:**
Line 6: "See tokens.py for complete MBASIC 5.21 specification reference." - tokens.py is not in the provided source files, making this reference unverifiable.

---
#### code_vs_comment

**Description:** Comment about negative zero handling may not match actual behavior

**Affected files:**
- `src/basic_builtins.py`

**Details:**
Line ~237: Comment says "Determine sign - preserve negative sign for values that round to zero" and "This allows us to detect cases like -0.001 which round to 0 but should display as '-0' (not '0').". However, the code checks if rounded == 0 and original_negative, which would make -0.001 display as '-0', but Python's round(-0.001, 0) returns 0.0 (positive zero). The original_negative flag is captured before rounding, so this should work, but the comment could be clearer about the implementation strategy.

---
#### code_vs_comment

**Description:** INPUT() docstring describes BASIC syntax with # but notes it's stripped by parser, creating potential confusion

**Affected files:**
- `src/basic_builtins.py`

**Details:**
Line ~680: Docstring shows "INPUT$(n, #filenum)" but notes "The # prefix in BASIC syntax is stripped by the parser before calling this method." This is correct but could confuse users reading the docstring who might try to pass '#' in their Python code.

---
#### code_vs_comment

**Description:** Comment says identifiers preserve case to match MBASIC 5.21 but doesn't explain why identifier_table exists if unused

**Affected files:**
- `src/case_string_handler.py`

**Details:**
Line ~50: Long comment explains identifiers preserve original case and mentions "An identifier_table infrastructure exists (see get_identifier_table) but is not currently used". This suggests either planned future use or refactoring artifact. The comment should clarify the purpose of the unused infrastructure.

---
#### Documentation inconsistency

**Description:** Module docstring mentions 'Web UI uses FileIO abstraction exclusively' but doesn't clarify the stub status

**Affected files:**
- `src/editing/manager.py`

**Details:**
src/editing/manager.py module docstring states:
"Why ProgramManager has its own file I/O methods:
- Provides simpler API for local UI menu operations (File > Open/Save dialogs)
- Only used by local UIs (CLI, Curses, Tk) where filesystem access is safe
- Separate from BASIC command flow: UI menus call ProgramManager directly,
  BASIC commands (LOAD/SAVE) go through FileIO abstraction first
- Web UI uses FileIO abstraction exclusively (no direct ProgramManager file access)"

However, as documented in src/file_io.py, the Web UI's SandboxedFileIO has most methods as stubs that raise errors. So saying "Web UI uses FileIO abstraction exclusively" is technically true but misleading since most FileIO operations don't work in the Web UI. The documentation should clarify that Web UI support is incomplete.

---
#### Documentation inconsistency

**Description:** Both abstractions provide list_files() and delete() with overlapping purposes but different signatures

**Affected files:**
- `src/file_io.py`
- `src/filesystem/base.py`

**Details:**
src/file_io.py FileIO.list_files() signature:
def list_files(self, filespec: str = "") -> List[Tuple[str, int, bool]]:
    """List files matching filespec pattern.
    Args:
        filespec: File pattern (e.g., "*.BAS", "*.txt")
                 Empty string means "*" (all files)
    Returns:
        List of (filename, size_bytes, is_dir) tuples"""

src/filesystem/base.py FileSystemProvider.list_files() signature:
def list_files(self, pattern: Optional[str] = None) -> list:
    """List files matching pattern.
    Args:
        pattern: Optional glob pattern (e.g., "*.BAS")
    Returns:
        List of filenames"""

The two abstractions have different return types: FileIO returns (filename, size, is_dir) tuples while FileSystemProvider returns just filenames. The documentation acknowledges this overlap but doesn't explain why they have different signatures or when to use which.

---
#### code_vs_documentation

**Description:** Module docstring mentions Python version requirement but doesn't specify minimum version consistently

**Affected files:**
- `src/input_sanitizer.py`

**Details:**
Module docstring states:
'Implementation note: Uses standard Python type hints (e.g., tuple[str, bool]) which require Python 3.9+. For earlier Python versions, use Tuple[str, bool] from typing.'

This is informational but could be clearer about whether the code actually supports Python <3.9 or if it's a hard requirement. The code uses lowercase tuple[str, bool] syntax, which means it REQUIRES Python 3.9+, but the note suggests there's a workaround for earlier versions (which would require code changes).

---
#### documentation_inconsistency

**Description:** State name documentation uses quoted strings but clarifies these are not actual enum values, creating potential confusion

**Affected files:**
- `src/immediate_executor.py`

**Details:**
Class docstring lists state names:
'State names used in documentation (not actual enum values):
- "idle" - No program loaded (halted=True)
- "paused" - User hit Ctrl+Q/stop (halted=True)
...

Note: The actual implementation checks boolean flags (halted, error_info, input_prompt), not string state values.'

While the note clarifies this, using quoted state names in documentation when they don't exist in code could confuse developers. The documentation could be clearer by not using string literals for non-existent states.

---
#### code_vs_comment

**Description:** Comment in cmd_cont says 'PC already contains the resume position' but doesn't explain how/when PC was set, creating incomplete documentation

**Affected files:**
- `src/interactive.py`

**Details:**
Lines 253-256:
State management:
- Clears stopped/halted flags in runtime
- PC already contains the resume position (set by STOP or break handler)
- Resumes tick-based execution loop

The comment references 'STOP or break handler' setting PC but doesn't explain where this happens or link to that code. This makes the comment incomplete for understanding the full flow.

---
#### code_vs_comment

**Description:** Comment says 'bare except' for exception handling but this is generally considered bad practice without explanation of why it's necessary

**Affected files:**
- `src/interactive.py`

**Details:**
Lines 803-809:
try:
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
        return ch if ch else None
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
except:
    # Fallback for non-TTY/piped input or any terminal errors (bare except)

The comment acknowledges 'bare except' but doesn't justify why catching all exceptions (including SystemExit, KeyboardInterrupt) is appropriate here. This could mask serious errors.

---
#### code_vs_comment_conflict

**Description:** Comment says 'no source line text available for error reporting' but this contradicts the purpose of passing empty line_text_map

**Affected files:**
- `src/interactive.py`

**Details:**
Comment at line ~113:
'# Pass empty line_text_map since immediate mode uses temporary line 0
# (no source line text available for error reporting, but this is fine
# for immediate mode where the user just typed the statement)'

The comment claims 'no source line text available' but immediate mode DOES have the source text (the user just typed it in 'statement' variable). The empty line_text_map is passed because line 0 is temporary, not because source text is unavailable. The parenthetical '(but this is fine...)' suggests this might be a limitation when it's actually by design.

---
#### code_vs_comment

**Description:** Comment says 'clears itself to False' but code shows it's cleared by the else branch, not by itself

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line 64-65 says:
"then clears itself to False. Prevents re-halting on same breakpoint."

But code at lines 454-455 shows:
else:
    self.state.skip_next_breakpoint_check = False

The flag doesn't clear 'itself' - it's explicitly cleared by the else branch when the breakpoint is skipped.

---
#### documentation_inconsistency

**Description:** InterpreterState docstring lists execution order but doesn't mention error_info can be set during statement execution (step 6), only in error handling (step 7)

**Affected files:**
- `src/interpreter.py`

**Details:**
Docstring at lines 44-52 lists:
"Internal execution order in tick_pc() (for developers understanding control flow):
1. pause_requested check - pauses if pause() was called
2. halted check - stops if already halted
3. break_requested check - handles Ctrl+C breaks
4. breakpoints check - pauses at breakpoints
5. trace output - displays [line] or [line.stmt] if TRON is active
6. statement execution - where input_prompt may be set
7. error handling - where error_info is set via exception handlers"

But code at lines 476-490 shows error_info is set DURING statement execution (step 6) in the except block, before invoking the error handler. The docstring implies it's only set in step 7 (error handling).

---
#### code_vs_comment

**Description:** Comment says NEXT I, J, K differs from separate statements, but the described behavior is actually the same for loop completion

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at lines 1113-1119 says:
"NEXT I, J, K processes variables left-to-right: I first, then J, then K.
For each variable, _execute_next_single() is called to increment it and check if
the loop should continue. If _execute_next_single() returns True (loop continues),
execution jumps back to the FOR body and remaining variables are not processed.
If it returns False (loop finished), that loop is popped and the next variable is processed.

This differs from separate statements (NEXT I: NEXT J: NEXT K) which would
always execute sequentially, processing all three NEXT statements."

The claim about 'differs from separate statements' is misleading. If NEXT I loops back, control returns to FOR I body, so NEXT J and NEXT K wouldn't execute anyway (they're after NEXT I). The behavior is the same whether combined or separate, except for the case where I's loop completes - then J is processed immediately in combined form, vs requiring another iteration in separate form.

---
#### code_vs_comment

**Description:** Comment about CLEAR preserving COMMON variables is incomplete

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line ~1280 states:
"# State preservation for CHAIN compatibility:
#
# PRESERVED by CLEAR (not cleared):
#   - runtime.common_vars (list of COMMON variable names - the list itself, not values)
#   - runtime.user_functions (DEF FN functions)"

However, the code only explicitly preserves common_vars list. The comment claims user_functions are preserved, but there's no code that explicitly preserves them - they're simply not cleared because execute_clear doesn't call any method that would clear user_functions. This is implicit preservation rather than explicit.

---
#### code_vs_comment

**Description:** Comment about latin-1 encoding for CP/M files is overly detailed but accurate

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment at line ~1410 has extensive documentation about latin-1 encoding:
"Encoding:
Uses latin-1 (ISO-8859-1) to preserve byte values 128-255 unchanged.
CP/M and MBASIC used 8-bit characters; latin-1 maps bytes 0-255 to
Unicode U+0000-U+00FF, allowing round-trip byte preservation.
Note: CP/M systems often used code pages like CP437 or CP850 for characters
128-255, which do NOT match latin-1. Latin-1 preserves the BYTE VALUES but
not necessarily the CHARACTER MEANING for non-ASCII CP/M text."

This is technically accurate but the level of detail about CP/M code pages seems excessive for a comment in the middle of file I/O code. This information might be better suited for external documentation.

---
#### code_vs_comment_conflict

**Description:** Comment in evaluate_binaryop() states 'len() counts characters' and claims character count equals byte count for latin-1, but this is only true for characters in the latin-1 range (0-255)

**Affected files:**
- `src/interpreter.py`

**Details:**
Comment: 'Also note: len() counts characters. For ASCII and latin-1 (both single-byte encodings), character count equals byte count.'

This is technically correct for latin-1 encoded strings, but the comment could be misleading since Python strings are Unicode and len() counts Unicode code points, not bytes. The equivalence only holds after encoding to latin-1 bytes.

---
#### Documentation inconsistency

**Description:** Module docstring states WebIOHandler is not exported due to nicegui dependency, but web_io.py imports nicegui at module level, making it fail on import if nicegui is not installed

**Affected files:**
- `src/iohandler/__init__.py`
- `src/iohandler/web_io.py`

**Details:**
__init__.py says: "WebIOHandler are not exported here because they have dependencies on their respective UI frameworks (tkinter, nicegui). They should be imported directly from their modules when needed"

But web_io.py has: "from nicegui import ui" at the top level, which will fail immediately if nicegui is not installed, even before WebIOHandler can be instantiated.

---
#### Code vs Comment conflict

**Description:** Backward compatibility comment for print() method says it was renamed to avoid conflicts with Python's built-in, but Python's print is a function not a method, so there's no actual conflict

**Affected files:**
- `src/iohandler/web_io.py`

**Details:**
Comment says: "This method was renamed from print() to output() to avoid conflicts with Python's built-in print function."

But self.print() as a method doesn't conflict with the built-in print() function - they have different scopes. The rename was likely for consistency with IOHandler base class, not to avoid conflicts.

---
#### Code vs Comment conflict

**Description:** get_char() backward compatibility comment says it preserves non-blocking behavior, but input_char() signature has blocking parameter that defaults to True

**Affected files:**
- `src/iohandler/web_io.py`

**Details:**
Comment says: "Note: Always calls input_char(blocking=False) for non-blocking behavior. The original get_char() implementation was non-blocking, so this preserves that behavior for backward compatibility."

But input_char() signature is: def input_char(self, blocking=True)

If get_char() was originally non-blocking and input_char() defaults to blocking=True, then calling input_char() without arguments would change behavior, not preserve it.

---
#### Documentation inconsistency

**Description:** input_char() docstring says blocking parameter is ignored, but also says it returns empty string immediately regardless of blocking value - this is redundant/confusing

**Affected files:**
- `src/iohandler/web_io.py`

**Details:**
Docstring says:
"Args:
    blocking: If True, wait for keypress. If False, return "" if no key ready.
             NOTE: This parameter is accepted for interface compatibility but
             is ignored in the web UI implementation.

Returns:
    Single character string, or "" if not available

Note: Character input not supported in web UI. This method always returns
an empty string immediately, regardless of the blocking parameter value.
The blocking parameter is ignored."

The Args section describes what blocking should do, then immediately says it's ignored. This is confusing - should just say "blocking: Ignored in web UI implementation" in Args.

---
#### Documentation inconsistency

**Description:** keyword_case_manager.py references simple_keyword_case.py but that file is not provided in the source code files

**Affected files:**
- `src/keyword_case_manager.py`
- `src/simple_keyword_case.py`

**Details:**
keyword_case_manager.py docstring says:
"Note: This class provides advanced case policies (first_wins, preserve, error) via
CaseKeeperTable and is used by parser.py and position_serializer.py. For simpler
force-based policies in the lexer, see SimpleKeywordCase (src/simple_keyword_case.py)
which only supports force_lower, force_upper, and force_capitalize."

But src/simple_keyword_case.py is not included in the provided source files, so this reference cannot be verified.

---
#### Code vs Comment conflict

**Description:** Comment says non-blocking input is 'simplified' but implementation has full platform-specific logic for Unix and Windows

**Affected files:**
- `src/iohandler/console.py`

**Details:**
Comment says: "Note: Non-blocking input is complex on different platforms.
This implementation provides basic support."

But the code has comprehensive platform-specific implementations:
- Unix: uses select.select() to check stdin
- Windows: uses msvcrt.kbhit() and msvcrt.getch()
- Fallback: warnings and graceful degradation

This is not 'basic support' - it's fairly complete platform-specific handling.

---
#### Code vs Comment conflict

**Description:** Comment about old BASIC preprocessing contradicts actual implementation of PRINT# handling

**Affected files:**
- `src/lexer.py`

**Details:**
Comment at lines ~357-361 states:
"# NOTE: We do NOT handle old BASIC where keywords run together (NEXTI, FORI).
# This is properly-formed MBASIC 5.21 which requires spaces.
# Exception: PRINT# and similar file I/O keywords (handled above) support # without space.
# Other old BASIC syntax should be preprocessed with conversion scripts."

However, the code at lines ~340-355 DOES handle the special case of PRINT# without spaces by splitting the # back out. This is not 'old BASIC' but rather a MBASIC 5.21 feature. The comment conflates two different issues: (1) keywords running together like NEXTI (old BASIC, not supported), and (2) PRINT#1 syntax (MBASIC 5.21 feature, IS supported).

---
#### Documentation inconsistency

**Description:** Docstring for read_identifier() mentions exception for PRINT# and INPUT# but implementation supports more file I/O keywords

**Affected files:**
- `src/lexer.py`

**Details:**
Docstring at lines ~280-287 states:
"Exception: PRINT# and INPUT# where # is part of the keyword."

But the code at line ~345 checks for:
if keyword_part in ['print', 'lprint', 'input', 'write', 'field', 'get', 'put', 'close']:

The implementation supports 8 file I/O keywords (print, lprint, input, write, field, get, put, close) but the docstring only mentions 2 (PRINT# and INPUT#).

---
#### Code vs Comment conflict

**Description:** Comment about type suffix behavior contradicts actual parsing logic

**Affected files:**
- `src/lexer.py`

**Details:**
Comment at line ~305 states:
"# Type suffix - terminates identifier (e.g., A$ reads as A$, not A$B)"

This comment suggests that type suffixes always terminate identifiers. However, the code at lines ~337-355 shows special handling where # can be split off from file I/O keywords (e.g., PRINT# becomes PRINT + #). This creates an inconsistency: for regular identifiers, # terminates (A#), but for file I/O keywords, # is split back out (PRINT# becomes PRINT + #). The comment doesn't acknowledge this dual behavior.

---
#### Documentation inconsistency

**Description:** Module docstring claims Extended BASIC features are always enabled but doesn't explain what this means for lexer behavior

**Affected files:**
- `src/lexer.py`

**Details:**
Module docstring at lines 1-8 states:
"MBASIC 5.21 Extended BASIC features: This implementation always enables Extended BASIC
features (e.g., periods in identifiers like \"RECORD.FIELD\") as they are part of MBASIC 5.21.
There is no option to disable them."

The only place periods are mentioned in the code is at line ~302:
if char.isalnum() or char == '.':

There's no documentation explaining what other Extended BASIC features exist, whether they're all implemented, or what the distinction is between Extended and non-Extended BASIC in MBASIC 5.21 context.

---
#### code_vs_comment

**Description:** Inconsistent terminology for 'end of line' vs 'end of statement' in method documentation

**Affected files:**
- `src/parser.py`

**Details:**
Method at_end_of_line() at line 152 has documentation:
"Check if at end of logical line (NEWLINE or EOF)

Note: This method does NOT check for comment tokens (REM, REMARK, APOSTROPHE)
or statement separators (COLON). Use at_end_of_statement() when parsing statements
that should stop at comments/colons. Use at_end_of_line() for line-level parsing
where colons separate multiple statements on the same line."

But the implementation at line 158 checks:
"return token.type in (TokenType.NEWLINE, TokenType.EOF)"

Meanwhile, at_end_of_statement() at line 161 checks:
"return token.type in (TokenType.NEWLINE, TokenType.EOF, TokenType.COLON,
                      TokenType.REM, TokenType.REMARK, TokenType.APOSTROPHE)"

The documentation is correct, but the naming could be confusing since 'end of line' typically means the physical line end, not just NEWLINE/EOF without considering colons.

---
#### code_vs_comment

**Description:** Comment about MID$ lookahead exception handling is overly broad

**Affected files:**
- `src/parser.py`

**Details:**
At line 619, the comment states:
"# Bare except intentionally catches all exceptions during lookahead
# (IndexError if we run past end, any parsing errors from malformed syntax)
# This is safe because position is restored below and proper error reported later"

The code uses a bare 'except:' clause at line 621. While the comment explains the intent, using a bare except is generally considered bad practice in Python. It would be better to catch specific exceptions (IndexError, ParseError, etc.) rather than all exceptions including KeyboardInterrupt, SystemExit, etc.

---
#### documentation_inconsistency

**Description:** Inconsistent documentation of PRINT statement syntax variations

**Affected files:**
- `src/parser.py`

**Details:**
The parse_print() method at line 1176 documents:
"Syntax:
    PRINT expr1, expr2          - Print to screen
    PRINT #filenum, expr1       - Print to file
    PRINT USING format$; expr1  - Formatted print to screen
    PRINT #filenum, USING format$; expr1 - Formatted print to file"

But the parse_lprint() method at line 1268 documents:
"Syntax:
    LPRINT expr1, expr2         - Print to printer
    LPRINT #filenum, expr1      - Print to file"

LPRINT doesn't document USING support, but PRINT does. It's unclear if LPRINT supports USING or not. The code for parse_lprint() doesn't check for USING keyword, suggesting it's not supported, but this should be explicitly documented.

---
#### code_vs_comment

**Description:** Comment describes LINE modifier behavior but doesn't clarify lexer tokenization detail

**Affected files:**
- `src/parser.py`

**Details:**
Comment at lines ~1098-1100 states:
"# Check for LINE modifier (e.g., INPUT "prompt";LINE var$)
# LINE allows input of entire line including commas
# Note: The lexer tokenizes standalone LINE keyword as LINE_INPUT token."

This comment is potentially confusing because it says 'standalone LINE keyword' is tokenized as LINE_INPUT, but in the context of 'INPUT...LINE var$', the LINE is not standalone. The comment should clarify whether this specific usage (after INPUT statement) uses LINE_INPUT token or a different token type.

---
#### code_vs_comment

**Description:** Comment about MID$ lexer tokenization uses inconsistent terminology

**Affected files:**
- `src/parser.py`

**Details:**
Comment at lines ~1843-1846 states:
"Note: The lexer tokenizes 'MID$' in source as a single MID token (the $ is part
of the keyword, not a separate token)."

Then at line 1848, the comment states:
"token = self.current()  # MID token (represents 'MID$' from source)"

The terminology is inconsistent - first it says 'MID$' is tokenized as 'MID token', then it says the token 'represents MID$ from source'. This could be clearer about whether the token type is literally called 'MID' or if it's called 'MID$' or something else.

---
#### code_vs_comment

**Description:** Comment about function name normalization in DEF FN is redundant with later comment

**Affected files:**
- `src/parser.py`

**Details:**
Comment at lines ~1920-1924 states:
"Function name normalization: All function names are normalized to lowercase with
'fn' prefix (e.g., "FNR" becomes "fnr", "FNA$" becomes "fna$") for consistent
lookup. This matches the lexer's identifier normalization and ensures function
calls match their definitions regardless of case."

This detailed explanation appears in the docstring, but the actual implementation code doesn't show any normalization happening in the visible portion. The comment may be describing behavior that happens elsewhere (in the lexer or in code not shown), making it potentially misleading in this location.

---
#### documentation_inconsistency

**Description:** LPRINT comment about separator behavior uses ambiguous phrasing

**Affected files:**
- `src/parser.py`

**Details:**
Comment at lines ~1042-1046 states:
"# Add newline if there's no trailing separator
# For N expressions: N-1 separators (between items) = no trailing separator
#                    N separators (between items + at end) = has trailing separator
# Note: If len(separators) > len(expressions) (e.g., "LPRINT ;"), the trailing
# separator is already in the list and will suppress the newline."

The phrase 'N-1 separators (between items)' is mathematically correct but could be clearer. The comment should explicitly state that separators are collected BETWEEN expressions, and a trailing separator after the last expression is what determines newline behavior.

---
#### code_vs_comment

**Description:** Comment in parse_resume() says RESUME and RESUME 0 both retry error statement, but implementation stores actual value

**Affected files:**
- `src/parser.py`

**Details:**
Comment states:
"Note: RESUME and RESUME 0 both retry the statement that caused the error."

Code implementation:
```python
line_number = int(self.advance().value)
```

The comment suggests RESUME 0 has special meaning (retry error statement), and notes that interpreter treats 0 and None equivalently. However, the parser stores the actual value (0 or other line number) without special handling. This creates ambiguity about whether 0 is a sentinel value or an actual line number 0.

---
#### code_vs_comment

**Description:** parse_width() docstring describes device parameter as 'implementation-specific' but provides no guidance on what values are valid

**Affected files:**
- `src/parser.py`

**Details:**
Docstring states:
"device: Optional device expression (implementation-specific; may support
file numbers, device codes, or other values depending on the interpreter)"

The code simply parses any expression:
```python
device = self.parse_expression()
```

The comment acknowledges the parameter is implementation-specific but provides no examples or constraints. This makes it unclear what valid device values are (file numbers like #1, device names like "LPT1:", numeric codes, etc.).

---
#### documentation_inconsistency

**Description:** parse_common() docstring says 'Non-empty parentheses are an error' but doesn't show error handling code

**Affected files:**
- `src/parser.py`

**Details:**
Docstring states:
"The empty parentheses () indicate an array variable (all elements shared).
This is just a marker - no subscripts are specified or stored. Non-empty
parentheses are an error (parser enforces empty parens only)."

Code implementation:
```python
if self.match(TokenType.LPAREN):
    self.advance()
    if not self.match(TokenType.RPAREN):
        raise ParseError("Expected ) after ( in COMMON array", self.current())
    self.advance()
```

The error message "Expected ) after ( in COMMON array" doesn't clearly communicate that subscripts are not allowed. A user might interpret this as a syntax error rather than understanding that COMMON arrays cannot have subscripts specified.

---
#### code_vs_comment

**Description:** parse_def_fn() comment about function name normalization is inconsistent with actual behavior

**Affected files:**
- `src/parser.py`

**Details:**
Comment states:
"function_name = 'fn' + raw_name  # Use lowercase 'fn' to match function calls"

And later:
"# raw_name already starts with lowercase 'fn' from lexer normalization
function_name = raw_name"

The first comment suggests adding 'fn' prefix, while the second suggests it's already present. The code handles two cases:
1. DEF FN R - adds 'fn' prefix
2. DEF FNR - already has 'fn' prefix from lexer

The comments could be clearer about why these two paths exist and how they differ in terms of lexer tokenization.

---
#### code_vs_comment

**Description:** apply_keyword_case_policy docstring says 'Callers may pass keywords in any case' but emit_keyword docstring says 'keyword MUST be normalized lowercase by caller'

**Affected files:**
- `src/position_serializer.py`

**Details:**
apply_keyword_case_policy docstring: 'Callers may pass keywords in any case.'

emit_keyword docstring: 'Args:
    keyword: The keyword to emit (MUST be normalized lowercase by caller)'

These are contradictory requirements. The apply_keyword_case_policy function handles normalization internally for first_wins policy ('keyword_lower = keyword.lower()'), suggesting it can accept any case. But emit_keyword requires lowercase input.

---
#### documentation_inconsistency

**Description:** apply_keyword_case_policy docstring mentions 'preserve' policy but implementation provides only a defensive fallback

**Affected files:**
- `src/position_serializer.py`

**Details:**
Docstring for 'preserve' policy: 'The "preserve" policy means callers should pass keywords already in the correct case and this function returns them as-is. However, since we can\'t know the original case here, we provide a defensive fallback (capitalize) for robustness in case this function is called incorrectly with "preserve" policy.'

This suggests the function isn't designed to properly handle 'preserve' policy - it just returns capitalize as a fallback. This seems inconsistent with the policy's intent.

---
#### code_vs_comment

**Description:** Comment in serialize_expression for VariableNode says 'Only add type suffix if explicit' but doesn't explain what makes it explicit

**Affected files:**
- `src/position_serializer.py`

**Details:**
Code: 'if expr.type_suffix and getattr(expr, \'explicit_type_suffix\', False):
    text += expr.type_suffix'

Comment: '# Only add type suffix if explicit'

The comment doesn't explain what 'explicit_type_suffix' means or when it would be True vs False. This attribute is checked but not documented in the VariableNode structure shown.

---
#### code_vs_comment

**Description:** renumber_with_spacing_preservation docstring says 'Caller should serialize these LineNodes using serialize_line()' but doesn't explain why or when

**Affected files:**
- `src/position_serializer.py`

**Details:**
Docstring ends with: 'Returns:
    Dict of new_line_number -> LineNode (with updated positions)
    Caller should serialize these LineNodes using serialize_line() to regenerate text'

This instruction is vague - it doesn't explain whether serialization is required, optional, or when it should happen. The function returns LineNodes (AST), not text, so the caller must serialize to get text, but this isn't clearly stated as a requirement.

---
#### documentation_inconsistency

**Description:** Module docstrings have slightly different wording when distinguishing between the two modules

**Affected files:**
- `src/resource_limits.py`
- `src/resource_locator.py`

**Details:**
resource_limits.py says: "Note: This is distinct from resource_locator.py which finds package data files."

resource_locator.py says: "Note: This is distinct from resource_limits.py which enforces runtime execution limits."

Both correctly distinguish the modules but use different terminology ('finds package data files' vs 'enforces runtime execution limits'). The distinction is clear but could be more consistent.

---
#### documentation_inconsistency

**Description:** Inconsistent string length limit documentation between different preset configurations

**Affected files:**
- `src/resource_limits.py`

**Details:**
All three preset functions (create_web_limits, create_local_limits, create_unlimited_limits) document max_string_length differently:

create_web_limits(): "max_string_length=255,              # 255 bytes (MBASIC 5.21 compatibility)"

create_local_limits(): "max_string_length=255,              # 255 bytes (MBASIC 5.21 compatibility)"

create_unlimited_limits(): "max_string_length=1024*1024,        # 1MB strings (for testing/development - not MBASIC compatible)"

The unlimited version explicitly notes it's "not MBASIC compatible" which is good, but the comment style and detail level varies. The first two are identical (good), but the third breaks compatibility for testing purposes which should perhaps be more prominently documented in the function docstring.

---
#### documentation_inconsistency

**Description:** Incomplete docstring for get_all_variables() method

**Affected files:**
- `src/runtime.py`

**Details:**
Line 838-851: The docstring for get_all_variables() is incomplete:

"Export all variables with structured type information.

Returns detailed information about each variable including:
- Base name (without type suffix)
- Type suffix character
- For scalars: current value
- For arrays: dimensions and base
- Access tracking: last_read and last_write info

Returns:
    list: List of dictionaries with variable information
          Each dict contains:"

The docstring ends abruptly without listing what keys each dictionary contains. This makes the API unclear for users of this method.

---
#### Code vs Comment conflict

**Description:** Comment claims default type suffix fallback should not occur in practice, but code implements it as defensive programming

**Affected files:**
- `src/runtime.py`

**Details:**
In parse_name() helper function within get_variables():

Comment says: "Note: In normal operation, all names in _variables have resolved type suffixes from _resolve_variable_name() which applies DEF type rules. This fallback is defensive programming for robustness - it should not occur in practice, but protects against potential edge cases in legacy code or future changes."

Code implements: "return full_name, '!'" as fallback when no type suffix present.

The comment suggests this is purely defensive and shouldn't happen, but doesn't explain if this is truly unreachable or if there are legitimate edge cases.

---
#### Documentation inconsistency

**Description:** Redundant field documentation acknowledges redundancy but doesn't explain why it exists

**Affected files:**
- `src/runtime.py`

**Details:**
In get_execution_stack() docstring for GOSUB calls:

"Note: 'from_line' is redundant with 'return_line' - both contain the same value (the line number to return to after RETURN). The 'from_line' field exists for backward compatibility with code that expects it. Use 'return_line' for new code as it more clearly indicates the field's purpose."

This documents the redundancy but doesn't specify what code depends on 'from_line' or when it might be safe to remove. The deprecation policy is unclear compared to get_loop_stack() which has explicit deprecation dates.

---
#### Documentation inconsistency

**Description:** Inconsistent terminology for statement offset indexing explanation

**Affected files:**
- `src/runtime.py`

**Details:**
Multiple docstrings explain 0-based indexing differently:

get_gosub_stack(): "Note: stmt_offset uses 0-based indexing (offset 0 = 1st statement, offset 1 = 2nd statement, etc.)"

set_breakpoint(): "Note: Uses 0-based indexing (offset 0 = 1st statement, offset 1 = 2nd statement, offset 2 = 3rd statement, etc.)"

get_execution_stack() example: "This shows: FOR I at line 100, statement offset 0 (1st statement)..."

While all are technically correct, the varying levels of detail (some show 2 examples, some show 3) and placement (some in Notes, some inline) create minor inconsistency in documentation style.

---
#### Documentation inconsistency

**Description:** Deprecation notice uses inconsistent date format

**Affected files:**
- `src/runtime.py`

**Details:**
In get_loop_stack() deprecation notice:
"Deprecated since: 2025-10-25 (commit cda25c84)"

This date (2025-10-25) is in the future relative to typical software development timelines, suggesting either:
1. The date format is incorrect (should be 2024-10-25)
2. This is placeholder documentation
3. The codebase uses a non-standard dating convention

The date should be verified for accuracy.

---
#### documentation_inconsistency

**Description:** Duplicate documentation of settings file paths in two files

**Affected files:**
- `src/settings.py`
- `src/settings_backend.py`

**Details:**
Both settings.py and settings_backend.py document the same file paths:

settings.py docstring:
"- Global: ~/.mbasic/settings.json (Linux/Mac) or %APPDATA%/mbasic/settings.json (Windows)
- Project: .mbasic/settings.json in project directory"

settings_backend.py FileSettingsBackend docstring:
"Stores settings in JSON files:
- Global: ~/.mbasic/settings.json (Linux/Mac) or %APPDATA%/mbasic/settings.json (Windows)
- Project: .mbasic/settings.json in project directory"

This duplication could lead to maintenance issues if paths change.

---
#### code_vs_comment

**Description:** Comment about file-level settings infrastructure being 'fully implemented' is misleading

**Affected files:**
- `src/settings.py`

**Details:**
Multiple comments state file-level settings are 'fully implemented':

In SettingsManager docstring:
"Note: File-level settings infrastructure is fully implemented (file_settings dict,
FILE scope support in get/set/reset methods), but currently unused."

In get() method:
"Note: File-level settings infrastructure is fully implemented and functional.
The file_settings dict can be set programmatically and is checked first in precedence."

However, the infrastructure is only partially implemented:
- file_settings dict exists
- get() checks it
- set() can write to it
- reset_to_defaults() can clear it
- BUT: load() never populates it from any source
- BUT: save() never persists it anywhere

So it's not 'fully implemented' - it's a runtime-only dict with no persistence.

---
#### code_vs_documentation

**Description:** Comments mention settings not included but don't explain why

**Affected files:**
- `src/settings_definitions.py`

**Details:**
Two comments mention excluded settings:

"# Note: editor.tab_size setting not included - BASIC uses line numbers for program structure,
# not indentation, so tab size is not a meaningful setting for BASIC source code"

"# Note: Line numbers are always shown - they're fundamental to BASIC!
# editor.show_line_numbers setting not included - makes no sense for BASIC"

These are good explanatory comments, but they reference settings that don't exist anywhere in the codebase. This could confuse developers looking for these settings. The comments are defensive documentation against expected but non-existent features.

---
#### code_vs_comment

**Description:** Module docstring references src/lexer.py but doesn't verify the relationship

**Affected files:**
- `src/simple_keyword_case.py`

**Details:**
Module docstring states:
"This is a simplified keyword case handler used by the lexer (src/lexer.py)."

And later:
"The lexer (src/lexer.py) uses SimpleKeywordCase because keywords only need
force-based policies in the tokenization phase."

However, src/lexer.py is not provided in the source files, so this relationship cannot be verified. The comment makes claims about how another module uses this code, but that module isn't available for verification.

---
#### documentation_inconsistency

**Description:** RedisSettingsBackend comment mentions 'nicegui or redis-py' but only redis-py is imported

**Affected files:**
- `src/settings_backend.py`

**Details:**
RedisSettingsBackend.__init__ docstring says:
"Args:
    redis_client: Redis client instance (from nicegui or redis-py)"

But in create_settings_backend(), only redis-py is used:
"import redis
redis_client = redis.from_url(redis_url, decode_responses=True)"

No nicegui Redis client is ever used. The comment suggests two possible sources but only one is implemented.

---
#### code_vs_comment

**Description:** RedisSettingsBackend TTL comment says '24 hours (matches NiceGUI session expiry)' but this is hardcoded assumption

**Affected files:**
- `src/settings_backend.py`

**Details:**
In RedisSettingsBackend._set_data():
"# Set with TTL of 24 hours (matches NiceGUI session expiry)
self.redis.setex(self.redis_key, 86400, data)"

The comment assumes NiceGUI session expiry is 24 hours, but this is not verified anywhere in the code. If NiceGUI's session expiry changes or is configurable, this hardcoded value would be incorrect. The comment makes an assertion about external behavior without verification.

---
#### Code vs Comment conflict

**Description:** Comment about removeprefix() fallback is misleading

**Affected files:**
- `src/ui/curses_settings_widget.py`

**Details:**
Line in _create_setting_widget():
'# Note: Both removeprefix() and the fallback [6:] only strip from the beginning,
# ensuring we don\'t modify \'force_\' appearing elsewhere in the string'

The comment claims both methods 'only strip from the beginning', but this is obvious for string slicing [6:] which always operates from the beginning. The comment seems to over-explain a trivial point, possibly indicating confusion during development.

---
#### Documentation inconsistency

**Description:** Contradictory documentation about BatchBackend purpose

**Affected files:**
- `src/ui/base.py`

**Details:**
base.py docstring lists 'BatchBackend' as a future backend type with this note:
'BatchBackend: Non-interactive execution mode for running programs from command line
(Note: "headless" typically means no UI, which seems contradictory to UIBackend purpose;
batch/non-interactive execution may be better handled outside the UIBackend abstraction)'

This is self-contradictory - it lists BatchBackend as a potential UIBackend implementation while simultaneously questioning whether it should be a UIBackend at all.

---
#### code_vs_comment

**Description:** Comment about target_column default value is misleading

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
In _sort_and_position_line docstring:
"target_column: Column to position cursor at (default: 7). This value is an approximation for typical line numbers."

And in keypress method:
"Note: Methods like _sort_and_position_line use a default target_column of 7, which assumes typical line numbers (status=1 char + number=5 digits + space=1 char)."

But the math is wrong: 1 + 5 + 1 = 7 assumes ALL line numbers are exactly 5 digits (like 10000-99999). For typical line numbers like 10, 100, 1000, the code area starts at column 3, 4, or 5, not 7. The comment should say 'assumes 5-digit line numbers' not 'typical line numbers'.

---
#### code_vs_comment

**Description:** Comment about syntax error priority conflicts with implementation details

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
In _display_syntax_errors docstring:
"Display syntax error messages in the output window with context.

Called by _update_syntax_indicators() during editing..."

But the method is actually called by _update_syntax_errors (not _update_syntax_indicators). There is no _update_syntax_indicators method in the code. This appears to be a renamed method where the docstring wasn't updated.

---
#### code_vs_comment

**Description:** Comment says _create_toolbar is UNUSED but provides detailed explanation about why it was removed

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~280 states:
STATUS: UNUSED - not called anywhere in current implementation.

The toolbar was removed from the UI in favor of Ctrl+U menu for better keyboard navigation. This fully-implemented method is retained for reference in case toolbar functionality is desired in the future. Can be safely removed if no plans to restore.

This is accurate documentation of unused code, but the method still exists with full implementation. This creates maintenance burden.

---
#### code_vs_comment

**Description:** Comment says interpreter is NEVER recreated but doesn't explain why immediate_executor IS recreated

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at lines ~170-178 says:
# Interpreter Lifecycle:
# Created ONCE here in __init__ and reused throughout the session.
# The interpreter object itself is NEVER recreated - the same instance is used
# for the lifetime of the UI session.
# Note: The immediate_io handler created here is temporary - ImmediateExecutor
# will be recreated in start() with a fresh OutputCapturingIOHandler, but that
# new executor will receive this same interpreter instance (not a new interpreter).

This explains interpreter lifecycle but doesn't explain WHY the executor needs recreation while interpreter doesn't. The architectural decision is documented but not justified.

---
#### documentation_inconsistency

**Description:** Inconsistent documentation of keyboard shortcuts between STATUS_BAR_SHORTCUTS constant and actual key handling

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
The code references STATUS_BAR_SHORTCUTS constant (line ~410) but the constant definition is not shown in this file. The _handle_input() method implements many keyboard shortcuts (QUIT_KEY, TAB_KEY, MENU_KEY, etc.) but we cannot verify if STATUS_BAR_SHORTCUTS documents all of them without seeing the constant definition.

---
#### code_vs_comment

**Description:** Comment about column positioning in _delete_current_line is inconsistent with actual positioning logic

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~810 says:
# Always position at column 1 (start of line number field)

But the code shows:
if line_index > 0:
    new_cursor_pos = sum(len(lines[i]) + 1 for i in range(line_index)) + 1
else:
    new_cursor_pos = 1  # First line, column 1

The +1 offset positions at column 1 (0-indexed), but the comment says 'start of line number field' which would actually be after the status character. The comment is ambiguous about whether column 1 means the status char or the first digit.

---
#### code_vs_comment

**Description:** Comment in _smart_insert_line says 'column 7' but doesn't explain why 7 specifically

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~920 says:
# Position cursor on the new line, at the code area (column 7)

And code:
new_cursor_pos = 7  # Column 7 is start of code area

But earlier in the file, line format is described as 'status(1) + line_num(variable width) + space + code'. With variable width line numbers, column 7 is not always the code area. This appears to be hardcoded for a specific line number width assumption.

---
#### code_vs_comment

**Description:** Comment describes main widget storage strategy inconsistently across methods

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Three different comments describe main widget storage:

1. _show_help (line ~730): "Main widget retrieval: Use self.base_widget (stored at UI creation time in __init__) rather than self.loop.widget (which reflects the current widget and might be a menu or other overlay). This approach works for _show_help, _show_keymap, and _show_settings because these methods close any existing overlays first (via on_close callbacks) before creating new ones, ensuring self.base_widget is the correct base for the new overlay."

2. _activate_menu (line ~800): "Main widget storage: Unlike _show_help/_show_keymap/_show_settings which close existing overlays first (and thus can use self.base_widget directly), this method extracts base_widget from self.loop.widget to unwrap any existing overlay. This preserves existing overlays (like help or settings) while adding the menu dropdown on top of them, allowing menu navigation even when other overlays are present."

3. _show_keymap (line ~760): "Main widget storage: Uses self.base_widget (stored at UI creation time in __init__) rather than self.loop.widget (which reflects the current widget and might be a menu or other overlay). Same approach as _show_help and _show_settings."

The comments suggest _show_help/_show_keymap/_show_settings all close existing overlays first, but the code for these methods doesn't show explicit overlay closing - they just use self.base_widget directly. The distinction between menu's approach and the others' approach is unclear.

---
#### code_vs_comment

**Description:** Comment about statement-level precision for GOSUB contradicts variable naming

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~1095 says:
"# Show statement-level precision for GOSUB return address
# return_stmt is statement offset (0-based index): 0 = first statement, 1 = second, etc."

But the code uses 'return_stmt' variable name which suggests it's a statement number, not an offset. The comment clarifies it's 0-based (offset), but the variable name 'return_stmt' is misleading - should be 'return_stmt_offset' or 'return_stmt_index' for clarity.

---
#### code_vs_comment

**Description:** Comment says 'duplicates definition in _run_program - consider extracting to shared location' but then imports from shared location, making the comment outdated

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~1570:
# Need to create the CapturingIOHandler class inline
# (duplicates definition in _run_program - consider extracting to shared location)
# Import shared CapturingIOHandler
from .capturing_io_handler import CapturingIOHandler

The comment suggests the code duplicates and should be extracted, but the very next line imports from a shared location, indicating the extraction already happened.

---
#### code_vs_comment

**Description:** Comment in cmd_delete says 'Note: Updates self.program immediately (source of truth), then syncs to runtime' but this pattern is repeated in multiple commands without explaining why runtime isn't the source of truth

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comments in cmd_delete (line ~1650) and cmd_renum (line ~1670) both say:
"Note: Updates self.program immediately (source of truth), then syncs to runtime."

This suggests self.program is the source of truth, but elsewhere in the code (e.g., _sync_program_to_runtime) there's complex logic to preserve runtime state. The relationship between program and runtime as sources of truth is unclear.

---
#### code_vs_comment

**Description:** Comment in _sync_program_to_runtime says 'This allows LIST and other commands to see the current program without starting execution' but LIST command (_list_program) uses self.editor_lines, not runtime

**Affected files:**
- `src/ui/curses_ui.py`

**Details:**
Comment at line ~1220:
"Sync program to runtime without resetting PC.

Updates runtime's statement_table and line_text_map from self.program,
but preserves current PC/execution state. This allows LIST and other
commands to see the current program without starting execution."

But _list_program implementation (line ~1110):
for line_num in sorted(self.editor_lines.keys()):
    lines.append(f"{line_num} {self.editor_lines[line_num]}")

LIST uses editor_lines, not runtime, so the comment's justification is incorrect.

---
#### code_vs_comment_conflict

**Description:** Comment says 'Project has internal implementation version (src/version.py) separate from this' but this is just a comment about version handling, not an inconsistency per se. However, it's unclear if src/version.py actually exists or if this is outdated.

**Affected files:**
- `src/ui/help_macros.py`

**Details:**
Line ~76 comment:
"# Hardcoded MBASIC version for documentation
# Note: Project has internal implementation version (src/version.py) separate from this
return '5.21'  # MBASIC 5.21 language version"

This suggests src/version.py exists but we don't have that file in the provided code to verify.

---
#### code_vs_documentation_inconsistency

**Description:** The tier label mapping in _search_indexes method has a comment 'Note: UI tier (e.g., 'ui/curses', 'ui/tk') is detected via startswith('ui/') check below and gets 'ðŸ“˜ UI' label. Other unrecognized tiers get 'ðŸ“™ Other'.' However, the actual tier_labels dict only defines 'language' and 'mbasic', not showing the UI or Other mappings explicitly.

**Affected files:**
- `src/ui/help_widget.py`

**Details:**
Line ~130 comment:
"# Map tier to labels for search result display
# Note: UI tier (e.g., 'ui/curses', 'ui/tk') is detected via startswith('ui/')
# check below and gets 'ðŸ“˜ UI' label. Other unrecognized tiers get 'ðŸ“™ Other'.
tier_labels = {
    'language': 'ðŸ“• Language',
    'mbasic': 'ðŸ“— MBASIC',
}"

The comment describes UI and Other tier handling but these aren't in the dict - they're handled in the conditional logic below (line ~150). This is correct code but the comment placement makes it seem like the dict should contain all mappings.

---
#### code_vs_comment_conflict

**Description:** Comment in _build_link_mapping says 'For links in headings like [text](url), we parse the URL directly since the renderer doesn't extract them.' This implies the renderer has a limitation, but we don't have the renderer code to verify if this is accurate or outdated.

**Affected files:**
- `src/ui/help_widget.py`

**Details:**
Line ~280 comment:
"For links in headings like [text](url), we parse the URL directly since the renderer doesn't extract them."

Without seeing markdown_renderer.py, we can't verify if this is still true or if the renderer was updated to handle these links.

---
#### code_vs_comment_conflict

**Description:** The menu structure comment says 'QUIT_KEY is None (menu-only)' but we don't see where QUIT_KEY is defined or used. The keybindings module is imported but QUIT_KEY isn't referenced in the visible code.

**Affected files:**
- `src/ui/interactive_menu.py`

**Details:**
Line ~40 comment:
"('Quit', 'quit'),  # QUIT_KEY is None (menu-only)"

The comment references QUIT_KEY but:
1. It's not imported from keybindings module
2. It's not used in the code
3. The menu item just uses the string 'quit' directly

This suggests the comment is outdated from a refactoring.

---
#### code_vs_comment_conflict

**Description:** Comment says 'STACK_KEY is '' (menu-only)' but STACK_KEY is not defined or imported anywhere in the visible code.

**Affected files:**
- `src/ui/interactive_menu.py`

**Details:**
Line ~56 comment:
"('Execution Stack', '_toggle_stack_window'),  # STACK_KEY is '' (menu-only)"

Similar to QUIT_KEY, STACK_KEY is referenced in a comment but not actually used in the code. This appears to be an outdated comment from when these keys were defined constants.

---
#### Code vs Comment conflict

**Description:** Comment on line 195 says 'MAXIMIZE_OUTPUT_KEY (Shift+Ctrl+M) - Menu-only feature, not documented as keyboard shortcut' but the constant is defined with a keyboard shortcut value 'ctrl shift m'.

**Affected files:**
- `src/ui/keybindings.py`

**Details:**
Line 184: MAXIMIZE_OUTPUT_KEY = 'ctrl shift m'
Line 195 comment: '# - MAXIMIZE_OUTPUT_KEY (Shift+Ctrl+M) - Menu-only feature, not documented as keyboard shortcut'

The constant has a keyboard shortcut assigned, contradicting the 'menu-only' claim.

---
#### Documentation inconsistency

**Description:** Module docstring says 'Note: Not thread-safe (no locking mechanism)' but doesn't explain if this is intentional or a limitation. Given that the module is used across multiple UIs, thread-safety might be expected.

**Affected files:**
- `src/ui/recent_files.py`

**Details:**
Lines 1-23 docstring:
"""Recent Files Manager - Shared module for tracking recently opened files
...
Features:
- Stores last 10 recently opened files
- Records full path and last access timestamp
- Automatically creates config directory if needed
- Cross-platform (uses pathlib)
- Note: Not thread-safe (no locking mechanism)
"""

No explanation of whether this is a known limitation or intentional design choice.

---
#### Code vs Comment conflict

**Description:** Comment on line 194 says 'STACK_KEY (empty string) - No keyboard shortcut assigned, menu-only' but the constant is defined as empty string ''. An empty string is not a valid keyboard shortcut, so the comment is accurate but the code implementation is questionable.

**Affected files:**
- `src/ui/keybindings.py`

**Details:**
Line 142: STACK_KEY = ''  # No keyboard shortcut

Line 194 comment: '# - STACK_KEY (empty string) - No keyboard shortcut assigned, menu-only'

Using empty string '' as a sentinel value for 'no shortcut' is inconsistent with QUIT_KEY which uses None for the same purpose (line 150).

---
#### Code vs Comment conflict

**Description:** Comment about link tag prefixes may be incomplete or outdated

**Affected files:**
- `src/ui/tk_help_browser.py`

**Details:**
In _create_context_menu() method (line 577):
# Note: Both "link_" (from _render_line_with_links) and "result_link_"
# (from _execute_search) prefixes are checked. Both types are stored
# identically in self.link_urls, but the prefixes distinguish their origin.

However, examining the code shows three different link tag patterns:
1. 'link_' prefix created in _render_line_with_links() (line 211)
2. 'result_link_' prefix created in _execute_search() (line 368)
3. Plain tag names without prefix used in _render_line_with_links() (line 214)

The comment only mentions two patterns but the code shows a third pattern exists.

---
#### Documentation inconsistency

**Description:** Inline help display described as 'not a hover tooltip' but implementation details unclear

**Affected files:**
- `src/ui/tk_settings_dialog.py`

**Details:**
In _create_setting_widget() method (line 177):
# Show short help as inline label (not a hover tooltip, just a gray label)

The comment clarifies what the implementation is NOT (not a tooltip), but the phrasing suggests there might have been confusion or a previous implementation that used tooltips. This could indicate an outdated comment from refactoring.

---
#### Code vs Comment conflict

**Description:** Comment about modal behavior contradicts typical understanding of modal dialogs

**Affected files:**
- `src/ui/tk_settings_dialog.py`

**Details:**
In __init__() method (line 44):
# Make modal (prevents interaction with parent, but doesn't block code execution - no wait_window())

The comment states the dialog is modal but explicitly notes it doesn't block code execution because wait_window() is not called. This is contradictory because modal dialogs typically DO block execution. The comment seems to be clarifying a non-standard implementation but the terminology is confusing.

---
#### Code vs Comment conflict

**Description:** Comment about context menu dismissal behavior may not match implementation

**Affected files:**
- `src/ui/tk_help_browser.py`

**Details:**
In _create_context_menu() method (line 593):
# Define dismiss_menu helper for ESC/FocusOut bindings (below)

Followed by (line 601):
# Release grab after menu is shown. Note: tk_popup handles menu interaction,
# but we explicitly release the grab to ensure clean state.

The comment at line 593 says dismiss_menu is for ESC/FocusOut bindings, but the bindings at lines 607-608 show FocusOut and Escape both call dismiss_menu(). However, the comment at line 601 about releasing grab suggests tk_popup already handles interaction, which may make the explicit dismiss_menu bindings redundant or the comment outdated.

---
#### code_vs_comment

**Description:** Docstring describes 3-pane layout with specific weights (3:2:1) but implementation uses ttk.PanedWindow which doesn't use those exact weight values

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Docstring lines 48-52:
'- 3-pane vertical layout (weights: 3:2:1 = total 6 units):
  * Editor with line numbers (top, ~50% = 3/6 - weight=3)
  * Output pane (middle, ~33% = 2/6 - weight=2)
    - Contains INPUT row (shown/hidden dynamically for INPUT statements)
  * Immediate mode input line (bottom, ~17% = 1/6 - weight=1)'

Implementation lines 158-162, 168-169, 275-276:
paned = ttk.PanedWindow(self.root, orient=tk.VERTICAL)
paned.add(editor_frame, weight=3)
paned.add(output_frame, weight=2)
paned.add(immediate_frame, weight=1)

While the weights match, ttk.PanedWindow weight behavior doesn't guarantee exact percentages as described. The percentages are approximate and depend on user resizing.

---
#### code_vs_comment

**Description:** Comment states Ctrl+I is bound to editor text widget to prevent tab interference, but the actual binding location is not shown in the provided code

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line 453:
'# Note: Ctrl+I is bound directly to editor text widget in start() (not root window)
# to prevent tab key interference - see editor_text.text.bind('<Control-i>', ...)'

The referenced binding is at line 189:
self.editor_text.text.bind('<Control-i>', self._on_ctrl_i)

The comment is accurate but the phrasing 'see editor_text.text.bind' suggests looking for it elsewhere when it's actually earlier in the same method (start()).

---
#### documentation_inconsistency

**Description:** Docstring describes INPUT row visibility control but doesn't mention the input_queue attribute used for coordination

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Docstring lines 50-51:
'- Contains INPUT row (shown/hidden dynamically for INPUT statements)'

Code lines 127-128:
self.input_queue = None  # Queue for coordinating INPUT with interpreter

Code lines 246-248:
# Initialize input queue
import queue
self.input_queue = queue.Queue()

The docstring mentions INPUT row visibility but doesn't document the queue mechanism used for coordinating INPUT statements with the interpreter.

---
#### code_vs_comment

**Description:** Comment describes click region handling for variable heading but implementation accepts both 'tree' and 'cell' regions

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Method _on_variable_double_click lines 1155-1159:
'# Check if we clicked on a row (accept both 'tree' and 'cell' regions)
# 'tree' = first column area, 'cell' = other column areas
region = self.variables_tree.identify_region(event.x, event.y)
if region not in ('cell', 'tree'):
    return'

The comment accurately describes the behavior, but the phrasing 'accept both' could be clearer about why both regions are needed (different columns report different regions).

---
#### code_vs_comment_conflict

**Description:** Comment about OPTION BASE validation contradicts defensive else clause

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _edit_array_element method around line 680:
Comment says: "OPTION BASE only allows 0 or 1 (validated by OPTION statement parser). The else clause is defensive programming for unexpected values."

Code has:
if array_base == 0:
    default_subscripts = ','.join(['0'] * len(dimensions))
elif array_base == 1:
    default_subscripts = ','.join(['1'] * len(dimensions))
else:
    # Defensive fallback for invalid array_base (should not occur)
    default_subscripts = ','.join(['0'] * len(dimensions))

If OPTION BASE truly only allows 0 or 1 and this is validated, the else clause is unreachable dead code. Either the validation doesn't exist (making the comment wrong), or the else clause is unnecessary (making it misleading).

---
#### code_vs_comment_conflict

**Description:** Comment about when _validate_editor_syntax is called doesn't match actual call sites

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _validate_editor_syntax method around line 1230:
Comment says: "Note: This method is called:
- With 100ms delay after cursor movement/clicks (to avoid excessive validation during rapid editing)
- Immediately when focus leaves editor (to ensure validation before switching windows)"

However, looking at actual call sites:
- _on_cursor_move: calls with 100ms delay (matches comment)
- _on_mouse_click: calls with 100ms delay (matches comment)
- _on_focus_out: calls immediately (matches comment)
- _on_enter_key: calls after saving program state (NOT mentioned in comment)

The comment is incomplete - it doesn't mention the call from _on_enter_key.

---
#### code_vs_comment_conflict

**Description:** Comment about clearing yellow highlight conflicts with when it's actually cleared

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _on_mouse_click method around line 1320:
Comment says: "Clear yellow statement highlight when clicking (allows text selection to be visible). The highlight is restored when execution resumes or when stepping to the next statement."

However, the code only clears the highlight if paused_at_breakpoint is True:
if self.paused_at_breakpoint:
    self._clear_statement_highlight()

The comment implies the highlight is always cleared on click, but the code only clears it when paused at a breakpoint. This is a subtle but important distinction.

---
#### code_vs_comment_conflict

**Description:** Comment about showing error list contradicts actual condition logic

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In _validate_editor_syntax method around line 1260:
Comment says: "Only show full error list in output if there are multiple errors. For single errors, the red ? icon in the editor is sufficient feedback."

Code implements:
should_show_list = len(errors_found) > 1

This means exactly 1 error won't show a list (correct per comment), but the comment's reasoning is slightly misleading. The comment implies this is about avoiding clutter for single errors, but then says "We don't track 'first time' - this is intentionally simple." This suggests there was consideration of showing errors on first occurrence only, which contradicts the "single error = no list" rule.

---
#### code_vs_comment

**Description:** Comment describes keyboard shortcut behavior but doesn't mention all modifier key handling

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1055: 'Allow keyboard shortcuts with modifier keys (Control, Alt, etc.) to propagate'
Code checks: 'if event.state & 0x000C:  # Control or Alt pressed'
Comment says 'etc.' but code only checks Control (0x0004) and Alt (0x0008), not other modifiers like Command/Meta. Comment should be more precise about which modifiers are handled.

---
#### code_vs_comment

**Description:** Comment about CONT command mentions END statement handling but doesn't explain when it applies

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1650: 'Resumes execution after:
- STOP statement
- Ctrl+C/Break
- END statement (in some cases)'
The comment says 'in some cases' for END but doesn't explain what those cases are. Looking at the code, CONT checks runtime.stopped, but there's no explanation of when END would set stopped=True vs halted=True.

---
#### code_vs_comment

**Description:** Comment about RENUM using AST serialization is incomplete

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Comment at line ~1590: 'Uses AST-based approach:
1. Build line number mapping (old -> new)
2. Walk AST and update all line number references
3. Serialize AST back to source
4. Refresh editor display'
Step 3 'Serialize AST back to source' is mentioned but the actual serialization code isn't shown in this file - it's delegated to renum_program() in ui_helpers. The comment should clarify this is handled by the helper function.

---
#### code_vs_comment

**Description:** Method name _add_immediate_output() is misleading - docstring admits it's historical and just forwards to _add_output()

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Method at line 1145:
def _add_immediate_output(self, text):
    """Add text to main output pane.

    This method name is historical - it simply forwards to _add_output().
    In the Tk UI, immediate mode output goes to the main output pane.
    Note: self.immediate_history exists but is always None (see __init__). Code
    that references it (e.g., _setup_immediate_context_menu) guards against None.
    """
    self._add_output(text)

The method name suggests it adds to immediate output, but it actually adds to main output. This is a naming inconsistency that could confuse maintainers.

---
#### code_vs_comment

**Description:** Dead code retained with comment explaining it's unused, creating maintenance burden

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
Method _setup_immediate_context_menu() at line 1213:
"""Setup right-click context menu for immediate history widget.

NOTE: This method is currently unused - immediate_history is always None
in the Tk UI (see __init__). This is dead code retained for potential
future use if immediate mode gets its own output widget.
"""

Also references dead code in _copy_immediate_selection() and _select_all_immediate() methods. The comment acknowledges these are unused but they remain in the codebase.

---
#### code_vs_comment

**Description:** CLS behavior documented as design decision but may conflict with user expectations

**Affected files:**
- `src/ui/tk_ui.py`

**Details:**
In TkIOHandler.clear_screen() method:
"""Clear screen - no-op for Tk UI.

Design decision: GUI output is persistent for review. Users can manually
clear output via Run > Clear Output menu if desired. CLS command is ignored
to preserve output history during program execution.
"""

This documents that CLS is intentionally ignored, but this may conflict with BASIC program expectations. Programs that use CLS for screen management will not work as expected. This should be documented in user-facing documentation, not just code comments.

---
#### code_vs_comment

**Description:** _parse_line_number() docstring comment about MBASIC 5.21 requirement is inconsistent with regex implementation that allows end-of-string

**Affected files:**
- `src/ui/tk_widgets.py`

**Details:**
Comment in _parse_line_number() says: 'Valid: "10 PRINT" (whitespace after), "10" (end after), "  10  REM" (leading whitespace ok)
Invalid: "10REM" (no whitespace), "ABC10" (non-digit prefix), "" (empty after strip)
MBASIC 5.21 requires whitespace (or end of line) between line number and statement'

The regex is: r'^(\d+)(?:\s|$)'

The comment says 'MBASIC 5.21 requires whitespace (or end of line)' but then lists '10' (just the number with nothing after) as valid. This is technically correct per the regex ($ matches end), but the phrasing 'requires whitespace (or end of line)' makes it sound like something must come after, when actually nothing after is also valid.

---
#### documentation_inconsistency

**Description:** Class docstring describes status priority but doesn't mention that clearing errors automatically reveals breakpoints, which is mentioned elsewhere

**Affected files:**
- `src/ui/tk_widgets.py`

**Details:**
Class docstring section 'Status priority (when both error and breakpoint):' says:
'- ? takes priority (error shown)
- After fixing error, â— becomes visible (automatically handled by set_error() method which checks has_breakpoint flag when clearing errors)'

This second bullet point is implementation detail that doesn't belong in the 'Status priority' section - it should be in a separate 'Behavior' section or in the set_error() method docstring only. The class docstring should describe what the priority is, not how it's implemented.

---
#### code_vs_comment

**Description:** Comment in serialize_variable() mentions explicit_type_suffix attribute behavior but implementation uses getattr with default

**Affected files:**
- `src/ui/ui_helpers.py`

**Details:**
Comment states: "Note: explicit_type_suffix is not always set (depends on parser implementation),
so getattr defaults to False if missing, preventing incorrect suffix output"

This comment is accurate and matches the code: getattr(var, 'explicit_type_suffix', False). However, it's placed after the conditional check, making it read like an explanation of potential issues rather than documenting the defensive programming pattern. The comment correctly describes the code behavior.

---
#### code_vs_comment

**Description:** Comment in update_line_references() describes pattern behavior with examples that may not match actual regex

**Affected files:**
- `src/ui/ui_helpers.py`

**Details:**
Comment states:
"Note: Pattern uses .+? (non-greedy) to match expression in ON statements,
which correctly handles edge cases like 'ON FLAG GOTO' (variable starting with 'G'),
'ON X+Y GOTO' (expressions), and 'ON A$ GOTO' (string variables)"

The regex pattern is: r'\b(GOTO|GOSUB|THEN|ELSE|ON\s+.+?\s+GOTO|ON\s+.+?\s+GOSUB)\s+(\d+)'

The .+? pattern will match any characters non-greedily until it finds ' GOTO' or ' GOSUB'. However, this could potentially match across statement boundaries if there's a colon separator (e.g., 'ON X : GOTO' would match 'ON X : GOTO'). The comment doesn't mention this potential issue.

---
#### documentation_inconsistency

**Description:** renum_program() docstring describes renum_callback parameter but doesn't specify what StatementNode types need handling

**Affected files:**
- `src/ui/ui_helpers.py`

**Details:**
Docstring states:
"renum_callback: Function(stmt: StatementNode, line_map: Dict[int, int]) -> None
that updates statement line number references in-place.
Called for ALL statements; callback is responsible for identifying and
updating statements with line number references (GOTO, GOSUB, ON GOTO,
ON GOSUB, IF THEN/ELSE line numbers)."

The docstring lists some statement types (GOTO, GOSUB, ON GOTO, ON GOSUB, IF THEN/ELSE) but doesn't mention ON ERROR GOTO, which also contains line number references. This could lead to incomplete callback implementations.

---
#### documentation_inconsistency

**Description:** cycle_sort_mode() docstring claims to match Tk UI implementation but no verification provided

**Affected files:**
- `src/ui/variable_sorting.py`

**Details:**
Docstring states:
"The cycle order is: accessed -> written -> read -> name -> (back to accessed)
This matches the Tk UI implementation."

Without access to the Tk UI implementation code, this claim cannot be verified. If the Tk UI changes its cycle order, this comment would become outdated. The comment creates a dependency claim that may not be maintained.

---
#### code_vs_comment

**Description:** cycle_sort_mode() handles unknown modes by defaulting to 'accessed' but comment in get_sort_key_function() says unknown modes fall back to name sorting

**Affected files:**
- `src/ui/variable_sorting.py`

**Details:**
In cycle_sort_mode():
"except ValueError:
    # If current mode not in cycle (e.g., 'type' or 'value'), default to 'accessed'
    return 'accessed'"

In get_sort_key_function():
"else:
    # Default to name sorting (unknown modes fall back to this)
    return lambda v: v['name'].lower()"

These two functions handle unknown modes differently: cycle_sort_mode() defaults to 'accessed', while get_sort_key_function() defaults to 'name'. This inconsistency could cause confusion if an unknown mode is used.

---
#### Code vs Comment conflict

**Description:** The get_cursor_position() method docstring says it 'always returns line 0, column 0' and is a 'placeholder implementation', but the actual return statement uses dict keys as integers {0, 0} instead of the documented string keys 'line' and 'column'.

**Affected files:**
- `src/ui/web/codemirror5_editor.py`

**Details:**
Docstring says: 'Returns:\n            Dict with \'line\' and \'column\' keys (placeholder: always {0, 0})'
Comment in method says: '# This would need async support, for now return placeholder\n        return {\'line\': 0, \'column\': 0}'
The docstring describes the return format correctly, but uses confusing notation '{0, 0}' which looks like a set literal rather than a dict with string keys.

---
#### Documentation inconsistency

**Description:** The cmd_delete() and cmd_renum() docstrings reference 'curses_ui.py or tk_ui.py' as example implementations, but these files are not present in the provided source code, making the references unhelpful.

**Affected files:**
- `src/ui/visual.py`

**Details:**
cmd_delete() docstring: 'See curses_ui.py or tk_ui.py for example implementations.'
cmd_renum() docstring: 'See ui_helpers.renum_program() for the shared implementation logic.'
These references assume files exist that are not in the provided codebase.

---
#### Code vs Documentation inconsistency

**Description:** The cmd_cont() docstring references 'tk_ui.cmd_cont()' as an example implementation, but tk_ui.py is not in the provided source code.

**Affected files:**
- `src/ui/visual.py`

**Details:**
Docstring says: 'See tk_ui.cmd_cont() for example implementation.'
This reference cannot be followed as the file is not provided.

---
#### Code vs Comment conflict

**Description:** The _internal_change_handler comment says 'CodeMirror sends new value as args' but this is ambiguous - it's unclear if 'args' means e.args specifically or a general term for arguments.

**Affected files:**
- `src/ui/web/codemirror5_editor.py`

**Details:**
Comment: '# CodeMirror sends new value as args'
Code: 'self._value = e.args'
The comment could be clearer that it means the e.args attribute specifically, not just 'as arguments'.

---
#### code_vs_comment

**Description:** Comment references _enable_inline_input() method that is not visible in the provided code

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~70 references:
# by _enable_inline_input() in the NiceGUIBackend class.

This method is not shown in the provided code snippet (part 1), suggesting either:
1. The method exists in part 2 (not shown)
2. The comment is outdated and references a removed method
3. The method was renamed

---
#### code_vs_comment

**Description:** Comment says prompt display is handled by _get_input via _enable_inline_input, but implementation details not visible

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~62-64:
# Don't print prompt here - the input_callback (backend._get_input) handles
# prompt display via _enable_inline_input() method in the NiceGUIBackend class

The _get_input method is not shown in the provided code, so cannot verify if this is accurate.

---
#### code_vs_comment

**Description:** Comment references line numbers that may be incorrect due to code changes

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Multiple comments reference specific line numbers (e.g., 'see comment at line ~1845 below', 'see _execute_tick() at line 1932') which are fragile and likely outdated after code modifications. Line 1932 reference appears in INPUT handling comment, but _execute_tick is actually at a different location.

---
#### code_vs_comment

**Description:** Comment about defensive programming pattern is inconsistently applied

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment in _menu_run() says: 'Note: This pattern is applied uniformly across all timer management (see _menu_continue,
# _menu_new, _menu_stop, etc.)'

However, _menu_new() does not cancel exec_timer (it only sets self.exec_timer = None without checking/canceling first), while _menu_run(), _menu_stop(), and _menu_continue() do cancel it. The pattern is not actually uniform.

---
#### code_vs_comment

**Description:** Comment about RUN behavior with empty program contradicts itself

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
In _menu_run() comment says: 'RUN on empty program is fine (just clears variables, no execution).'

But later in the same method, there's code that checks for empty program and returns early with comment: '# If empty program, just show Ready (variables cleared, nothing to execute)'

The first comment says it's 'fine' but the code treats it as a special case that exits early. The behavior is consistent but the comment phrasing is misleading.

---
#### code_vs_comment

**Description:** Comment describes _remove_blank_lines heuristic as working well but acknowledges it may preserve unwanted blank lines

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~1185 says:
"Remove blank lines from editor except the last line.

The last line is preserved even if blank to avoid removing it while the user
is actively typing on it. This is a heuristic that works well in practice but
may preserve some blank lines if the user edits earlier in the document."

This is internally consistent but the comment acknowledges a known limitation. The heuristic assumes the last line is where the cursor is, which may not always be true.

---
#### code_vs_comment

**Description:** Comment in _execute_immediate describes architecture decision but doesn't match the actual sync behavior

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~1783 says:
"Architecture: We do NOT auto-sync editor from AST after immediate commands.
This preserves one-way data flow (editor â†’ AST â†’ execution) and prevents
losing user's formatting/comments. Commands that modify code (like RENUM)
update the editor text directly."

However, earlier in the same method at line ~1770, the code calls:
self._save_editor_to_program()
self._sync_program_to_runtime()

This IS syncing from editor to AST, which contradicts the 'do NOT auto-sync' statement. The comment likely means 'do not sync FROM AST back TO editor', but the wording is confusing.

---
#### code_vs_comment

**Description:** Docstring for stop() method says 'Calls app.shutdown()' but implementation shows app.shutdown() without parentheses verification

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Docstring: 'Calls app.shutdown() to terminate the NiceGUI application'

Code:
def stop(self):
    app.shutdown()

This is actually correct, but the docstring could be clearer about what app refers to (the NiceGUI app module imported at top).

---
#### code_vs_comment

**Description:** Comment says 'Save state on disconnect' but the function name and behavior suggest it's attempting to save, not guaranteed to save

**Affected files:**
- `src/ui/web/nicegui_backend.py`

**Details:**
Comment at line ~472: '# Save state on disconnect'

Function:
def save_on_disconnect():
    try:
        app.storage.client['session_state'] = backend.serialize_state()
    except Exception as e:
        sys.stderr.write(f"Warning: Failed to save final session state: {e}\n")

The comment implies success, but the implementation can silently fail. Comment should be '# Attempt to save state on disconnect' or '# Try to save state on disconnect'

---
#### code_vs_comment

**Description:** Docstring mentions Redis-backed session storage but implementation is generic

**Affected files:**
- `src/ui/web/session_state.py`

**Details:**
Class docstring states:
'Serializable session state for NiceGUIBackend.

This class represents all the state that needs to persist across requests
when using Redis-backed session storage for load balancing.'

However, the SessionState class itself is just a dataclass with serialization methods (to_dict, from_dict, to_json, from_json). It has no Redis-specific code. The class is storage-agnostic and could work with any backend. The comment implies Redis is the primary use case, but the implementation doesn't enforce or assume Redis.

---
#### documentation_inconsistency

**Description:** Example shows semicolon usage inconsistently with explanation

**Affected files:**
- `docs/help/common/examples/hello-world.md`

**Details:**
The hello-world.md example shows:
'10 PRINT "Hello, World!"'

And explains:
'The semicolon at the end is optional'

But the example code doesn't have a semicolon at the end. This could confuse beginners about what 'semicolon at the end' means. The explanation likely refers to semicolons for suppressing newlines or concatenating output, not a trailing semicolon after the statement.

---
#### documentation_inconsistency

**Description:** Exponent notation explanation has potential ambiguity about E vs D notation

**Affected files:**
- `docs/help/common/language/data-types.md`

**Details:**
The data-types.md file states: "E notation (e.g., 1.5E+10) uses single-precision by default, converts to double if assigned to # variable" and "For values within single-precision range, D and E are interchangeable when assigned to # variables". This could be clearer about when E notation actually forces single vs when it's just a default that gets converted.

---
#### documentation_inconsistency

**Description:** ASCII control character descriptions differ in detail level

**Affected files:**
- `docs/help/common/language/character-set.md`
- `docs/help/common/language/appendices/ascii-codes.md`

**Details:**
character-set.md provides a brief table of common control characters (BEL, BS, TAB, LF, CR, ESC) while ascii-codes.md provides a complete table of all control characters 0-31 with abbreviations and full names. The character-set.md could reference the complete table in ascii-codes.md for users needing more detail.

---
#### documentation_inconsistency

**Description:** FIX documentation has more detailed examples and use cases than INT, despite being related functions

**Affected files:**
- `docs/help/common/language/functions/fix.md`
- `docs/help/common/language/functions/int.md`

**Details:**
fix.md includes:
- Two detailed examples with explanations
- A specific use case for array indexing
- A note about the difference from INT

int.md only has:
- Two simple examples
- No use case explanations
- No comparison to FIX

Both should have similar depth of documentation since they're closely related functions that users often need to choose between.

---
#### documentation_inconsistency

**Description:** Inconsistent documentation of Control-C behavior between INKEY$ and INPUT$

**Affected files:**
- `docs/help/common/language/functions/inkey_dollar.md`
- `docs/help/common/language/functions/input_dollar.md`

**Details:**
inkey_dollar.md: 'Note: Control-C behavior varied in original implementations. In MBASIC 5.21 interpreter, Control-C would terminate the program. In the BASIC Compiler, Control-C was passed through. This implementation follows compiler behavior and passes Control-C through (CHR$(3)) for program detection and handling.'

input_dollar.md: 'Note: In MBASIC 5.21 interpreter, Control-C would interrupt INPUT$ and terminate the wait. This implementation passes Control-C through (CHR$(3)) for program detection and handling, matching compiler behavior.'

The INKEY$ note says 'terminate the program' while INPUT$ says 'interrupt INPUT$ and terminate the wait' - these are slightly different descriptions of the same behavior that should be worded consistently.

---
#### documentation_inconsistency

**Description:** SPACE$ documentation references STRING$ equivalence but doesn't explain STRING$ syntax

**Affected files:**
- `docs/help/common/language/functions/space_dollar.md`

**Details:**
space_dollar.md states: 'This is equivalent to STRING$(I, 32) since 32 is the ASCII code for a space character.'

However, readers unfamiliar with STRING$ won't understand this reference without clicking through. A brief inline explanation like 'STRING$(I, 32) (which creates a string of I characters with ASCII code 32)' would be clearer.

---
#### documentation_inconsistency

**Description:** STR$ documentation references 'print-using' in related links, but this appears to be a statement not a function

**Affected files:**
- `docs/help/common/language/functions/str_dollar.md`

**Details:**
In str_dollar.md:
related: ['val', 'print-using', 'left_dollar', 'right_dollar']

The 'print-using' reference should likely be to a statement file, not a function. The See Also section doesn't include PRINT USING either.

---
#### documentation_inconsistency

**Description:** TAB documentation lists READ and DATA in See Also but they are not directly related to TAB functionality

**Affected files:**
- `docs/help/common/language/functions/tab.md`

**Details:**
In tab.md See Also section:
- [READ](../statements/read.md) - Read data from DATA statements (used in example above)
- [DATA](../statements/data.md) - Store data for READ statements (used in example above)

These are only tangentially related because they appear in the example code, not because they are functionally related to TAB.

---
#### documentation_inconsistency

**Description:** AUTO documentation example shows usage but doesn't demonstrate the asterisk warning feature mentioned in remarks

**Affected files:**
- `docs/help/common/language/statements/auto.md`

**Details:**
The Remarks section states:
'If AUTO generates a line number that is already being used, an asterisk is printed after the number to warn the user'

But the Example section doesn't demonstrate this behavior:
```basic
AUTO 100,50
REM Generates line numbers 100, 150, 200, etc.

AUTO
REM Generates line numbers 10, 20, 30, 40, etc.
```

An example showing the asterisk warning would be more helpful.

---
#### documentation_inconsistency

**Description:** CHAIN documentation states 'Open files remain open across the chain operation' but doesn't clarify if this applies to all file types

**Affected files:**
- `docs/help/common/language/statements/chain.md`

**Details:**
In chain.md Remarks section:
'Open files remain open across the chain operation.'

This statement doesn't specify whether this applies to sequential files, random files, or both. It also doesn't mention what happens to file numbers or whether the chained program needs to know about these open files.

---
#### documentation_inconsistency

**Description:** CONT documentation references 'Section 2.61, STOP' which is not a valid cross-reference format

**Affected files:**
- `docs/help/common/language/statements/cont.md`

**Details:**
In cont.md Example section:
'See example Section 2.61, STOP.'

This appears to be a reference to an old manual section number that doesn't match the markdown documentation structure. Should be a proper markdown link like [STOP](stop.md).

---
#### documentation_inconsistency

**Description:** DATA documentation doesn't mention behavior when READ attempts to read past end of DATA

**Affected files:**
- `docs/help/common/language/statements/data.md`

**Details:**
The DATA documentation explains how DATA statements work and how they're read sequentially, but doesn't document what error occurs when a READ statement tries to read more items than are available in DATA statements. This is important error-handling information.

---
#### documentation_inconsistency

**Description:** END documentation claims CONT can continue after END, but this contradicts typical BASIC behavior where END terminates the program

**Affected files:**
- `docs/help/common/language/statements/end.md`
- `docs/help/common/language/statements/stop.md`

**Details:**
END.md states:
'Can be continued with CONT (execution resumes at next statement after END)'

This is unusual - typically END terminates the program completely and CONT would not work. STOP allows CONT, but END typically does not. This may be incorrect documentation or unusual implementation behavior.

---
#### documentation_inconsistency

**Description:** INPUT documentation has inconsistent formatting in syntax section

**Affected files:**
- `docs/help/common/language/statements/input.md`

**Details:**
The syntax shows:
INPUT[;] ["prompt string"[;|,]]variable[,variable...]

But the remarks describe the semicolon behavior differently:
'A semicolon immediately after INPUT suppresses the carriage return/line feed'
'A semicolon after the prompt string causes the prompt to be displayed without a question mark'

The syntax should clarify that there are TWO different semicolon positions with different meanings: INPUT; vs INPUT "prompt";

---
#### documentation_inconsistency

**Description:** FILES documentation mentions CP/M specific behavior without version qualification

**Affected files:**
- `docs/help/common/language/statements/files.md`

**Details:**
The documentation states:
'**Note**: CP/M automatically adds .BAS extension if none is specified for BASIC program files.'

This is system-specific behavior that may not apply to all versions of MBASIC. The documentation should clarify this is CP/M-specific or remove it if not applicable to the current implementation.

---
#### documentation_inconsistency

**Description:** LLIST references LIST Format 2 examples but LIST has two different format descriptions

**Affected files:**
- `docs/help/common/language/statements/llist.md`
- `docs/help/common/language/statements/list.md`

**Details:**
llist.md states: 'See the examples for LIST, Format 2.'

But list.md shows:
'Format 1: LIST [<line number>]           (8K version)'
'Format 2: LIST [<line number>[-[<line number>]]]  (Extended, Disk)'

The Example section in list.md mixes both formats without clearly separating them, making the reference from LLIST ambiguous.

---
#### documentation_inconsistency

**Description:** Missing documentation for PRINT# USING format string details

**Affected files:**
- `docs/help/common/language/statements/printi-printi-using.md`

**Details:**
printi-printi-using.md mentions PRINT# USING format strings:
'**PRINT# USING** formats output using a format string, just like PRINT USING:
- # for digit positions
- . for decimal point
- $$ for floating dollar sign
- ** for asterisk fill
- , for thousands separator'

But there's no link to detailed PRINT USING documentation, and the See Also section references 'PRINT USING' with link to print.md, but print.md doesn't contain PRINT USING documentation (it only documents basic PRINT).

---
#### documentation_inconsistency

**Description:** OPEN documentation mentions mode 'A' for append but doesn't document it

**Affected files:**
- `docs/help/common/language/statements/open.md`

**Details:**
In printi-printi-using.md Remarks section:
'PRINT# writes data to a sequential file opened for output (mode "O") or append (mode "A").'

But open.md only documents three modes:
'- **"O"** - specifies sequential output mode
- **"I"** - specifies sequential input mode
- **"R"** - specifies random input/output mode'

Mode 'A' for append is not documented in OPEN.

---
#### documentation_inconsistency

**Description:** Inconsistent file number syntax in documentation

**Affected files:**
- `docs/help/common/language/statements/inputi.md`

**Details:**
inputi.md syntax shows:
'LINE INPUT#<file number>,<string variable>'

But other file I/O statements like open.md show:
'OPEN <mode>, [#]<file number>,<filename>, [<reclen>]'

And put.md shows:
'PUT [#]<file number>[,<record number>]'

The # symbol is shown as optional [#] in some statements but required in LINE INPUT#. This inconsistency in notation may confuse users about whether # is required.

---
#### documentation_inconsistency

**Description:** RESUME and RESTORE have similar names but completely different purposes, documentation could cross-reference to prevent confusion

**Affected files:**
- `docs/help/common/language/statements/resume.md`
- `docs/help/common/language/statements/restore.md`

**Details:**
RESUME is for error handling continuation, RESTORE is for DATA pointer reset. Both start with 'RES' and could be confused by new users. Neither doc mentions the other to clarify the difference.

---
#### documentation_inconsistency

**Description:** Settings documentation spread across multiple files with potential for inconsistency in setting names and descriptions

**Affected files:**
- `docs/help/common/language/statements/setsetting.md`
- `docs/help/common/language/statements/showsettings.md`
- `docs/help/common/settings.md`

**Details:**
SETSETTING and SHOWSETTINGS docs are brief and refer to settings.md for details. However, settings.md is comprehensive. Risk of drift if settings are added/changed and not updated in all three places.

---
#### documentation_inconsistency

**Description:** WRITE and WRITE# documentation titles inconsistent with naming convention

**Affected files:**
- `docs/help/common/language/statements/write.md`
- `docs/help/common/language/statements/writei.md`

**Details:**
write.md has title: 'WRITE (Screen)'
writei.md has title: 'WRITE# (File)'

The '#' symbol placement is inconsistent. Should be 'WRITE (Screen)' and 'WRITE# (File)' or 'WRITE' and 'WRITE #' (with space). Current format mixes conventions.

---
#### documentation_inconsistency

**Description:** Settings documentation shows conflicting information about settings storage location

**Affected files:**
- `docs/help/common/settings.md`

**Details:**
Settings Storage section says:
'- Linux/Mac: ~/.mbasic/settings.json
- Windows: %APPDATA%\mbasic\settings.json
- Project: .mbasic/settings.json in project directory'

But the 'Settings Scope' section mentions 'File scope (highest priority) - Per-file settings (future feature)' which suggests a fourth storage location not listed in Settings Storage section.

---
#### documentation_inconsistency

**Description:** TRON-TROFF documentation filename doesn't match standard naming convention

**Affected files:**
- `docs/help/common/language/statements/tron-troff.md`

**Details:**
Most statement docs use lowercase with hyphens (e.g., 'for-next.md', 'if-then-else-if-goto.md', 'while-wend.md'). But this file is 'tron-troff.md' (all lowercase) while the title is 'TRON-TROFF' (all uppercase). Should be consistent with other multi-word statement docs.

---
#### documentation_inconsistency

**Description:** Keyboard shortcuts table incomplete in curses documentation

**Affected files:**
- `docs/help/common/ui/curses/editing.md`
- `docs/help/common/ui/tk/index.md`

**Details:**
curses/editing.md has a 'Keyboard Shortcuts' section that says 'See your UI's keyboard shortcuts documentation for the complete list' and lists only 5 shortcuts (Ctrl+R, Ctrl+N, Ctrl+S, Ctrl+L, Ctrl+P). The tk/index.md has a similar section with 6 shortcuts (adds Ctrl+F). However, extensions.md mentions Ctrl+B, Ctrl+T, and Ctrl+K for Curses which are not documented in the curses editing guide. This creates an incomplete reference.

---
#### documentation_inconsistency

**Description:** UI selection paths inconsistent between index and UI docs

**Affected files:**
- `docs/help/index.md`
- `docs/help/common/ui/tk/index.md`

**Details:**
index.md lists UI paths as 'Tk (Desktop GUI)](ui/tk/index.md)', 'Curses (Terminal)](ui/curses/index.md)', 'Web Browser](ui/web/index.md)', 'CLI (Command Line)](ui/cli/index.md)' (using ui/ prefix). However, tk/index.md references other docs with paths like '../../getting-started.md' and '../../language/statements/index.md' which use common/ prefix. The path structure is inconsistent - some docs use ui/ and some use common/ui/.

---
#### documentation_inconsistency

**Description:** Different variable type documentation between Curses and CLI

**Affected files:**
- `docs/help/ui/curses/variables.md`
- `docs/help/ui/cli/variables.md`

**Details:**
cli/variables.md documents four variable types: "Integer Variables (A%), Single-Precision (A!), Double-Precision (A#), String Variables (A$)"

curses/variables.md in the "Variable Types Display" section shows: "Integer, String, Single (!), Double (#), Array"

Both documents cover the same types but with different formatting and organization. The CLI doc provides examples for each type, while Curses doc focuses on display format. This inconsistency in presentation could confuse users switching between UIs.

---
#### documentation_inconsistency

**Description:** Placeholder documentation not replaced with actual content

**Affected files:**
- `docs/help/ui/common/running.md`
- `docs/help/ui/curses/running.md`

**Details:**
common/running.md is marked as "PLACEHOLDER - Documentation in progress" and says "This page will cover: - How to run BASIC programs - RUN command - Program execution - Stopping programs - Continuing after STOP"

However, curses/running.md already provides detailed documentation for these topics specific to the Curses UI. The common/running.md placeholder should either be completed with UI-agnostic content or removed, as it currently provides no value and creates confusion.

---
#### documentation_inconsistency

**Description:** Inconsistent help keyboard shortcut documentation

**Affected files:**
- `docs/help/ui/curses/help-navigation.md`
- `docs/help/ui/curses/quick-reference.md`

**Details:**
help-navigation.md states: "Press **^F** (Ctrl+F) anytime to open help."

quick-reference.md lists: "^F | Help (with search)"

feature-reference.md states: "Help Command (?) Display the main help screen with keyboard shortcuts and feature overview. Press ? to open help."

There's confusion about whether help is opened with Ctrl+F or ? key. Both may be valid, but the documentation should clarify that both shortcuts exist if that's the case.

---
#### documentation_inconsistency

**Description:** Inconsistent description of auto-numbering increment configurability

**Affected files:**
- `docs/help/ui/web/getting-started.md`
- `docs/help/ui/web/web-interface.md`

**Details:**
getting-started.md states: "Lines increment by 10 automatically" without mentioning configurability in the initial description.

web-interface.md states: "Successive lines auto-increment: next line becomes 20, 30, 40, etc. (increment is configurable)"

While getting-started.md does mention Settings later, the initial description should be consistent about configurability being available.

---
#### documentation_inconsistency

**Description:** Inconsistent menu structure documentation

**Affected files:**
- `docs/help/ui/web/getting-started.md`
- `docs/help/ui/web/index.md`

**Details:**
getting-started.md lists menu bar as: "File - New, Open, Save, Save As, Recent Files, Exit"

index.md does not mention Save/Save As in File menu, and getting-started.md's File Operations section describes Save as triggering browser downloads, not traditional save operations.

The menu structure should be consistently documented across all files.

---
#### documentation_inconsistency

**Description:** Library statistics count mismatch with category descriptions

**Affected files:**
- `docs/library/index.md`

**Details:**
The main index states: 'Library Statistics: 202 programs from the 1970s-1980s'

However, when counting the programs listed in the category index pages:
- Telecommunications: 5 programs listed
- Utilities: 18 programs listed

Without access to all category index files, cannot verify if the total of 202 is accurate across all 9 categories. This is a potential inconsistency that should be verified.

---
#### documentation_inconsistency

**Description:** Inconsistent help key command documentation

**Affected files:**
- `docs/user/QUICK_REFERENCE.md`

**Details:**
In the 'Editor Commands' section, the help command is listed as:
'Ctrl+P | Help | Open help browser'

But in the 'Help System' section, it states:
'Ctrl+P | Anywhere | Open help browser'

And in the 'More Information' section at the bottom:
'Press `^P` (or `^F`) within the Curses UI to access the built-in help system'

This introduces Ctrl+F as an alternative that wasn't mentioned in the main command tables, creating potential confusion about which key(s) actually open help.

---
#### documentation_inconsistency

**Description:** Duplicate installation documentation with redirect

**Affected files:**
- `docs/user/INSTALL.md`
- `docs/user/INSTALLATION.md`

**Details:**
There are two installation documentation files:
1. docs/user/INSTALL.md - Contains full installation instructions
2. docs/user/INSTALLATION.md - Contains only a redirect note pointing to INSTALL.md

The INSTALLATION.md file states: 'This file exists for compatibility with different documentation linking conventions. All installation documentation has been consolidated in [INSTALL.md](INSTALL.md).'

While this is intentional for compatibility, it creates potential maintenance issues if links in other documents point to INSTALLATION.md instead of INSTALL.md. All documentation should consistently reference INSTALL.md as the canonical source.

---