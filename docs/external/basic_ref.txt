MBASIC VT180, VS.21 
BASIC-80 REFERENCE MANUAL 
AA-P226A-TV 
MBASIC VT180, VS.21 
BASIC-80 REFERENCE MANUAL 
AA-P226A-TV 
developed by 
MICROSOFT CORPORATION 
Bellevue, Washing ton 
DIGITAL EQUIPMENT CORPORATION 
Maynard, Massachusetts 
The information in this document is subject to change 
without notice and should not be construed as a com
mitment by Digital Equipment Corporation. Digital 
Equipment Corporation assumes no responsibility for any 
errors that may appear in this document. 
The software described in this document is furnished 
under a license and may only be used or copied in 
accordance with the terms of such license. 
No responsibility is assumed for the use or reliability 
of software by DIGITAL or its affiliated companies. 
Copyright G 1979, MICROSOFT CORPORATION 
Licensed to DIGITAL EQUIPMENT CORPORATION, 
Maynard, Massachusetts. 
The following are trademarks of Digital Equipment 
Corporation: 
ASSIST 
COMPUTER LABS 
COMTEX 
DATATRIEVE 
DDT 
DEC 
DECCOMM 
DECmate 
DECnet 
DECSYSTEM-IO 
DECSYSTEM-20 
DECtape 
DECUS 
DECwriter 
DIBOL 
DIGITAL 
EDUsystem 
FLIP CHIP 
FOCAL 
lAS 
INDAC 
ITPS-IO 
LAB-8 
MASSBUS 
OMNIBUS 
OS/8 
PDP 
PDT 
PHA 
RSTS 
RSX 
RTS-8 
SBI 
TMS-II 
TRAX . 
TYPESET-8 
TYPESET-II 
UNIBUS 
VAX 
VMS 
VT 
Work Processor 
VTl80 
CP/M is a trademark of Digital Research 
PRODUCT EXCEPTION REPORTING SERVICE: 
If, prior to SEPTEMBER 1, 1983, the customer encounters a problem 
wi th the software. as orig inally furnished a Product Exception 
Report may be sub~itted to: 
Digital Equipment Corporation 
BOX A 
146 Main Street 
Maynard, MA 01754 
Throug h the software authors, DIGITAL wi 11, wi thout add i tional 
charg e, respond to the reported error in the current unaltered 
release of the software by issuing any known correction informa
tion to the customer reporting the problem and/or issuing notice 
of the availability of corrected code. However, DIGITAL makes no 
representations or guarantees that such a response will be forth
coming and DIGITAL assumes no responsibility or liability for 
such a response or the accuracy thereof. 
WARRANTY: 
NONE. 
THIS SOFTWARE PRODUCT IS PROVIDED "AS IS". 

IDmDomo EXTERNAL APPLICATION SOFTWARE LIBRARY PAGE OF 
PRODUCT EXCEPTION REPORT (PER) ----_EASE TYPE 
ROGRAM OR DOCUMENT TITLE lOA NUMBER 10PERATING SYSTEM IVERSION 
I DATE 
AN THE PROBLEM BE REPRODUCED AT WILL? YES 0 NO 
0 
PU TYPE \MEMORY SIZE IDISTRIBUTION MEDIUM \SYS DEVICE 
I 
I IMAGTAPE 0 ATTACHMENTS 
FLOPPY DISKS 0 LISTING 0 DECTAPE II 0 
NAME: 
FIRM: 
ADDRESS: 
CUST. NO: 
U!3MITTED BY: 
lATE RECEIVED (MAIL) 
I-01613-07-0000(3E9) 
ALL SUBMISSIONS BECOME THE PROPERTY OF DIGITAL EQUIPMENT CORPORATION 
PHONE: 
\ DATE TO AUTHOR 
Mail To: 
Digital Equipment Corporation 
Box A 146 Main Street 
Maynard, MA 01754 
"If received prior to the PER expiration date of the product, Digital will, 
thru the product author(s). respond to a reported error in the current 
unaltered release of the software by issuing any known correction 
information to the customer reporting the problem and/or issuing 
notice of the availability of corrected code. However, Digital makes no 
representations or guarantees that such a response will be forthcoming 
and Digital assumes no responsibility or liability for such a response 
or the accuracy thereof. Except as specified in this paragraph, Digital 
does not support or maintain the software." 
\ DATE RECEIVED FROM AUTHOR \ DATE ANSWERED 

basic-80 
reference 
manual 
This manual is a reference for Microsoft's BASIC-80 language, release 5.0 and later. 
There are significant differences between the 5.0 release of BASIC-80 and the previous releases 
(release 4.51 and earlier). If you have programs written under a previous release of BASIC-80, 
check Appendix A for new features in 5.0 that may affect execution. 
Information in this document is subject to change without notice and does not represent a 
commitment on the part of Microsoft. The software described in this document is 
furnished under a license agreement or non-disclosure agreement. The software may be 
used or copied only in accordance with the terms of the agreement. 
(C) Microsoft, 1979 
8101-520-06 
BASIC-80 Reference Manual 
CONTENTS 
INTRODUCTION 
CHAPTER 1 
CHAPTER 2 
CHAPTER 3 
APPENDIX A 
APPENDIX B 
APPENDIX C 
APPENDIX D 
APPENDIX E 
APPENDIX F 
APPENDIX G 
APPENDIX H 
INDEX 
General Information about BASIC-80 
BASIC-80 Commands and Statements 
BASIC-80 Functions 
New Features in BASIC-80. Release 5.0 
BASIC-80 Disk I/O 
Assembly Language Subroutines 
BASIC-80 with the CP/M Operating System 
Converting Programs to BASIC-80 
Summary of Error Codes and Error Messages 
Mathematical Functions 
ASCII Character Codes 
PAGE 
1-1 
2-1 
3-1 
A-I 
B-1 
C-l 
D-l 
E-l 
F-l 
G-l 
H-l 
I-I 

Introduction 
BASIC-80 is the most extensive implementation of BASIC 
available for the 8080 and Z80 microprocessors. In its 
fifth major release (Release 5.0), BASIC-80 meets the ANSI 
qualifications 
for 
BASIC, 
as 
set forth in document 
BSRX3.60-1978. Each release of BASIC-80 consists of three 
upward compatible versions: 
8K, Extended and Disk. This 
manual is a reference for all three versions of BASIC-80, 
release 5.0 and later. This manual is also a reference for 
Microsoft BASIC-86 and the Microsoft BASIC Compiler. 
BASIC-86 
is 
currently available in Extended and Disk 
Standalone versions, which are comparable to the BASIC-80 
Extended and Disk Standalone versions. 
There are significant differences between the 5.0 release of 
BASIC-80 
and the previous releases (release 4.51 and 
earlier). If you have programs written under a previous 
release of BASIC-80, check Appendix A for new features in 
5.0 that may affect execution. 
The manual is divided into three large chapters plus a 
number of appendices. Chapter 1 covers a variety of topics, 
largely pertaining to information representation when using 
BASIC-80. 
every 
Chapter 2 contains the syntax and semantics of 
command 
alphabetically. 
and 
statement 
in 
BASIC-80, 
ordered 
Chapter 3 describes all of BASIC-80~s 
intrinsic functions, also ordered alphabetically. 
The 
appendices contain information pertaining to individual 
operating systems: plus lists of error messages, ASCII 
codes, and math functions: 
and helpful information on 
assembly language subroutines and disk I/O. 

Page 1-1 
CHAPTER 1 
GENERAL INFORMATION ABOUT BASIC-SO 
1.1 INITIALIZATION 
The procedure for initialization will vary with different 
implementations of BASIC-SO. Check the appropriate appendix 
at the back of this manual to determine how BASIC-SO is 
initialized with your operating system. 
1.2 MODES OF OPERATION 
When BASIC-SO is initialized, it types the prompt "Ok". 
"Ok" means BASIC-SO is at command level, that is, it is 
ready to accept commands. At this point, BASIC-SO may be 
used in either of two modes: 
the direct mode or the 
indirect mode. 
In the direct mode, BASIC statements and commands are not 
preceded by line numbers. 
They are executed as they are 
entered. Results of arithmetic and logical operations may 
be 
displayed immediately and stored for later use, but the 
instructions themselves are lost after execution. This mode 
is 
useful 
for 
debugging and for using BASIC as a 
"calculator" for quick computations that do not require a 
complete program. 
The indirect mode is the mode used 
Program lines are preceded by line 
memory. 
The program stored in 
entering the RUN command. 
for 
entering programs. 
numbers and are stored in 
memory is executed by 
1.3 LINE FORMAT 
Program lines in a BASIC program have the following format 
(square brackets indicate optional) : 
nnnnn BASIC statement[:BASIC statement .•. ] <carriage return> 
GENERAL INFORMATION ABOUT BASIC-80 
Page 1-2 
At the proqrammer"'s option, more than one BASIC statement 
may be placed on a line, but each statement on a line must 
be separated from the last by a colon. 
A BASIC program line always begins with a line number, ends 
with a carriage return, and may contain a maximum of: 
72 characters in 8K BASIC-80 
255 characters in Extended and Disk BASIC-80. 
In Extended and Disk versions, it is possible to extend a 
logical line over more than one physical line by use of the 
terminal"'s <line feed> key. <Line feed> lets you continue 
typing a logical line on the next physical line without 
entering a <carriage return>. (In the 8K version, <line 
feed> has no effect.) 
1.3.1 Line Numbers 
Every BASIC program line begins with a line number. 
Line 
numbers indicate the order in which the program lines are 
stored in memory and are' also used as references when 
branching and editing. Line numbers must be in the range a 
to 65529. In the Extendedi and Disk versions, a per iod (.) 
may be used in EDIT, LIST, AUTO and DELETE commands to refer 
to the current line. 
GENERAL INFORMATION ABOUT BASIC-SO 
Page 1-3 
1.4 CHARACTER SET 
The BASIC-SO character set is comprised of alphabetic 
characters, numeric characters and special characters. 
The alphabetic characters in BASIC-SO are the upper case and 
lower case letters of the alphabet. 
The numeric characters in BASIC-SO are the digits 0 through 
9. 
The following special characters and terminal keys are 
recognized by BASIC-SO: 
Character 
= 
+ 
/ 
* 
,. 
( 
) 
% 
i 
$ 
[ 
] 
, 
. 
~ 
& 
? 
< 
> 
\ 
@ 
<rubout> 
<escape> 
<tab> 
<line feed> 
<carriage 
return> 
Name 
Blank 
Equal sign or assignment symbol 
Plus sign 
Minus sign 
Asterisk or multiplication symbol 
Slash or division symbol 
Up arrow or exponentiation symbol 
Left parenthesis 
Right parenthesis 
Percent 
Number (or pound) sign 
Dollar sign 
Exclamation point 
Left bracket 
Right bracket 
Comma 
Period or decimal point 
Single quotation mark (apostrophe) 
Semicolon 
Colon 
Ampersand 
Question mark 
Less than 
Greater than 
Backs1ash or integer division symbol 
At-sign 
Underscore 
Deletes last character typed. 
Escapes Edit Mode subcommands. 
See Section 2.16. 
Moves print position to next tab stop. 
Tab stops are every eight columns. 
Moves to next, physical line. 
Terminates input of a line. 
GENERAL INFORMATION ABOUT BASIC-80 
1.4.1 Control Characters 
The following control characters are in BASIC-80: 
Contro1-A 
Contro1-C 
Page 1-4 
Enters Edit Mode on the line being typed. 
Interrupts program execution and returns to 
Contro1-G 
Contro1-B 
Contro1-I 
Contro1-0 
Contro1-R 
Contro1-S 
Contro1-Q 
Contro1-U 
BASIC-80 command level. 
Rings the bell at the terminal. 
Backspace. Deletes the last character typed. 
Tab. 
Tab stops are every eight columns. 
Ba1ts 
program 
continues. 
output. 
A 
output 
second 
while 
Contro1-0 
execution 
restarts 
Retypes the line that is currently being 
typed. 
Suspends program execution. 
Resumes program execution after a Contro1-S. 
Deletes the line that is currently being 
typed. 
1.5 CONSTANTS 
Constants are the actual values BASIC uses during execution. 
There are two types of constants: string and numeric. 
A string constant is a sequence of up to 255 
alphanumeric 
characters enclosed in double quotation marks. 
string constants: 
"HELLO" 
"$25,000.00" 
Examples of 
"Number of Employees" 
Numeric constants are positive or negative numbers. Numeric 
constants in BASIC cannot contain commas. There are five 
types of numeric constants: 
1. 
Integer constants 
2. 
Fixed Point 
Whole numbers between -32768 and 
+32767. 
Integer constants do not 
have decimal points. 
Positive or negative real numbers, 
constants 
i.e., numbers that contain decimal 
points. 
GENERAL INFORMATION ABOUT BASIC-80 
3. 
Floating Point 
Page 1-5 
Positive or negative numbers repre
constants 
4. 
5. 
Hex constants 
Octal constants 
sented in exponential form (similar 
to 
scientific 
notation). 
A 
floating point constant consists of 
an optionally signed integer or 
fixed point number (the mantissa) 
followed by the letter E and an 
optionally signed 
integer 
(the 
exponent). The allowable range for 
floating point constants is, 10-38 
to 10+38. 
Examples: 
235.988E-7 = .0000235988 
2359E6 = 2359000000 
(Double preclslon floating point 
constants use the letter D instead 
of E. See Section 1.5.1.) 
Hexadecimal numbers with the prefix 
&H. 
Examples: 
&H76 
&H32F 
Octal numbers with the prefix &0 or 
Se. 
Examples: 
&0347 
&1234 
1.5.1 Single And Double Precision ~ !££ Numeric Constants 
In the 8K version of BASIC-80, all numeric constants are 
single precision numbers. They are stored with 7 digits of 
precision, and printed with up to 6 digits. 
In 
the 
Extended and Disk versions, 
\ 
however, \ numeric 
constants may be either single precision or double precision 
numbers. with double precision, the numbers are stored with 
16 digits of precision, and printed with up to 16 digits. 
GENERAL INFORMATION ABOUT BASIC-80 
A single precision constant is 
has: 
Page 1-6 
any numeric constant that 
1. 
2. 
3. 
seven or fewer digits, 
exponential form using 
a 
trailing exclamation 
A double precision constant is 
has: 
1. 
2. 
3. 
eight or more digits, 
exponential form using 
a 
trailing number sign 
or 
E, or 
point (1) 
any numeric constant that 
or 
0, or 
(#) 
Examples: 
Single Precision Constants 
46.8 -1.09E-06 
3489.0 
22.5! 
1. 6 
VARIABLES 
Double Precision Constants 
345692811 -1.09432D-06 
3489.0# 
7654321.1234 
Variables are names used to represent values that are used 
in a BASIC program. The value of a variable may be assigned 
explicitly by the programmer, or it may be assigned as the 
result of calculations in the program. Before a variable is 
assigned a value, its value is assumed to be zero. 
1.6.1 Variable Names And Declaration Characters 
BASIC-80 variable names may be any length, however, in the 
8K 
version, only the first two characters are significant. 
In the Extended and Disk versions, up to 40 characters are 
significant. 
The characters allowed in a variable name are 
letters and numbers, and the decimal point is allowed in 
Extended and Disk variable names. The first character must 
be a letter. Special type declaration characters are also 
allowed -- see below. 
A variable name may not be a reserved word. 
The 
Extended 
and Disk versions allow embedded reserved words; the 8K 
version does not. If a variable begins with FN, it is 
assumed to be a call to a user-defined function. Reserved 
words include all BASIC-80 commands, statements, function 
GENERAL INFORMATION ABOUT BASIC-80 
Page 1-7 
names and operator names. 
Variables may represent either a numeric value or a string. 
String variable names are written with a dollar sign ($) as 
the last character. For example: A$ = "SALES REPORT". The 
dollar sign is a variable type declaration character, that 
is, it "declares" that the variable will represent a string. 
In the Extended and Disk versions, numeric variable names 
may declare integer, single or double precision values. 
(All numeric values in 8K are single precision.) The type 
declaration characters for these variable names are as 
follows: 
% 
* 
Integer variable 
Single precision variable 
Double precision variable 
The default type for a numeric variable name is single 
precision. 
Examples of BASIC-80 variable names follow. 
In Extended and Disk versions: 
PIt 
declares a double precision value 
MINIMUM! 
LIMIT% 
declares a single precision value 
declares an integer value 
In 8K, Extended and Disk versions: 
N$ 
declares a string value 
ABC 
represents a single precision value 
In the Extended and Disk versions of BASIC-80, there is a 
second method by which variable types may be declared. The 
BASIC-80 statements DEFINT, DEFSTR, DEFSNG and DEFDBL may be 
included in a program to declare the types for certain 
variable names. These statements are described in detail in 
Section 2.12. 
1.6.2 Array Variables 
An array is a group or table of values referenced by the 
same variable name. Each element in an array is referenced 
by an array variable that is subscripted with an integer or 
an 
integer expression. An array variable name has as many 
subscripts as there are dimensions in the array. 
For 
example V(lO} would reference a value in a one-dimension 
array, T(1,4) would reference a value in a two-dimension 
array, and so on. The maximum number of dimensions for an 
GENERAL INFORMATION ABOUT BASIC-80 
Page 1-8 
array is 255. The maximum number of elements per dimension 
is 32767. 
1.7 TYPE CONVERSION 
When necessary, BASIC will convert a numeric constant from 
one type to another. 
should be kept in mind. 
1. 
The 
following rules and examples 
If a numeric constant of one type is set equal to a 
numeric variable of a different type, the number 
will be stored as the type declared in the variable 
name. 
(If 
a 
str ing var iable is set equal to a 
numeric value or vice versa, a "Type mismatch" 
error occurs.) 
Example: 
10 A% = 23.42 
20 PRINT A% 
RUN 
23 
2. 
3. 
During expression evaluation, all of the operands 
in 
an 
arithmetic or relational operation are 
converted to the sane degree of precision, i.e., 
that of the most precise operand. Also, the result 
of an arithmetic operation is returned to this 
degree of precision. 
Examples: 
10 D* = 6*/7 
20 PRINT D* 
RUN 
The arithmetic was performed 
in double precision and the 
result was returned in D* 
.8571428571428571 as a double precision value. 
10 D = 6*/7 
The arithmetic was performed 
20 PRINT D 
RUN 
.857143 
in double precision and the 
result was returned to D (single 
precision variable), rounded and 
printed as a single precision 
value. 
Logical operators (see Section 1.8.3) convert their 
operands to integers and return an integer result. 
Operands must be in the range -32768 to 32767 or an 
"Overflow" error occurs. 
GENERAL INFORMATION ABOUT BASIC-SO 
4. 
Page 1-9 
When a floating point value is converted to an 
integer, the fractional portion is rounded. 
Example: 
10 C% = 55.SS 
20 PRINT C% 
RUN 
56 
5. 
If a double prec1s1on variable is assigned a single 
prec1s10n value, only the first seven digits, 
rounded, of the converted number will be valid. 
This is because only seven digits of accuracy were 
supplied with the single precision value. 
absolute 
The 
value of the difference between the 
printed double precision number and the original 
single precision value will be less than 6.3E-S 
times the original single precision value. 
Example: 
10 A = 2.04 
20 Bi = A 
30 PRINT A;Bi 
RUN 
2.04 2.03999996lS53027 
1.S EXPRESSIONS AND OPERATORS 
An expression may be simply a string or numeric constant, or 
a 
variable, or it may combine constants and variables with 
operators to produce a single value. 
Operators perform mathematical or logical operations on 
values. 
The operators provided by BASIC-SO may be divided 
into four categories: 
1. 
Arithmetic 
2. 
3. 
4. 
Relational 
Logical 
Functional 
GENERAL INFORMATION ABOUT BASIC-80 
Page 1-10 
1.8.1 Arithmetic Operators 
The arithmetic operators, in order of precedence, are: 
Operator 
Operation 
Exponentiation 
Negation 
*,/ 
+,
Multiplication, Floating 
Point Division 
Sample Expression 
X"Y -x 
x*y 
X/y 
Addition, Subtraction 
To change the order in which the operations 
use 
parentheses. 
Operations 
within 
performed first. Inside parentheses, the 
X+y 
are performed, 
parentheses are 
usual order of 
operations is maintained. 
Here are some sample algebraic expressions and their BASIC 
counterparts. 
Algebraic Expression 
X+2Y 
Y 
X--Z 
XY 
Z
X+Y -z 
(X2) y 
yZ 
X 
X(-Y) 
BASIC Expression 
X+Y*2 
X-y/z 
X*y/z 
(X+Y)/Z 
(X"2)"Y 
X" (y" Z) 
X*(-Y) Two consecutive 
operators must 
be separated by 
parentheses. 
1.8.1.1 Integer Division And Modulus Arithmetic 
Two additional operators are-available in Extended and Disk 
versions 
of 
BASIC-80: 
Integer division and modulus 
arithmetic. 
Integer division is denoted by the 
operands are rounded to integers 
baskslash (\). 
The 
(must be in the range -32768 to 32767) before the division 
quotient is truncated to an integer. 
is performed, and the 
GENERAL INFORMATION ABOUT BASIC-80 
For example: 
10\4 = 2 
25.68\6.99 = 3 
The precedence of 
integer 
division 
Page 1-11 
is 
just 
after 
multiplication and floating point division. 
Modulus arithmetic is denoted by the operator MOD. It gives 
the 
integer value that is the remainder of an integer 
division. For example: 
10.4 MOD 4 = 2 (10/4=2 with a remainder 2) 
25.68 MOD 6.99 = 5 (26/7=3 with a remainder 5) 
The precedence of modulus arithmetic is just after integer 
division. 
1.8.1.2 Overflow And Division ~ Zero 
If, during the evaluation of an expression, a division by 
zero is encountered, the "Division by zero" error message is 
displayed, machine infinity with the sign of the numerator 
is 
supplied as the result of the division, and execution 
continues. If the evaluation of an exponentiation results 
in 
zero being raised to a negative power, the "Division by 
zero" error message is displayed, positive machine infinity 
is 
supplied as the result of the exponentiation, and 
execution continues. 
If 
overflow occurs, the "Overflow" error message is 
displayed, machine infinity with the algebraically correct 
sign is supplied as the result, and execution continues. 
1.8.2 Relational Operators 
Relational operators are used to compare two values. 
The 
result of the comparison is .either "true" (-1) or "false" 
(0). 
This result may then used to make a decision regarding 
program flow. 
(See IF, Section 2.26.) 
GENERAL INFORMATION ABOUT BASIC-80 
°Eerator 
= 
<> 
< 
> 
<= 
>= 
Relation Tested 
Equality 
Inequality 
Less than 
Greater than 
Less than or equal to 
Page 1-12 
ExEression 
X=Y 
X<>Y 
X<Y 
X>Y 
X<=Y 
X>=Y 
Greater than or equal to 
(The equal sign is also used to assign a value to a 
variable. See LET, Section 2.30.) 
When arithmet.ic and relational operators are combined in one 
expression, the ari,thmetic is always performed first. For 
example, the expression 
X+Y < (T-l)/Z 
is-true if the value of X plus Y is less than the value of 
T-l divided by Z. More examples: 
IF SIN(X)<O GOTO 1000 
IF I MOD J <> 0 THEN K=K+l 
1.8.3 Logical 0Eerators 
Logical operators perform tests on multiple relations, bit 
manipulation, or Boolean operations. The logical operator 
returns a bitwise result which is either "true" (not zero) 
or "false" (zero). 'In an expression, logical operations are 
performed after arithmetic and relational operations. 
The 
outcome of a logical operation is determined as shown in the 
following table. The operators are listed in order of 
precedence. 
GENERAL INFORMATION ABOUT BASIC-80 
NOT 
AND 
OR 
XOR 
IMP 
EQV 
X 
1 
a 
X 
1 
1 
a 
a 
X 
1 
1 
o 
a 
X 
1 
1 
o 
a 
X 
1 
1 
a 
o 
X 
1 
1 
a 
a 
NOT X 
a 
1 
y 
1 
a 
1 
a 
Y 
1 
o 
1 
a 
X AND Y 
1 
a 
o 
a 
X OR Y 
1 
1 
1 
o 
X XOR Y 
Y 
1 
o 
1 
a 
Y 
1 
a 
1 
a 
y 
1 
o 
1 
o 
a 
1 
1 
a 
X IMP Y 
1 
o 
1 
1 
X EQV Y 
1 
o 
o 
1 
Page 1-13 
Just as the relational operators can be used to make 
decisions regarding program flow, logical operators can 
connect two or more relations and return a true or false 
value to be used in a decision (see IF, Section 2.26). For 
example: 
IF D<200 AND F<4 THEN 80 
IF I>10 OR K<O THEN 50 
IF NOT P THEN 100 
Logical operators work by converting their operands to 
sixteen bit, signed, two~scomplement integers in the range -32768 to +32767. (If the operands are not in this range, 
an error results.) If both operands are supplied as a or -1, 
logical operators return a or -1. The given operation is 
GENERAL INFORMATION ABOUT BASIC-SO 
Page 1-14 
performed on these integers in bitwise fashion, i.e., each 
bit of the result is determined by the corresponding bits in 
the two ope rands '. 
Thus, it is possible to use logical operators to test bytes 
for 
a 
particular bit pattern. 
For 
instance, the AND 
operator may be used to "mask" all but one of the bits of a 
status byte at a machine I/O port. The OR operator may be 
used to "merge" two bytes to create a particular 'binary 
value. The following examples will help demonstrate how the 
63 AND 16=16 
logical operators work. 
63 = binary 111111 and 16 = binary 
15 AND 14=14 -1 AND S=S 
4 OR 2=6 
10 OR 10=10 -lOR -2=-1 
NOT X=- (X+1) 
10000, so 63 AND 16 = 16 
15 = binary 1111 and 14 = binary 1110, 
so 15 AND 14 = 14 (binary 1110) -1 = binary 1111111111111111 and 
S = binary 1000, so -1 AND S = S 
4 = binary 100 and 2 = binary 10, 
so 4 OR 2 = 6 (binary 110) 
10 = binary 1010, so 1010 OR 1010 = 
1010 (10) -1 = binary 1111111111111111 and -2 = binary 1111111111111110, 
so -lOR -2 = -1. The bit 
complement of sixteen zeros is 
sixteen ones, which is the 
two~s complement represen,tation of -1. 
The two~s complement of any integer 
is the bit complement plus one. 
1.S.4 Functional Operators 
A function is used in an expression to call a predetermined 
operation that is to be performed on an operand. BASIC-SO 
has "intrinsic" functions that reside in the system, such as 
SQR 
(square root) or SIN (sine). 
All of BASIC-SO"'s 
intrinsic functions are described in Chapter 3 • 
• 
BASIC-SO also allows "user defined" functions that are 
written by the programmer. See DEF FN, Section 2.11. 
GENERAL INFORMATION ABOUT BASIC-SO 
1.S.5 String Operations 
Strings may be concatenated using +. For example: 
10 A$="FILE" : B$="NAME" 
20 PRINT A$ + B$ 
30 PRINT "NEW " + A$ + B$ 
R~ 
FILENAME 
Page 1-15 
NEW FILENAME 
Strings may be compared using the same relational oper~tors 
that are used with numbers: 
= 
<> 
< 
> 
<= 
>= 
String comparisons are made by taking one character at a 
time from each string and comparing the ASCII codes. If all 
the ASCII codes are the same, the strings are equal. If the 
ASCII codes differ, the lower code number precedes the 
higher. If, during string comparison, the end of one string 
is 
reached, the shorter string is said to be smaller. 
Leading and trailing blanks are significant. Examples: 
"AA" < "AB" 
"FILENAME" = "FILENAME" 
"X&" > "Xi" 
"CL " > "CL" 
"kg" > "KG" 
"SMYTH" < "SMYTHE" 
B$ < "9/l2/7S" 
where B$ = "S/12/7S" 
Thus, string comparisons can be used to test string values 
or 
to 
alphabetize strings. 
All string constants used in 
comparison expressions must be enclosed in quotation marks. 
1.9 INPUT EDITING 
If an incorrect. character is entered as a line is being 
typed, it can be deleted with the RUBOUT key or with 
Control-H. Rubout surrounds the deleted character(s) with 
backslashes, and Contro1-H has the effect of backspacing 
over a character and erasing it. Once a character(s) has 
been deleted, simply continue typing the line as desired. 
To delete a line that is in the process of being typed, type 
Control-U. 
A carriage return is executed automatically 
after the line is deleted. 
To correct program lines for a program that is currently in 
memory, simply retype the line using the same line number. 
BASIC-SO will automatically replace the old line with the 
new line. 
GENERAL INFORMATION ABOUT BASIC-SO 
Page 1-16 
More sophisticated editing capabilities are provided in the 
Extended and Disk versions of BASIC-SO. See EDIT, Section 
2.16. 
To delete the entire program that is currently residing in 
memory, enter the NEW command. (See Section 2.41.) NEW is 
usually used to clear memory prior to entering a new 
program. 
1.10 ERROR MESSAGES 
If BASIC-SO detects an error that causes program execution 
to 
terminate, an error message is printed. 
version, only the error code is printed. 
In the SK 
In 
the Extended 
and Disk versions, the entire error message is printed. For 
a complete list of BASIC-SO error codes and error messages, 
see Appendix 
Page 2-1 
CHAPTER 2 
BASIC-SO COMMANDS AND STATEMENTS 
All of the BASIC-SO commands and statements are described in 
this chapter. Each description is formatted as follows: 
Format: 
Versions: 
Purpose: 
Remarks: 
Example: 
Shows the correct format for the instruction. 
See below for format notation. 
Lists the. versions of BASIC-SO 
in which the instruction is available. 
Tells what the instruction is used for. 
Describes in detail how the instruction 
is used. 
Shows sample programs or program segments 
that demonstrate the use of the instruction. 
Format Notation 
Wherever the format for a statement or command is given, the 
following rules apply: 
1. 
Items in capital letters must be input as shown. 
2. 
3. 
4. 
5. 
Items in lower case letters enclosed in angle 
brackets « » are to be supplied by the user. 
Items in square brackets ([ ]) are optional. 
All punctuation except angle brackets and square 
brackets (i.e., commas, parentheses, semicolons, 
hyphens, equal signs) must be included where shown. 
Items followed by an ellipsis ( ••• ) may be repeated 
any number of times (up to the length of the line). 
BASIC-SO COMMANDS AND STATEMENTS 
2.1 AUTO 
Format: 
Versions: 
Purpose: 
AUTO [<line number>[,<increment>]] 
Page 2-2 
Extended, Disk 
To generate a line number automatically after 
Remarks: 
Example: 
every carriage return. 
AUTO begins numbering at <line number> and 
increments 
each 
subsequent line number by 
<increment>. The default for -both values is 10. 
If 
<line number> is followed by a comma but 
<increment> is not specified, the last increment 
specified in an AUTO command is assumed. 
If AUTO generates a line number that is already 
being used, an asterisk is printed after the 
number to warn the user that any input will 
replace the existing line. However, typing a 
carriage return immediately after the asterisk 
will save the line and generate the next line 
number. 
AUTO is terminated by typing Control-C. 
The 
line in which Control-C is typed is not saved. 
After Control-C is typed, BASIC returns to 
command level. 
AUTO 100,50 
AUTO 
Generates line numbers 100, 
150, 200 ••• 
Generates line numbers 10, 
20,30,40 ••• 
BASIC-SO COMMANDS AND STATEMENTS 
2.2 CALL 
Format: 
Version: 
Purpose: 
Remarks: 
CALL <variable name>[«argument list»] 
Page 2-3 
Extended, Disk 
To call an assembly language subroutine. 
The CALL statement is one way to transfer 
program flow to an assembly language subroutine. 
(See also the OSR function, Section 3.40) 
<variable name> contains an address that is the 
starting point in memory of the subroutine. 
<variable name> may not be an array variable 
name. 
<argument list> contains the arguments 
that are passed to the assembly language 
subroutine. 
literals. 
<argument list> may not contain 
The CALL statement generates the same calling 
sequence used by Microsoft~s FORTRAN, COBOL and 
BASIC compilers. 
Example: 
110 MYROOT=&HDOOO 
120 CALL MYROOT(I,J,K) 
BASIC-SO COMMANDS AND STATEMENTS 
2.3 CHAIN 
Format: 
Page 2-4 
CHAIN [MERGE] <filename>[,[<line number exp>] 
[,ALL] [,DELETE<range>]] 
Version: 
Purpose: 
Remarks: 
Disk 
To call a program and pass variables to it from 
the current program. 
<filename> is the name of the program that is 
called. Example: 
CHAIN"PROGI" 
<line number exp> is a line number or an 
expression that evaluates to a line number in 
the called program. It is the starting point 
for 
execution of the called program. If it is 
omitted, execution begins at the first line. 
Example: 
CHAIN"PROGI",IOOO 
<line number exp> is not affected by a RENUM 
command. 
With the ALL option, every variable in the 
current program is passed to the called programo 
If 
the ALL option is omitted, the current 
program must contain a COMMON statement to list 
the variables that are passed. See Section 2.7. 
Example: 
CHAIN"PROGl",IOOO,ALL 
If the MERGE option is included, it allows a 
subroutine to be brought into the BASIC program 
as an overlay. That is, a MERGE operation is 
performed with the current program and the 
called program. The called program must be an 
ASCII file if it is to be MERGEd. Example: 
CHAIN MERGE"OVRLAY",lOOO 
After an overlay is 
desirable to delet~ 
be brought in. 
option. Example: 
To 
brought in, it is usually 
it so that a new overlay may 
do 
this, use the DELETE 
CHAIN MERGE"OVRLAY2",1000,DELETE 1000-5000 
The line numbers in <range> are affected by the 
RENUM command. 
BASIC-SO COMMANDS AND STATEMENTS 
NOTE: 
Page 2-5 
The Microsoft BASIC compiler does not support 
the ALL, MERGE, and DELETE options to CHAIN. If 
you wish to maintain compatibility with the 
BASIC compiler, it is recommended that COMMON be 
used to pass variables and that overlays not be 
used. 
NOTE: 
NOTE: 
The CHAIN statement with MERGE option leaves the 
files open and preserves the current OPTION BASE 
setting. 
If the MERGE option is omitted, CHAIN does not 
preserve 
variable 
types 
or 
user-defined 
functions for use by the chained program. 
That 
is, any DEFINT, DEFSNG, DEFDBL, DEFSTR, or DEFFN 
statements containing shared variables must be 
restated in the chained program. 
BASIC-SO COMMANDS AND STATEMENTS 
2.4 CLEAR 
Format: 
Versions: 
Purpose: 
CLEAR [,[<expressionl>] [,<expression2>]] 
Page 2-6 
SK, -Extended, Disk 
To set all numeric variables to zero and all 
string variables to null; and, optionally, 'to 
set the end of memory and the amount of stack 
Remarks: 
NOTE: 
Examples: 
space. 
<expr'essionl> is a memory location which, if 
specified, sets the highest location available 
for use by BASIC-SO. 
<expression2> sets aside stack space for BASIC. 
The default is 256 bytes or one-eighth of the 
available memory, whichever is smaller. 
In previous versions of BASIC-SO, <expressionl> 
set 
the 
amount 
of 
string 
<expression2> set the end of memory. 
space,' and 
BASIC-80, 
release 5.0 and later, allocates string space 
dynamically. An ROut of string space errorR 
occurs only if there is no free memory left for 
BASIC to use. 
CLEAR 
CLEAR ,32768 
CLEAR ,,2000 
CLEAR ,32768,2000 
MICROSOFT BASIC COMMANDS AND STATEMENTS 
2.5 CLOAD 
Page 2-7 
THIS COMMAND IS NOT INCLUDED IN THE DEC VT180 VERSION 
Formats: 
Purpose: 
Remarks: 
NOTE: 
Example: 
CLOAD <filename> 
CLOAD? <filename> 
CLOAD* <array name> 
To load a program or an array from cassette tape 
into memory. 
CLOAD executes a NEW command before it loads the 
program from cassette tape. <filename> is, the 
string expression or the first character of the 
string expression that was specified when the 
program was CSAVEd. 
CLOAD? verifies tapes by comparing the program 
currently in memory with the file on tape that 
has the same filename. If they are the same, 
BASIC prints Ok. If not, BASIC prints NO GOOD. 
CLOAD* loads a numeric array that has been saved 
on 
tape. 
The data on tape is loaded into the 
array called <array name> specified when the 
array was CSAVE*ed. 
CLOAD and CLOAD? are always entered at command 
level as direct· mode commands. CLOAD* may be 
entered at command level or used as a program 
statement. 
Make 
sure the array has been 
DIMensioned before it is loaded. 
BASIC always 
returns to COmmand level after a CLOAD, CLOAD? 
or 
CLOAD* is executed. 
Before a CLOAD is 
executed, make sure the cassette recorder is 
properly connected and in the Play mode, and the 
tape is possitioned correctly. 
See also CSAVE, Section 2.9. 
CLOAD and CSAVE are not included 
implementations of BASIC. 
CLOAD "MAX2" 
Loads file "M" into memory. 
in 
all 
MICROSOFT BASIC COMMANDS AND STATEMENTS 
2.6 CLOSE 
Format: 
Purpose: 
Remarks: 
Page 2-8 
CLOSE[[#]<file number>[,[#]<file number ••• >]] 
To conclude I/O to a disk file. 
<file number> is the number under which the file 
was OPENed. 
A CLOSE with no arguments closes 
all open files. 
The association between a particular file and 
file number terminates upon execution of a 
CLOSE. The file may then be reOPENed using the 
same or a different file number; likewise, that 
file number may now be reused to OPEN any file. 
A CLOSE for a sequential output file writes the 
final buffer of output. 
The END statement and the NEW command always 
CLOSE all disk files automatically. (STOP does 
Example: 
not close disk files.) 
See PART II, Chapter 3, Microsoft BASIC Disk 
I/O, of the Microsoft BASIC User's Guide. 
BASIC-80 COMMANDS AND STATEMENTS 
2.7 COMMON 
Format: 
Version: 
Purpose: 
Remarks: 
COMMON <list of variables> 
Page 2-9 
Disk 
To pass variables to a CHAINed program. 
The COMMON statement is used in conjunction with 
the CHAIN statement. 
COMMON statements may 
appear anywhere in a program, though it is 
recommended that they appear at the beginning. 
The same variable cannot appear in more than one 
COMMON statement. Array variables are specified 
by appending "()" to the variable name. If all 
variables are to be passed, use CHAIN with the 
ALL option and omit the COMMON statement. 
Example: 
100 COMMON A,B,C,D(),G$ 
110 CHAIN "PROG3",10 
• 
BASIC-80 COMMANDS AND STATEMENTS 
2.8 CONT 
Format: 
Versions: 
Purpose: 
CONT 
Page 2-10 
8K, Extended, Disk 
To continue program execution after a Control-C 
has been typed, or a STOP or END statement has 
Remarks: 
Example: 
been executed. 
Execution resumes at the point where the break 
occurred. 
If the break occurred after a prompt 
from an INPUT statement, execution continues 
with the reprinting of the prompt (7 or prompt 
string) • 
CONT is usually used in conjunction with STOP 
for 
debugging. 
When execution is stopped, 
intermediate values may be examined and changed 
using direct mode statements. Execution may be. 
resumed with CONT or a direct mode GOTO, which 
resumes execution at a specified line number. 
With the Extended and Disk versions, CONT may be 
used to continue execution after an error. 
CONT is invalid if the program has been edited 
during the break. 
In 
8K BASIC-80, execution 
cannot be CONTinued if a direct mode error, has 
occurred during the break. 
See example Section 2.61, STOP. 
BASIC-80 COMMANDS AND STATEMENTS 
2.9 
CSAVE 
Page 2-11 
THIS COMMAND IS NOT INCLUDED IN THE DEC VT180 VERSION 
Formats: 
Versions: 
Purpose: 
Remarks: 
NOTE: 
Example: 
CSAVE <string expression> 
CSAVE* <array variable name> 
8K (cassette), Extended (cassette) 
To save the program or an array currently in 
memory on cassette tape. 
Each program or array saved on tape is 
identified by a filename. 
When the command 
CSAVE <string expression> is executed, BASIC-80 
saves the program currently in memory on tape 
and uses the first character in <string 
expression> 
as 
the 
filename. 
<string 
expression> may be more than one character, but 
only 
the first character is used for the 
filename. 
When the command CSAVE* <array variable name> is 
executed, BASIC-80saves the specified array on 
tape. The array must be a numeric array. 
The 
elements of a multidimensional array are saved 
with the leftmost subscript changing fastest. 
CSAVE may be used as a program statement or as a 
direct mode command. 
Before a CSAVE or CSAVE* is executed, make sure 
the cassette recorder is properly connected and 
in the Record mode. 
See also CLOAD, Section 2.5. 
CSAVE and CLOAD are not included 
implementations of BASIC-80. 
CSAVE "TIMER" 
Saves the program currently in memory on 
cassette under filename "T". 
in 
all 
BASIC-80 COMMANDS AND STATEMENTS 
2.10 DATA 
Format: 
Versions: 
Purpose: 
DATA <list of constants> 
Page 2-12 
8K, Extended, Disk 
To store the numeric and string constants that 
are accessed by the program~s READ statement(s). 
(See READ, Section 2.54) 
Remarks: 
DATA statements are nonexecutable and may be 
placed 
anywhere 
in 
the program. 
A DATA 
statement may contain as many constants as will 
fit on a line (separated by commas), and any 
number of DATA statements may be used in a 
program. 
The READ statements access the DATA 
statements in order (by line number) and the 
data contained therein may be thought of as one 
continuous list of items, regardless of how many 
items are on a line or where the "lines are 
placed in the program. 
<list of 
constants> 
may 
contain 
numeric 
constants in any format, i.e., fixed point, 
floating point or integer. 
(No 
numeric 
expressions are allowed in the list.) String 
constants in DATA statements must be surrounded 
by double quotation marks only if they contain 
commas, colons or significant leading or 
trailing spaces. Otherwise, quotation marks are 
not needed. 
The variable type (numeric or string) given in 
the 
READ 
statement 
must 
agree with the 
corresponding constant in the DATA statement. 
DATA statements may be reread from the beginning 
by use of the RESTORE statement (Section 2.57). 
Example: 
See examples in Section 2.54, READ. 
BASIC-80 COMMANDS AND STATEMENTS 
2.11 DEF FN 
Format: 
Page 2-13 
DEF FN<name>[«parameter list>}]=<function definition> 
Versions: 
Purpose: 
Remarks: 
8K, Extended, Disk 
To define and name a function that is written by 
the user. 
<name> must be a legal variable name. 
This 
name, preceded by FN, becomes the name of the 
function. 
<parameter list> is comprised of 
those variable names in the function definition 
that are to be replaced when the function is 
called. 
The items in the list are separated by 
commas. <function definition> is an expression 
that performs the operation of the function. It 
is limited to one line. 
Variable names that 
appear in this expression serve only to define 
the 
function; 
they do not affect program 
variables that have the same name. A variable 
name used in a function definition mayor may 
not appear in the parameter list. If it does, 
the value of the parameter is supplied when the 
function is called. 
Otherwise, the current 
value of the variable is used. 
The variables in the parameter list represent, 
on a one-to-one basis, the argument variables or 
values that will be given in the function call. 
(Remember, in the 8K version only one argument 
is allowed in a function call, therefore the DEF 
FN statement will contain only one variable.) 
In 
Extended and Disk BASIC-80, user-defined 
functions may be numeric or string; in 8K, 
user-defined string functions are not allowed. 
If a type is specified in the function name, the 
value of the expression is forced to that type 
before it is returned to the calling statement. 
If a type is specified in the function name and 
the argument type does not match, a "Type 
mismatch" error occurs. 
A DEF FN statement must be executed before the 
function 
it 
defines may be called. 
If 
a 
function is called before it has been defined, 
an 
"Undefined user function" error occurs. DEF 
FN is illegal in the direct mode. 
BASIC-SO COMMANDS AND STATEMENTS 
Example: 
410 DEF FNAB(X,Y)=XA 3/yA 2 
420 T=FNAB (I, J) 
Line 410 defines the function 
function is called in line 420. 
Page 2-14 
FNAB. 
The 
BASIC-SO COMMANDS AND STATEMENTS 
2.12 DEFINT/SNG/DBL/STR 
Format: 
Versions: 
Purpose: 
DEF<type> <range(s) of letters> 
where <type> is INT, SNG, DBL, or STR 
Extended, Disk 
Page 2-15 
To declare variable types as integer, single 
Remarks: 
Examples: 
precision, double precision, or string. 
A DEFtype statement declares that the variable 
names beginning with the 1etter(s) specified 
will be that type variable. 
However, a type 
declaration character always takes precedence 
over a DEFtype statement in the typing of a 
variable. 
If 
no 
type 
encountered, 
declaration 
statements 
are 
BASIC-SO assumes all variables 
without declaration characters are single 
precision variables. 
10 DEFDBL L-P All variables beginning with 
the letters L, M, N, 0, and P 
will be double precision 
variables. 
10 DEFSTR A 
All variables beginning with 
the letter A will be string 
variables. 
10 DEFINT I-N,W-Z 
All variable beginning with 
the letters I, J, K, L, M, 
N, W, X, Y, Z will be integer 
variables. 
BASIC-80 COMMANDS AND STATEMENTS 
2.13 ~ USR 
Format: 
Versions: 
Purpose: 
Page 2-16 
DEF USR[<digit>]=<integer expression> 
Extended, Disk 
To specify the starting address of an assembly 
Remarks: 
_ Example: 
language subroutine. 
<digit> may be any digit from 0 to 9. The digit 
corresponds to the number of the USR routine 
whose address is being specified. If <digit> is 
omitted, DEF USRO is assumed. 
The value of 
<integer expression> is the starting address of 
the USR routine. 
See Appendix C, Assembly_ 
Language Subroutines. 
Any number of DEF USR statements may appear in a 
program 
to 
redefine 
subroutine 
starting 
addresses, thus allowing access to as many 
subroutines as necessary. 
• 
. 
200 DEFUSRO=24000 
210 X=USRO(yA 2/2.89) 
." 
BASIC-80 COMMANDS AND STATEMENTS 
2.14 DELETE 
Format: 
Versions: 
Purpose: 
Remarks: 
DELETE[<line number>] [-<line number>] 
Page 2-17 
Extended, Disk 
To delete program lines. 
BASIC-80 always returns to command level after a 
DELETE is executed. If <line number> does not 
exist, an "Illegal function call" error occurs. 
Examples: 
DELETE 40 
DELETE 40-100 
DELETE-40 
Deletes line 40 
Deletes lines 40 through 
100, inclusive 
Deletes all lines up to 
and including line 40 
BASIC-80 COMMANDS AND STATEMENTS 
2.15 DIM 
Format: 
Versions: 
Purpose: 
DIM <list of subscripted variables> 
Page 2-18 
8K, Extended, Disk 
To specify the maximum values for array variable 
Remarks: 
Example: 
subscripts and allocate storage accordingly. 
If an array variable name is used without a DIM 
statement, the maximum value of its subscript(s) 
is assumed to be 10. If a subscript is used 
that is greater than the maximum specified, ,a 
"Subscript out of range" error occurs. 
The 
minimum value for a subscript is always 0, 
unless otherwise specified with the OPTION BASE 
statement (see Section 2.46). 
The DIM statement sets all the elements of the 
specified arrays to an initial value of zero. 
10 DIM A(20) 
20 FOR 1=0 TO 20 
30 READ A(I) 
40 NEXT I 
• 
BASIC-SO COMMANDS AND STATEMENTS 
2.16 EDIT 
Format: 
Versions: 
Purpose: 
Remarks: 
EDIT <line number> 
Page 2-19 
Extended, Disk 
To enter Edit Mode at the specified line. 
In Edit Mode, it is possible to edit portions of 
a 
line without retyping the entire line. Upon 
entering Edit Mode, BASIC-SO types the line 
number of the line to be edited, then it types a 
space and waits for an Edit Mode subcommand. 
Edit Mode Subcommands -------- ~~~~~~ 
Edit Mode subcommands are used to move the 
cursor or to insert, delete, replace, or search 
for text within a line. The subcommands are not 
echoed. 
Most of the Edit Mode subcommands may 
be preceded by an integer which causes the 
command to be executed that number of times. 
When a preceding integer is not specified, it is 
assumed to be 1. 
Edit Mode subcommands may be categorized 
according to the following functions: 
1. 
2. 
3. 
4. 
5. 
6. 
Moving the cursor 
Inserting text 
Deleting text 
Finding text 
Replacing text 
Ending and restarting Edit Mode 
N~E 
In the descriptions that follow, <ch> 
represents 
any 
character, 
<text> 
represents a string of characters of 
arbitrary 
length, 
[iJ 
represents an 
optional integer (the default is 1), and 
$ 
represents the Escape (or Altmode) 
key. 
BASIC-SO COMMANDS AND STATEMENTS 
1. 
Moving the Cursor 
Space 
Page 2-20 
Use the space bar to move the cursor to the 
right. 
[iJSpace moves the cursor i spaces to 
the right. Characters are printed as you space 
over them. 
Rubout In Edit Mode, [i]Rubout moves the cursor i 
spaces to the left (backspaces). Characters are 
printed as you backspace over them. 
2. 
Inserting Text 
I 
X 
I<text>$ inserts <text> at the current cursor 
position. 
The inserted characters are printed 
on the terminal. TO terminate insertion, type 
Escape. 
If 
Carriage Return is typed during an 
Insert command, the effect is the same as typing 
Escape and then Carriage Return. During an 
Insert command, the Rubout or Delete key on the 
terminal may be used to delete characters to the 
left of the cursor. If an attempt is made to 
insert a character that will make the line 
longer than 255 characters, a bell (Control-G) 
is typed and the character is not printed. 
The X subcommand is used to extend the line. 
X 
• mo.ves 'the '" cursor to the end of the line, goes 
into insert mode, and allows insertion of text 
as 
if 
an 
Insert command had been given. When 
you are finished extending the line, type Escape 
or Carriage Return. 
3. 
Oeleting'Te~t 
o 
[i]D deletes i characters to the right of the 
cursor. 
between 
The deleted characters are echoed 
backslashes, 
and 
the 
cursor 
is 
positioned to the right of the last character 
deleted. If there are fewer than i characters 
to 
H 
the 
right of the cursor, iO deletes the 
remainder of the line. 
H deletes all characters to the 
curSQr and then automatically 
mode. H is useful for replacing 
the end of a line. 
4. 
Finding Text 
S 
right of the 
enters insert 
statements at 
The subcommand [i]S<ch> searches for the ith 
occurrence of <ch> and positions the cursor 
before it. The character at the current cursor 
position is not included in the search. If <ch> 
is not found, the cursor will stop at the end of 
BASIC-80 COMMANDS AND STATEMENTS 
Page 2-21 
the line. All characters passed over during the 
search are printed. 
K 
s. 
The subcommand [i]K<ch> is similar to [i]S<ch>, 
except all the characters passed over in the 
search are deleted. The cursor is positioned 
before <ch>, and the deleted characters are 
enclosed in backslashes. 
Replacing Text 
C 
The subcommand C<ch> changes the next character 
to 
<ch>. 
If 
you wish to change the next i 
characters, use the subcommand iC, followed by i 
characters. 
After the ith new character is 
typed, change mode is exited and you will return 
to Edit Mode. 
6. 
Ending and Restarting Edit Mode 
<cr> 
E 
Q 
Typing Carriage Return prints the remainder of 
the line, saves the changes you made and exits 
Edit Mode. 
The E subcommand has the same effect as Carriage 
Return, except the remainder of the line is not 
printed. 
The Q subcommand returns to BASIC-80 ¥command 
.. 
level, without saving any of the changes that 
" 
L 
A 
were made to the line during Edit Mode. 
The L subcommand lists the remainder of the line 
(saving any changes made so far) and repositions 
the cursor at the beginning of the line, still 
in 
Edit Mode. 
L 
is usually used to list the 
line when you first enter Edit Mode. 
The A subcommand lets you begin editing a line 
over again. 
It restores the original line and 
repositions the cursor at the beginning. 
NOTE 
If BASIC-80 receives an unrecognizable 
command or illegal character while in 
Edit Mode, it prints a bell (Control-G) 
and the command or character is ignored. 
BASIC-SO COMMANDS AND STATEMENTS 
Page 2-22 
Syntax Errors 
When a Syntax Error is encountered during 
execution of a program, BASIC-SO automatically 
enters Edit Mode at the line that caused the 
error. For example: 
10 K = 2(4) 
RON 
?Syntax error in 10 
10 
When you finish editing the line and type 
Carriage Return (or the E subcommand), BASIC-SO 
reinserts the line, which causes all variable 
values to be lost. To preserve the variable 
values for examination , first exit Edit Mode 
with the 0 subcommand. BASIC-SO will return to 
command level, and all variable values will be 
preserved. 
Control-A 
To enter Edit Mode on the line you are currently 
typing, type Control-A. BASIC-SO responds with 
a carriage return, an exclamation point (1) and 
a 
space. 
The cursor will be positioned at the 
first character in the line. Proceed by typing 
an Edit Mode subcommand. 
NOTE 
Remember, if you have just entered a 
line and wish to go back and edit it, 
the command nEDIT.n will enter Edit Mode 
at 
the current line. (The line number 
symbol n.n always refers to the current 
line. ) 
BASIC-SO COMMANDS AND STATEMENTS 
2.17 END 
Format: 
Versions: 
Purpose: 
END 
Page 2-23 
SK, Extended, Disk 
To terminate program execution, close all files 
Remarks: 
Example: 
and return to command level. 
END statements may be placed anywbere in the 
program to terminate execution. Unlike the STOP 
statement, END does not cause a BREAK message to 
be 
printed. 
An 
END statement at the end of a 
program is optional. BASIC-aO·always returns to 
command level after an END is executed. 
520 IF K>lOOO THEN END ELSE GOTO 20 
BASIC-80 COMMANDS AND STATEMENTS 
2.18 ERASE 
Format: . 
Versions: 
Purpose: 
Remarks: 
Page 2-24 
ERASE <list of array variables> 
Extended, Disk 
To eliminate arrays from a program. 
Arrays may be redimensioned after they are 
ERASEd, or the previously allocated array space 
in memory may be used for other purposes. If an 
attempt is made to redimension an array without 
first ERASEing it, a "Redimensioned array" error 
NOTE: 
Example: 
occurs. 
The Microsoft BASIC compiler does not support 
ERASE. 
450 ERASE A,B 
460 DIM B(99) 
• 
• 
BASIC-80 COMMANDS AND STATEMENTS 
2.19 ERR AND ERL VARIABLES 
Page 2-25 
When an error handling subroutine is entered, 
the variable ERR contains the error code for the 
error, and the variable ERL contains the line 
number of the line in which the error ·was 
detected. The ERR and ERL variables are usually 
used in IF ••• THEN statements to direct program 
flow in the error trap routine. 
If the statement that caused the error was a 
direct mode statement, ERL will contain 65535. 
To 
test if an error occurred in a direct 
statement, use IF 65535 = ERL THEN ••• 
Otherwise, use 
IF ERR = error code THEN ••• 
IF ERL = line number THEN ••• 
If the line number is not on the right side of 
the relational operator, it cannot be renumbered 
by RENUM.Because ERL and ERR are reserved 
variables, neither may appear to the left of the 
equal sign in a LET (assignment) statement. 
BASIC-80 COMMANDS AND STATEMENTS 
2.20 ERROR 
Format: 
Versions: 
Purpose: 
ERROR <integer expression> 
Extend~d, Disk 
1) 
Page 2-26 
To simulate the occurrence of a BASIC-80 
error1 
Remarks: 
or 
2) 
to 
allow error codes to be 
defined by the user. 
The value of <integer expression> must be 
greater than 0 and less than 255. If the value 
of <integer expression> equals an error code 
already in use by BASIC-80 (see Appendix J), the 
ERROR statement will simulate the occurrence of 
that error, and the corresponding error message 
will be printed. (See Example 1.) 
To define your own error code, use a value that 
is 
greater than any used by BASIC-80~s error 
codes. 
(It is preferable to use the highest 
available 
values, 
so 
compatibility may be 
maintained when more error codes are added to 
BASIC-80.) This user-defined error code may then 
be 
conveniently handled in an error trap 
routine. (Se..e Example 2.) 
If an ERROR statement specifies a CQcle for which 
no 
error message has been defined, BASIC-80 
responds with the message UNPRINTABLE ERROR. 
Execution of an ERROR statement for which there 
is no error trap routine causes an error message 
to be printed and execution to halt. 
Example 1: LIST 
10 S = 10 
20 T = 5 
30 ERROR S + T 
40 END 
Ok 
RUN 
String too long in line 30 
Or, in direct mode: 
Ok 
ERROR 15 
String too long 
Ok 
(you type this line) 
(BASIC-80 types this line) 
BASIC-SO COMMANDS AND STATEMENTS 
Example 2: 
. 
110 ON ERROR GOTO 400 
120 INPUT "WHAT IS YOUR BET";B 
130 IF B > 5000 THEN ERROR 210 
Page 2-27 
400 IF ERR = 210 THEN PRINT "HOUSE LIMIT IS $5000" 
410 IF ERL = 130 THEN RESUME 120 
BASIC-80 COMMANDS AND STATEMENTS 
2.21 FIELD 
Format: 
Page 2-28 
FIELD[i]<file number>,<field width> AS <string variable> ••• 
Version: 
Purpose: 
Remarks: 
Example: 
NOTE: 
Disk 
To allocate space for variables in a random file 
buffer. 
To get data out of a random buffer after a GET 
or to enter data before a PUT, a FIELD statement 
must have been executed. 
<file number> 
is the number und~r which the file 
was OPENed. 
characters to 
For example, 
<field width> is the number of 
be allocated to <string variable>. 
FIELD 1, 20 AS N$, 10 AS ID$, 40 AS ADD$ 
allocates the first 20 positions. (bytes) in the· 
random file buffer to the string variable N$, 
the next 10 positions to ID$, and the next 40 
positions to ADD$. 
FIELD does NOT place any 
data in the random file buffer. (See LSET/RSET 
and GET.) 
The total number of bytes allocated in a FIELD 
statement must not exceed the record length that 
was specified when the file was OPENed. 
Otherwise, a "Field overflow" error occurs. 
(The default record length is l28.) 
Any number of FIELD statements may be executed 
for the same file, and all FIELD statements that 
have been executed are in effect at the same 
time. 
See Appendix B. 
~ !!2! ~ a FIELDed var iable name in an I.NPUT 
or 
LET statement. 
Once a -viriable--name is 
FIELDed, it points to the correct place in the 
random file buffer. 
If a subsequent INPUT or 
LET statement with that variable name is 
executed, the variable~s pointer is moved to 
string space. 
BASIC-SO COMMANDS AND STATEMENTS 
2.22 FOR ••• NEXT 
Format: 
Versions: 
Purpose: 
FOR <variable>=x TO y [STEP z] 
Page 2-29 
NEXT [<variable>] [,<variable> ••• ] 
where x, y and z are numeric expressions. 
SK, Extended, Disk 
To 
allow a series of instructions to be 
Remarks: 
performed in a loop a given number of times. 
<variable> is used as a counter. The first 
numeric expression (x) is the initial value of 
the counter. The second numeric expression (y) 
is 
the final value of the counter. The program 
lines following the FOR statement are executed 
until the NEXT statement is encountered. Then 
the counter is incremented by the amount 
specified by STEP. A check is performed to see 
if the value of the counter is now greater than 
the final value (y). 
If 
it is not greater, 
BASIC-SO branches back to the statement after 
the FOR· statement and the process is repeated. 
If it is greater, execution continues with the 
statement following the NEXT statement. This is 
a 
FOR ••• NEXT loop. If STEP is not specified, 
the 
increment is assumed to be one. If STEP is 
negative, the final value of the counter is set 
to 
be less than the initial value. The counter 
is decremented each time through the loop, and 
the 
loop is executed until the counter is less 
than the final value. 
The body of the loop is skipped if the 
value of the loop times the sign of 
exceeds the final value times the sign 
step. 
Nested Loops 
initial 
the step 
of 
the 
FOR ••• NEXT loops may be nested, that is, a 
FOR ••• NEXT loop may be placed within the context 
of another FOR ••• NEXT loop. 
When loops are 
nested, each loop must have a unique variable 
name as its counter. The NEXT statement for the 
inside loop must appear before that for the 
outside loop. If nested loops have the same end 
point, a single NEXT statement may be used for 
all of them. 
The variable(s) in the NEXT statement may be 
BASIC-SO COMMANDS AND STATEMENTS 
Page 2-30 
omitted, in which case the NEXT statement will 
match the most recent FOR statement. If a NEXT 
statement 
is 
encountered 
before 
its 
corresponding FOR statement, a "NEXT without 
FOR" 
error message is issued and execution is 
terminated. 
Example 1: 
10 1(=10 
20 FOR I=l TO I( STEP 2 
30 PRINT I; 
40 1(=1(+10 
50 PRINT I( 
60 NEXT 
RUN 
1 
3 
5 
7 
9 
Ok 
20 
30 
40 
50 
60 
Example 2: 10 J-O 
20 FOR I=l TO J 
30 PRINT I 
40 NEXT I 
In this example, the 
because the initial 
the final value. 
Example 3: 
10 I=5 
20 FOR I=l TO I+5 
30 PRINT I; 
40 NEXT 
RUN 
1 
2 
3 
4 
loop does( not execute 
value of the loop exceeds 
5 
6 
7 
8 
9 
10 
Ok 
In this example, the loop executes ten times. 
The final value for the loop variable is always 
set before the initial value is set. 
(Note: 
Previous versions of BASIC-SO set the initial 
value of the loop variable before setting the 
final value; 
i.e., the above loop would have 
executed six times.) 
BASIC-SO COMMANDS AND STATEMENTS 
2.23 GET 
Format: 
Version: 
Purpose: 
GET [#]<file number>[,<record number>] 
Page 2-31 
Disk 
To read a record from a random disk file into a 
Remarks: 
Example: 
NOTE: 
random buffer. 
<file number> is the number under which the file 
was OPENed. If <record number> is omitted, the 
next record (after the last GET) is read into 
the buffer. The largest possible record number 
is 32767. 
See Appendix B. 
After a GET statement, INPUT# and LINE INPUT# 
may be done to read characters from the random 
file buffer. 
BASIC-80 COMMANDS AND STATEMENTS 
2.24 GOSUB •.. RETURN 
Format: 
Versions: 
Purpose: 
Remarks: 
GOSUB <line number> 
RETURN 
8K, Extended, Disk 
Page 2-32 
To branch to and return from a subroutine. 
<line number> is the first 
line 
of 
the 
subroutine. 
A subroutine may be called any number of times 
in 
a 
program, and a subroutine may be called 
from within another subroutine. Such nesting of 
subroutines is limited only by available memory. 
The RETURN statement(s) in a subroutine cause 
BASIC-80 
to 
branch back to the statement 
following the most recent GOSUB statement. 
A 
subroutine may contain more than one RETURN 
statement, should logic dictate a return at 
different points in the subroutine. Subroutines 
may appear anywhere in the program, but it is 
recommended 
that the subroutine be readily 
distinguishable from the main program. 
To 
prevent inadvertant entry into the subroutine, 
it may be preceded by a STOP, END, or GOTO 
statement that directs program control around 
the subroutine. 
Example: 
10 GOSUB 40 
20 PRINT "BACK FROM SUBROUTINE" 
30 END 
40 PRINT "SUBROUTINE" ; 
50 PRINT " IN"; 
60 PRINT n PROGRESS" 
70 RETURN 
RUN 
SUBROUTINE IN PROGRESS 
BACK FROM SUBROUTINE 
Ok 
BASIC-SO COMMANDS AND STATEMENTS 
2.25 GOTO 
Format: 
Versions: 
Purpose: 
GOTO <line number> 
SK, Extended, Disk 
Page 2-33 
To branch unconditionally out of the normal 
Remarks: 
Example: 
program sequence to a specified line number. 
If <line number> is an executable statement, 
that statement and those following are executed. 
If it is a nonexecutable statement, execution 
proceeds 
at 
the 
first executable statement 
encountered after <line number>. 
LIST 
10 READ R 
20 PRINT "R =" :R, 
30 A = 3.l4*R .... 2 
40 PRINT "AREA =" :A 
50 GOTO 10 
60 DATA 5,7,12 
Ok 
RUN 
R = 5 
R = 7 
R = 12 
AREA = 7S.5 
AREA = l53.S6 
AREA = 452.16 
?Out of data in 10 
Ok 
BASIC-SO COMMANDS AND STATEMENTS 
2.26 IF ••• THEN[ ••• ELSE] AND IF ••• GOTO -----
Format: 
Format: 
Versions: 
NOTE: 
IF <expression> THEN <statement(s» 
Page 2-34 
<line number> 
, 
[ELSE <statement(s)> I <line number>] 
IF <expression> GOTO <line number> 
[ELSE <statement(s)> I <line number>] 
SK, Extended, Disk 
The ELSE clause is allowed only in Extended and 
Disk versions. 
Purpose: 
Remarks: 
To make a decision regarding program flow based 
on the result returned by an expression. 
If the result of <expression> is not zero, the 
THEN or GOTO clause is executed. THEN may be 
followed by either a line number for branching 
or one or more statements to be executed. GOTO 
is always followed by a line number. 
If 
the 
result of <expression> is zero, the THEN or GOTO 
clause is ignored and the ELSE clause, if 
present, is executed. Execution continues with 
the next executable statement. (ELSE is allowed 
only -in Extended and Disk versions.) Extended 
and Disk versions allow a comma before THEN. 
Nesting of IF Statements 
In 
the 
Extended 
IF ••• THEN ••• ELSE 
and 
statements 
Nesting is limited only by the 
line. For example 
Disk 
versions, 
may be nested. 
length of the 
IF X>Y THEN PRINT "GREATER" ELSE IF Y>X 
THEN PRINT "LESS THAN" ELSE PRINT "EQUAL" 
is a legal statement. If the statement does not 
contain 
the 
same number of ELSE and THEN 
clauses, each ELSE is matched with the closest 
unmatched THEN. For example 
IF A=B THEN IF B=C THEN PRINT "A=C" 
ELSE PRINT "A<>C" 
will not print nA<>C" when A<>B. 
If an IF ••• THEN statement is followed by a 
number in the direct mode, an "Undefined 
line 
line" 
error results unless a statement with 
specified 
line 
number had previously 
the 
been 
entered in the indirect mode. 
BASIC-SO COMMANDS AND STATEMENTS 
NOTE: 
Page 2-35 
When using IF to test equality for a value that 
is 
the 
result of a floating point computation, 
remember that the internal representation of the 
value may not be exact. Therefore, the test 
should be against the' range over which the 
accuracy of the value may vary. For example, to 
test a computed variable 'A against the value 
1.0, use: 
IF ABS (A-1.0)<1.0E-6 THEN ••• 
This test returns true if the value of A is 1.0 
with a relative error of less than 1.OE-6. 
Example 1: 200 IF I THEN GETt1,I 
This statement GETs record number I if I is not 
zero. 
Example 2: 100 IF(I<20)*(I>10) THEN DB=1979-1:GOTO 300 
110 PRINT "OUT OF RANGE" 
In this example, a test determines if I is 
greater than 10 and less than 20. If I is in 
this range, DB is calculated and execution 
branches to line 300. 
If 
I 
is not in this 
range, execution continues with line 110. 
Example 3: 210 IF IOFLAG THEN PRINT A$ ELSE LPRINT A$ 
This statement causes printed output to go 
either to the terminal or the line printer, 
depending on the value of a variable (IOFLAG). 
If 
I OF LAG 
is 
zero, output goes to the line 
printer, otherwise output goes to the terminal. 
BASIC-80 COMMANDS AND STATEMENTS 
2.27 INPUT 
Format: 
Page 2-36 
INPUT[:] [<"prompt string">:]<list of variables> 
Versions: 
Purpose: 
Remarks: 
8K, Extended, Disk 
To allow input from the terminal during program 
execution. 
When an INPUT statement is encountered, program 
execution pauses and a question mark is printed 
to indicate the program is waiting for data. If 
<"prompt string"> ~s included, the string is 
printed before the question mark. The required 
data is then entered at the terminal. 
A comma may be used instead of a semicolon after 
the prompt string to suppress the question mark. 
For example, 
the 
statement 
INPUT 
"ENTER 
BIRTHDATE",B$ will print the prompt with no 
question mark. 
If INPUT is immediately followed by a semicolon, 
then the carriage return typed by the user to 
input data does not echo a carriage return/line 
feed sequence. 
The data that is entered is assigned to 
variable(s) 
given in <variable list>. 
number of data items supplied must be the 
as 
the number of variables in the list. 
the 
The 
same 
Data 
ttems are separated by commas. 
The variable names in the list may be numeric or 
string variable names (including subscripted 
variables). The type of each data item that is 
input must agree with the type specified by the 
variable name. 
(Strings input to an INPUT 
statement need not be surrounded by quotation 
marks.) 
Responding to INPUT with too many or too few 
items, or with the wrong type of value (numeric 
instead of string, etc.) causes the messsage 
"?Redo from start" to be printed. No assignment 
of input values is made until an acceptable 
response is given. 
In the 8K version, INPUT is illegal in the 
direct mode. 
BASIC-80 COMMANDS AND STATEMENTS 
Examples: 
10 INPUT 
20 PRINT 
30 END 
RUN 
? 
5 
x 
X "SQUARED IS" X"'2 
Page 2-37 
(The 5 was typed in by the user 
in response to the question mark.) 
5 SQUARED IS 25 
Ok 
LIST 
10 PI=3.14 
20 INPUT "WHAT IS THE RADIUS":R 
30 A=PI*R"'2 
40 PRINT "THE AREA OF THE CIRCLE IS":A 
50 PRINT 
60 GOTO 20 
Ok 
RUN 
WHAT IS THE RADIUS? 7.4 (User types 7.4) 
THE AREA OF THE CIRCLE IS 171.946 
WHAT IS THE RADIUS? 
etc. 
BASlc-ao COMMANDS AND STATEMENTS 
2.2a INPUT# 
Format: 
Version: 
Purpose: 
INPUT#<file number>,<variable list> 
Page 2-38 
Disk 
To read data items from a sequential disk file 
Remarks: 
Example: 
and assign them to program variables. 
<file number> is the number used when the file 
was OPENed for input. <variable list> contains 
the vari?lble names that will be assigned to the 
items in the file. 
(The variable type must 
match the type specified by the variable name.) 
With INPUT#, no question mark is printed, as 
with INPUT. 
The data items in the file should appear just as 
they would if data were being typed in response 
to an INPUT statement. 
with numeric values, 
leading spaces, carriage returns and line feeds 
are ignored. The first character encountered 
that is not a space, carriage return or line 
feed is assumed to be the start of a number. 
The number terminates on a space, carriage 
return, line feed or comma. 
If BASIC-aO is scanning the sequential data file 
for 
a 
string item, leading spaces, carriage 
returns and line feeds are also ignored. 
The 
first character encountered that is not a space, 
carriage return, or line feed is assumed to be 
the start of a string item. If this first 
character is a quotation mark ("), the string 
item will consist of all characters read between 
the first quotation mark and the second. 
a 
Thus, 
quoted string may not contain a quotation mark 
as a character. If the first character of the 
string is not a quotation mark, the string is an 
unquoted string, and will terminate on a comma, 
carriage or line feed (or after 255 characters 
have been read). If end of file is reached when 
a 
numeric or string item is being INPUT, the 
item is terminated. 
See Appendix B. 
BASIC-SO COMMANDS AND STATEMENTS 
2.29 KILL 
Format: 
Version: 
Purpose: 
Remarks: 
KILL <filename> 
Page 2-39 
Disk 
To delete a file from disk. 
If a KILL statement is given for a file that is 
currently OPEN, a RFile already openR error 
occurs. 
KILL is used for all types of disk files: 
program files, random data files and sequential 
data files. 
Example: 
200 KILL RDATA1R 
See also Appendix B. 
BASIC-80 COMMANDS AND STATEMENTS 
2.30 LET 
Format: 
Versions: 
Purpose: 
[LET] <variable>=<expression> 
8K, Extended, Disk 
Page 2-40 
To assign the value of an expression to a 
Remarks: 
Example: 
variable. 
Notice the word LET is optional, i.e., the equal 
sign is sufficient when assigning an expression 
to a variable name. 
110 LET 0=12 
120 LET E=12A2 
130 LET F=12A4 
140 LET SUM=D+E+F 
or 
110 D=12 
120 E=12"'2 
130 F=12 .... 4 
140 SUM=D+E+F 
BASIC-80 COMMANDS AND STATEMENTS 
2.31 LINE INPUT 
Format: 
Page 2-41 
LINE INPUT[i] [<"prompt string">i]<string variable> 
Versions: 
Purpose: 
Remarks: 
Example: 
Extended, Disk 
To input an entire line (up to 254 characters) 
to 
a 
string variable, without the use of 
delimiters. 
The prompt string is a string literal that is 
printed 
at 
the 
terminal before input is 
accepted. A question mark is not printed unless 
it is part of the prompt string. All input from 
the end of the prompt to the carriage return is 
assigned to <string variable>. 
If LINE INPUT is immediately followed by a 
semicolon, then the carriage return typed by the 
user to end the input line does not echo a 
carriage 
terminal. 
return/line 
feed sequence at the 
A LINE INPUT may be escaped by typing Control-C. 
BASIC-SO will return to command level and type 
Ok. 
Typing CONT resumes execution at the LINE 
INPUT. 
See Example, Section 2.32, LINE INPUT#. 
BASIC-SO COMMANDS AND STATEMENTS 
2.32 ~ INPUTi 
Format: 
Version: 
Purpose: 
Page 2-42 
LINE INPUTi<file number>,<string variable> 
Disk 
To read an entire line (up to 254 characters), 
without delimiters, from a sequential disk data 
Remarks: 
Example: 
file to a string variable. 
<file number> is the number under which the file 
was OPENed. 
<string variable> is the variable 
name to which the 'line will be assigned. 
LINE 
INPUTi reads all characters in the sequential 
file up to a carriage return. 
It 
then skips 
over the carriage return/line feed sequence, and 
the next LINE INPUTi reads all characters up to 
the 
next 
carriage 
return. 
(If 
a 
line 
feed/carriage return sequence is encountered, it 
is preserved.) 
LINE INPUTi is especially useful 
a data file has been broken into 
BASIC-SO program saved in ASCII 
read as data by another program. 
10 OPEN "O",l,"LIST" 
if each line of 
fields, or if a 
mode is being 
20 LINE INPUT "CUSTOMER INFORMATION? " :C$ 
30 PRINT iI, C$ 
40 CLOSE 1 
50 OPEN "I",l,"LIST" 
60 LINE INPUT iI, C$ 
70 PRINT C$ 
SO 'CLOSE 1 
RUN 
CUSTOMER INFORMATION? LINDA JONES 
LINDA JONES 
Ok 
234,4 
234,4 
MEMPHIS 
MEMPHIS 
BASIC-80 COMMANDS AND STATEMENTS 
2.33 LIST 
Format 1: 
Versions: 
Format 2: 
Versions: 
Purpose: 
LIST [<line number>] 
8K, Extended, Disk 
LIST [<line number>[-[<line number>]]] 
Page 2-43 
Extended, Disk 
To list all or part of the program currently in 
Remarks: 
memory at the terminal. 
BASIC-80 always returns to command level after a 
LIST is executed. 
Format 1: If <line number> is omitted, the 
program is listed beginning at the lowest line 
number. 
(Listing is terminated either by the 
end of the program or by typing Control-C.) If 
<line number> is included, the 8K version will 
list the program beginning at that line: and 
the Extended and Disk versions will list only 
the specified line. 
Format 2: This format allows the following 
options: 
1. 
If only the first number is specified, that 
line 
listed. 
2. 
and all higher-numbered lines are 
If only the second number is specified, all 
lines from the beginning of the program 
through that line are listed. 
3. 
If both numbers are specified, the entire 
range is listed. 
BASIC-80 COMMANDS AND STATEMENTS 
Examples: 
Format 1: 
LIST 
Page 2-44 
Lists the program currently 
LIST 500 
Format 2: 
LIST 150
LIST -1000 
in memory. 
In the 8K version, lists 
all programs lines from 
500 to the end. 
In Extended and Disk, 
lists line 500. 
Lists all lines from 150 
to the end. 
Lists all lines from the 
lowest number through 1000. 
LIST 150-1000 Lists lines 150 through 
1000, inclusive. 
BASIC-80 COMMANDS AND STATEMENTS 
2.34 LLIST 
Format: 
Versions: 
Purpose: 
LLIST [<line number>[-[<line number>]]] 
Page 2-45 
Extended, Disk 
To list all or part of the program currently in 
Remarks: 
NOTE: 
Example: 
memory at the line printer. 
LLIST assumes a l32-character wide printer. 
BASIC-80 always returns to command level after 
an LLIST is executed. The options for LLIST are 
the same as for LIST, Format 2. 
LLIST and LPRINT are not included in 
implementations of BASIC-80. 
See the examples for LIST, Format 2. 
all 
BASIC-SO COMMANDS AND STATEMENTS 
2.35 LOAD 
Format: 
Version: 
Purpose: 
Remarks: 
LOAD <filename>[,R] 
Page 2-46 
Disk 
To load a file from disk into memory. 
<filename> is the name that was used when the 
file 
was 
SAVEd. 
(With CP/M, the default 
extension .BAS is supplied.) 
LOAD closes all open files and deletes all 
variables and program lines currently residing 
in 
memory before it loads the designated 
program. 
However, if the nRn option is used 
with LOAD, the program is RUN after it is 
LOADed, and all open data files are kept open. 
Thus, LOAD with the nRn option may be used to 
chain several programs (or segments of the same 
program). Information may be passed between the 
programs using their disk data files. 
Example: 
LOAD nSTRTRKn,R 
BASIC-80 COMMANDS AND STATEMENTS 
2.36 LPRINT AND LPRINT USING 
Format: 
Versions: 
Purpose: 
Remarks: 
Page 2-47 
LPRINT [<list of expressions>] 
LPRINT USING <string exp>i<list of expressions> 
Extended, Disk 
To print data at the line printer. 
Same as PRINT and PRINT USING, except output 
goes to the line printer. See Section 2.49 and 
NOTE: 
Section 2.50. 
LPRINT assumes a l32-character-wide printer. 
LPRINT and LLIST are not included in 
implementations of BASIC-80. 
all 
BASIC-80 COMMANDS AND STATEMENTS 
2 • 37 
LSET AND RSET 
Format: 
Page 2-48 
LSET <string variable> = <string expression> 
RSET <string variable> = <string expression> 
Version: 
Purpose: 
Remarks: 
Examples: 
NOTE: 
Disk 
To move data from memory to a random file buffer 
(in preparation for a PUT statement) • 
If <string expression> requires fewer bytes than 
were 
FIELDed 
to 
<string 
variable>, LSET 
left-justifies the string in the field, and RSET 
right-justifies the string. (Spaces are used to 
pad the extra positions.) If the string is too 
long for the field, characters are dropped from 
the right. Numeric values must be converted to 
strings before they are LSET or RSET. See the 
MKI$, MKS$, MKD$ functions, Section 3.25. 
150 LSET A$=MKS$(AMT) 
160 LSET D$=DESC($~ 
See also Appendix B. 
LSET or RSET may also be used with 
string variable to left-justify or 
a 
string in a given field. 
program lines 
110 A$=SPACE$(20) 
120 RSET A$=N$ 
a 
non-fielded 
right-justify 
For 
example, the 
right-justify the string N$ in a 20-character 
field. 
This can be very handy for formatting 
printed output. 
BASIC-80 COMMANDS AND STATEMENTS 
2.38 MERGE 
Format: 
Version: 
Purpose: 
MERGE <filename> 
Page 2-49 
Disk 
To merge a specified disk file into the program 
Remarks: 
Example: 
currently in memory. 
<filename> is the name used when the file was 
SAVEd. 
(With CP/M, the default extension .BAS 
is supplied.) The file must have been SAVEd in 
ASCII format. (If not, a "Bad file mode" error 
occurs. ) 
If any lines in the disk file have the same line 
numbers as lines in the program in memory, the 
lines from the file on disk will replace the 
corresponding lines in memory. (MERGEing may be 
thought of as "inserting" the program lines on 
disk into the program in memory.) 
BASIC-80 always returns to command level after 
executing a MERGE command. 
MERGE "NUMBRS" 
BASIC-SO COMMANDS AND STATEMENTS 
2.39 MID$ 
Format: 
MID$«string expl>,n[,m])=<string exp2> 
_where nand 
Page 2-50 
m are integer expressions and 
<string expl> 
expressions. 
Versions: 
Purpose: 
Extended, Disk 
and <string exp2> are string 
To replace a portion of one string with another 
string. 
Remarks: 
The characters in <string expl>, beginning at 
position n, are replaced by the characters in 
<string exp2>. The optional m refers, to the 
number of characters from <string exp2> that 
will be used in the replacement. 
If 
m is 
omitted, all of <string exp2> is used. However, 
regardless of whether m is omitted or included, 
the 
replacement of characters never goes beyond 
the original length of <string expl>. 
Example: 
10 A$="KANSAS CITY, MO" 
20 MID$(A$,14)="KS" 
30 PRINT A$ 
RUN 
KANSAS CITY, KS 
MID$ is also a function that returns a substring 
of a given string. See Section 3.24. 
BASIC-80 COMMANDS AND STATEMENTS 
2.40 NAME 
Format: 
Version: 
Purpose: 
Remarks: 
NAME <old filename> AS <new filename> 
Page 2-51 
Disk 
To change the name of a disk file. 
<old filename> must exist and <new filename> 
must not exist; otherwise an error will result. 
After a NAME command, the file exists on the 
same disk, in the same area of disk space, with 
the new name. 
Example: 
Ok 
NAME "ACCTS" AS "LEDGER" 
Ok 
In this example, the file that was 
formerly named ACCTS will now be named LEDGER. 
BASIC-80 COMMANDS AND STATEMENTS 
2.41 NEW 
Format: 
Versions: 
Purpose: 
NEW 
Page 2-52 
8K, Extended, Disk 
To delete the program currently in memory and 
Remarks: 
clear all variables. 
NEW is entered at command leyel to clear memory 
before entering a new program. BASIC-80 always 
returns to command level after a NEW is 
executed. 
BASIC-80 COMMANDS AND STATEMENTS 
2.42 NULL 
Format: 
Versions: 
Purpose: 
NULL <integer expression> 
Page 2-53 
8K, Extended, Disk 
To set the number of nulls to be printed at the 
end of each line. 
Remarks: 
For 
10-character-per-second 
tape 
punches, 
<integer expression> should be >=3. When tapes 
are not being punched, <integer expression> 
should 
be 
0 
or 
1 
for 
Teletypes 
and 
Teletype-compatible CRTs. <integer expression> 
should be 2 or 3 for 30 cps hard copy printers. 
The default value is O. 
Example: 
Ok 
NULL 2 
Ok 
100 INPUT X 
200 IF X<50 GOTO 800 
Two null characters will be printed after each 
line. 
BASIC-SO COMMANDS AND STATEMENTS 
2.43 ON ERROR GOTO 
Format: 
Versions: 
Purpose: 
ON ERROR GOTO <line number> 
Page 2-54 
Extended, Disk 
To enable error trapping and specify the first 
Remarks: 
NOTE: 
Example: 
line of the error handling subroutine. 
Once error trapping has been enabled all errors 
detected, including direct mode errors (e.g., 
Syntax errors), will cause a jump to the 
specified error handling subroutine. If <line 
number> does not exist, an "Undefined line" 
error 
results. 
To 
disable error trapping, 
execute an ON ERROR ~TO O. 
Subsequent errors 
will print an error message and halt execution. 
An ON ERROR GOTO 0 statement that appears in an 
error trapping subroutine causes BASIC-SO to 
stop and print the error message for the error 
that caused the trap. It is recommended that 
all error trapping subroutines execute an ON 
ERROR GOTO 0 if an error is encountered for 
which there is no recovery action. 
If an error occurs during execution of an error 
handling subroutine, the BASIC error message is 
printed 
trapping 
and 
does 
execution 
terminates. 
Error 
not occur within the error 
handling subroutine. 
10 ON ERROR GOTO 1000 
BASIC-SO COMMANDS AND STATEMENTS 
2.44 ON ••• GOSUB AND ON ••• GOTO 
Format: 
Versions: 
Purpose: 
Page 2-55 
ON <expression> GOTO <list of line numbers> 
ON <expression> GOSUB <list of line numbers> 
SK, Extended, Disk 
To branch to one of several specified line 
numbers, depending on the value returned when an 
Remarks: 
Example: 
expression is evaluated. 
The value of <expression> determines which line 
number in the list will be used for branching. 
For example, if the value is three, the third 
line number in the list will be the destination 
of the branch. (If the value is a non-integer, 
the fractional portion is rounded.) 
In the ON ••• GOSUB statement, each line number in 
the 
list must be the first line number of a 
subroutine. 
If the value of <expression> is zero or greater 
than the number of items in the list (but less 
than or equal to 255), BASIC continues with the 
next executable statement. 
If 
the 
value of 
<expression> is negative or greater than 255, an 
"Illegal function call" error occurs. 
100 ON L-1 GOTO 150,300,320,390 
BASIC-80 COMMANDS AND STATEMENTS 
2.45 OPEN 
Format: 
Page 2-56 
OPEN <mode>, [#]<file number>,<filename>, [<reclen>] 
Version: 
Purpose: 
Remarks: 
NOTE: 
Example: 
Disk 
To allow I/O to a disk file. 
A disk file must be OPENed before any disk 
operation can be performed on that file. 
allocates a buffer for I/O to the file 
determines the mode of access that will be 
with the buffer. 
<mode> is a string expression whose 
character is one of the following: 
o 
specifies sequential output mode 
I 
R 
specifies sequential input mode 
I/O 
OPEN 
and 
used 
first 
specifies random input/output mode 
<file number> is an integer expression whose 
value is between one and fifteen. The number is 
then associated with the file for as long as it 
is 
OPEN and is used to refer other disk I/O 
statements to the file. 
<filename> is a string expression containing a 
name that conforms to your operating system~s 
rules for disk filenames. 
<reclen> is an integer expression which, if 
included, sets the record length for random 
files. The default record length is 128 bytes. 
See also page A-3. 
A file can be OPENed for sequential input or 
random access on more than one file number at a 
time. A file may be OPENed for output, however, 
on only one file number at a time. 
10 OPEN "I",2,"INVEN" 
See also Appendix B. 
BASIC-80 COMMANDS AND STATEMENTS 
2.46 OPTION BASE 
Format: 
Versions: 
Purpose: 
RemarkS: 
OPTION BASE n 
where n is 1 or 0 
8K, Extended, Disk 
To 
declare the 
subscripts. 
minimum 
Page 2-57 
value 
for 
The default base is O. If the statement 
OPTION BASE 1 
array 
is executed, the lowest value an array subscript 
may have is one. 
BASIC-80 COMMANDS AND STATEMENTS 
2.47 OUT 
Format: 
OUT I,J 
Page 2-58 
where I and J are integer expressions in the 
Versions: 
Purpose: 
Remarks: 
Example: 
range 0 to 255. 
8K, Extended, Disk 
To send a byte to a machine output port. 
The integer expression I is the port number, and 
the 
integer expression J is the data to be 
transmitted. 
100 OUT 32,100 
BASIC-80 COMMANDS AND STATEMENTS 
2.48 POKE 
Format: 
Versions: 
Purpose: 
Remarks: 
POKE I,J 
where I and J are integer expressions 
Page 2-59 
8K, Extended, Disk 
To write a byte into a memory location. 
The integer expression I is the address of the 
memory 
location to be POKEd. 
The 
integer 
expression J is the data to be POKEd. J must be 
in 
the 
range 0 to 255. In the 8K version, I 
must be less than 32768. In the Extended and 
Disk versions, I must be in the range 0 to 
65536. 
With the 8K version, data may be POKEd into 
memory locations above 32768 by supplying a 
negative number for I. 
The value of I is 
computed by subtracting 65536 from the desired 
address. 
For example, to POKE data into 
location 45000, I = 45000-65536, or -20536. 
The complementary function to POKE is PEEK. The 
argument to PEEK is an address from which a byte 
is to be read. See Section 3.27. 
POKE and PEEK are useful for efficient data 
storage, loading assembly language subroutines, 
and passing arguments and results to and from 
assembly language subroutines. 
Example: 
10 POKE &H5AOO,&HFF 
BASIC-SO COMMANDS AND STATEMENTS 
2.49 PRINT 
Format: 
Versions: 
Purpose: 
Remarks: 
PRINT [<list of expressions>] 
SK, Extended, Disk 
Page 2-60 
To output data at the terminal. 
If <list of expressions> is omitted, a blank 
line is printed. 
If <list of expressions> is 
included, the values of the expressions are 
printed at the terminal. The expressions in the 
list may be numeric and/or string expressions. 
(Strings must be enclosed in quotation marks.) 
Print Positions 
The position of each printed item is determined 
by the punctuation used to separate the items in 
the list. BASIC-SO divides the line into print 
zones of 14 spaces each. 
In 
the list of 
expressions, a comma causes the next value to be 
printed at the beginning of the next zone. A 
semicolon causes the next value to be printed 
immediately after the last value. Typing one or 
more spaces between expressions has the same 
effect as typing a semicolon. 
If a comma or a semicolon terminates the list of 
expressions, the next PRINT statement begins 
printing on the same line, spacing accordingly. 
If 
the list of expressions terminates without a 
comma or a semicolon, a carriage return is 
printed at the end of the line. If the printed 
line is longer than the terminal width, BASIC-SO 
goes to the next physical line and continues 
printing. 
Printed numbers are always followed by a space. 
Positive 
numbers are preceded by a space. 
Negative numbers are preceded by a minus sign. 
Single precision numbers that can be represented 
with 6 or fewer digits in the unscaled format no 
less accurately than they can be represen.ted in 
the scaled format, are output using the unscaled 
format. 
For eX9mple, 10A(-6) is output as 
.000001 and 10A(-7) is output as lE-7. 
Double 
preclslon numbers that can be represented with 
16 or fewer digits in the unscaled format no 
less accurately than they can be represented in 
the scaled format, are output using the unscaled 
format.' 
For example, 10A(-16) is output as 
.0000000000000001 and 10A(-17) is output as 
10-17. 
BASIC-80 COMMANDS AND STATEMENTS 
Page 2-61 
A question mark may be used in place of the word 
PRINT in a PRINT statement. 
Example 1: 
10 X=5 
20 PRINT 
30 END 
RUN 
10 
Ok 
In 
X+5, X-5, X*(-5), X""5 
a -25 
3125 
this example, the commas in the PRINT 
statement cause each value to be printed at the 
beginning of the next print zone. 
Example 2: LIST 
10 INPUT X 
20 PRINT X "SQUARED IS" X""2 "AND" 7 
30 PRINT X "CUBED IS" X""3 
40 PRINT 
50 GOTO 10 
Ok 
RUN 
? 
? 
9 
9 SQUARED IS 81 AND 9 CUBED IS 729 
21 
21 SQUARED IS 441 AND 21 CUBED IS 9261 
? 
In this example, the semicolon at the end of 
line 20 causes both PRINT statements to be 
printed on the same line, and line 40 causes a 
blank line to be printed before the next prompt. 
Example 3: 
10 FOR X = 1 TO 5 
20 J=J+5 
30 K=K+10 
40 ?J7K7 
50 NEXT X 
Ok 
RUN 
5 
10 
10 
20 
15 
30 
20 
40 
25 
50 
Ok 
In this example, the semicolons in the PRINT 
statement 
cause 
each value to be printed 
immediately after the preceding value. 
(Don~t 
forget, a number is always followed by a space 
and positive numbers are preceded by a space.) 
In 
line 40, a question mark is used instead of 
the word PRINT. 
BASIC-80 COMMANDS AND STATEMENTS 
2.~0 
PRINT USING 
Format: 
Page 2-62 
PRINT USING <string exp>~<list of expressions> 
Versions: 
Purpose: 
Remarks 
and 
Examples: 
"!" 
Extended, Disk 
To print strings or numbers using a specified 
format •. 
<list of expressions> is comprised of the string 
expressions or numeric expressions that are to 
be printed, separated by semicolons. 
<string 
exp> is a string literal (or variable) comprised 
of 
special 
formatting 
ch?lracters. 
These 
formatting characters (see below) determine the 
field and the format of the printed strings or 
numbers. 
String Fields 
When PRINT USING is used to print strings, one 
of 
three formatting characters may be used to 
format the string field: 
Specifies that only the first character in the 
given string is to be printed. 
"\n spaces\" Specifies that 2+n characters from the string 
are to be printed. If the backslashes are typed 
with no spaces, two characters will be printed~ 
with 
one 
space, three characters will be 
printed, and so on. If the string is longer 
than 
the 
field, 
the extra characters are 
ignored. If the field is lonnger than the 
string, the string will be left-justified in the 
field and padded with spaces on the right. 
Example: 
10 A$="LOOK":B$="OUT" 
30 PRINT USING "!"~A$~B$ 
40 PRINT USING"\ \"~A$~B$ 
50 PRINT USING"\ 
RUN 
LO 
LOOKOUT 
LOOK OUT !! 
\"~A$~B$~"!!" 
BASIC-80 COMMANDS AND STATEMENTS 
"&" 
Page 2-63 
Specifies a variable length string field. 
When 
the field is specified with "&", the string is 
output exactly as input. Example: 
10 A$="LOOK" :B$="OUT" 
20 PRINT USING "!"~A$~ 
30 PRINT USING "&"~B$ 
RUN 
LOUT 
Numeric Fields 
When PRINT USING is used to print numbers, the 
following special characters may be used to 
format the numeric field: 
# 
+ 
A number sign is used to represent each digit 
position. 
Digit positions are always filled. 
If the number to be printed has fewer digits 
than positions specified, the number will be 
right-justified (preceded by spaces) in the 
field. 
A decimal point may be inserted at any position 
in 
the field. 
If the format string specifies 
that a digit is to precede the decimal point, 
the digit will always be printed (as 0 if 
necessary). Numbers are rounded as necessary. 
PRINT USING nit.iin~.78 
0.78 
PRINT USING "##i.t#"~987.654 
987.65 
PRINT USING "ii.ii 
10.20 
5.30 
66.79 
"~10.2,5.3,66.789,.234 
0.23 
In the last example, three spaces were inserted 
at 
the end of the format string to separate the 
printed values on the line. 
A plus sign at the beginning or end of the 
format string will cause ·the sign of the number 
(plus or minus) to be printed before or after 
the number. 
BASIC-80 COMMANDS AND STATEMENTS 
Page 2-64 
A minus sign at the end of the format field will 
cause negative numbers to be printed with a 
trailing minus sign. 
PRINT USING "+..... -68.95 
+2.40 
";-68.95,2.4,55.6,-.9 
+55.60 
PRINT USING " •••• #--0.90 
";-68.95,22.449,-7.01 
68.95
** 
22.45 
7.01
A double asterisk at the beginning of the format 
string causes leading spaces in the numeric 
field to be filled with asterisks. The ** also 
specifies positions for two more digits. 
PRINT USING "** •• # 
*12.4 
$$ 
*-0.9 
765.1 
";12.39,-0.9,765.1 
A double dollar sign causes a dollar sign to be 
printed to the immediate left of the formatted 
number. 
The $$ specifies two more digit 
positions, one of which is the dollar sign. The 
exponential format cannot be used with $$. 
Negative numbers cannot be used unless the minus 
sign trails to the right. 
PRINT USING "$$## •• '.";456.78 
$456.78 
**$ 
The **$ at the beginning of a format string 
combines the effects of the above two symbols. 
Leading spaces will be asterisk-filled and a 
dollar sign will be printed before the number. 
**$ specifies three more digit positions, one of 
which is the dollar sign. 
PRINT USING "**$ ••• '.";2.34 
***$2.34 
A comma that is to the left of the decimal point 
in 
a 
formatting string causes a comma to be 
printed to the left of every third digit to the 
left of the decimal point. A comma that is at 
the en~ of the format string is printed as part 
of 
the string. A comma specifies another digit 
position. The comma has no effect if used with 
the exponential (AAAA) format. 
PRINT USING " •• '., ••• ";1234.5 
1,234.50 
PRINT USING " ••••••• ,";1234.5 
1234.50, 
BASIC-80 COMMANDS AND STATEMENTS 
Page 2-65 
Four carats (or up-arrows) may be placed after 
the 
digit 
position 
characters to specify 
exponential format. The four carats allow space 
for 
E+xx to be printed. 
position may be specified. 
Any 
decimal point 
The significant 
digits are left-justified, and the exponent is 
adjusted. Unless a leading + or trailing + or 
is specified, one digit position will be used to 
the left of the decimal point to print a space 
or a minus sign. 
PRINT USING "*#.#*~~~~";234.56 
2.35E+02 
PRINT USING ".####~~~~-";888888 
.8889E+06 
PRINT USING "+.##AAAA";123 
+.12E+03 
An underscore in the format string 
next 
character to be output as 
character. 
PRINT USING "_1##.#*_1 ";12.34 
112.341 
The literal character 
itself 
causes the 
a 
literal 
may 
be 
an 
underscore by placing "_" in the format string. 
% 
If the number to be printed is larger than the 
specified numeric field, a percent sign is 
printed in front of the number. 
If 
rounding 
causes the number to exceed the field, a percent 
sign will be printed in front of the rounded 
number. 
PRINT USING "##.##";111.22 
%111.22 
PRINT USING ".##";.999 
%1.00 
If the number of digits specified exceeds 24, an 
"Illegal function call" error will result. 
BASIC-80 COMMANDS AND STATEMENTS 
2.51 PRINTi AND PRINTi USING 
Format: 
Page 2-66 
PRINTt<filenumb~r>,[USING<string exp>;]<list of exps> 
Version: 
Purpose: 
Remarks: 
Disk 
To write data to a sequential disk file. 
<file number> is the number used when the file 
was 
OPENed 
for 
output. 
<string. exp> is 
comprised of formatting characters as described 
in 
Section 2.50, PRINT USING. The expressions 
in <list of expressions>, are the numeric and/or 
string expressions that will be written to the 
file. 
PRINTt does not compress data on the disk. 
An 
image of the data is written to the disk, just 
as it would be displayed on the terminal with a 
PRINT statement. 
For this reason, care should 
be taken to delimit the data on the disk, so 
that it will be input correctly from the disk. 
In the list of expressions, numeric 
expressions 
should be delimited by semicolons. 
PRINTtl,A;B;C;X;Y;Z 
For example, 
(If commas are used as delimiters, the extra 
blanks that are inserted between print fields 
will also be written to disk.) 
String expressions 
must 
be 
separated 
by 
semicolons in the list. To format the string 
expressions correctly on the disk, use explicit 
delimiters in the list of expressions. 
For example, let A$=nCAMERAn and B$=n93604-1". 
The statement 
PRINTtl,A$;B$ 
would write CAMERA93604-1 to the disk. 
Because 
there are no delimiters, this could not be input 
as 
two separate strings. 
To 
correct 
the 
problem, insert explicit delimiters into the 
PRINTi statement as follows: 
PRINTtl,A$;n,";B$ 
The image written to disk is 
CAMERA, 93604-1 
BASIC-SO COMMANDS AND STATEMENTS 
which can be read back 
variables. 
If 
the 
strings themselves 
semicolons, significant leading blanks, 
returns, or line feeds, write them 
surrounded 
by 
explicit 
Page 2-67 
into 
two 
contain 
quotation 
CHR$ (34) • 
example, let A$="CAMERA, AUTOMATIC" 
For 
B$=" 
93604-1". The statement 
PRINTtl,A$;B$ 
would write the following image to disk: 
CAMERA, AUTOMATIC 
and the statement 
INPUTtl,A$,B$ 
would 
input 
"AUTOMATIC 
93604-1 
"CAMERA" 
to 
93604-1" to B$. To 
A$ 
string 
commas, 
carriage 
to 
disk 
marks, 
and 
and 
separate these 
strings properly on the disk, 
quotes to the disk image using 
statement 
write double 
CHR$(34}. The 
PRINTtl,CHR$(34} ;A$;CHR$(34) ;CHR$(34} ;B$;CHR$(34) 
writes the following image to disk: 
"CAMERA, AUTOMATIC"" 
and the statement 
INPUTtl,A$,B$ 
93604-1" 
would input "CAMERA, AUTOMATIC" to 
" 
93604-1" to B$. 
A$ 
and 
The PRINTt statement may also be used with the 
USING option to control the format of the disk 
file. 
For example: 
PRINTtl,USING"$$ttt.tt,";J;K;L 
For more examples using PRINTt, see Appendix B. 
See also WRITEt, Section 2.6S. 
BASIC-80 COMMANDS AND STATEMENTS 
2.52 PUT 
Format: 
Version: 
Purpose: 
PUT (#]<file number>(,<record number>] 
Page 2-68 
Disk 
To write a record from a random buffer to a 
Remarks: 
Example: 
NOTE: 
random. disk file. 
<file number> is the number under which the file 
was OPENed. If <record number> is omitted, the 
record will have the next available record 
number 
(after the last PUT). 
possible record number is 32767. 
record number is 1. 
The largest 
The smallest 
See Appendix B. 
PRINT#, PRINT# USING, and WRITE# may be used to 
put characters in the random file buffer before 
a 
PUT statement. 
In the case of WRITE#, BASIC-80 pads the buffer 
with spaces up to the carriage return. Any 
attempt to read or write past the end of the 
buffer causes a "Field overflow" error. 
BASIC-80 COMMANDS AND STATEMENTS 
2.53 RANDOMIZE 
Format: 
Versions: 
Purpose: 
Remarks: 
RANDOMIZE [<expression>] 
Extended, Disk 
To reseed the random number generator. 
If <expression> is 
program execution 
printing 
Page 2-69 
omitted, BASIC-80 suspends 
and asks for a value by 
Random Number Seed (-32768 to 32767)? 
before executing RANDOMIZE. 
If the random number generator is not reseeded, 
the RND function returns the same sequence of 
random numbers each time the program is RUN. To 
change the sequence of random numbers every time 
the program is RUN, place a RANDOMIZE statement 
at 
the beginning of the program and change the 
argument with each RUN. 
Example: 
10 RANDOMIZE 
20 FOR 1=1 TO 5 
30 PRINT RND; 
40 NEXT I 
RUN 
Random Number Seed (-32768 to 32767)? 3 (user 
types 3) 
.88598 .484668 .586328 .119426 .709225 
Ok 
RUN 
Random Number Seed (-32768 to 32767)? 4 (user 
types 4 for new sequence) 
.803506 .162462 .929364 .292443 .322921 
Ok 
RUN 
Random Number Seed (-32768 to 32767)? 3 (same 
sequence as first RUN) 
.88598 .484668 .586328 .119426 .709225 
Ok 
BASIC-80 COMMANDS AND STATEMENTS 
2.54 READ 
Format: 
Versions: 
Purpose: 
READ <list of variables> 
8K, Extended, Disk 
Page 2-70 
To read values from a DATA statement and assign 
them to variables. (See DATA, Section 2.10.) 
Remarks: 
A READ statement must always be used in 
conjunction 
with 
a 
DATA statement. 
READ 
statements assign variables to DATA statement 
values on a one-to-one basis. READ statement 
variables may be numeric or string, and the 
values read must agree with the variable types 
specified. If they do not agree, a "Syntax 
error" will result. 
A single READ statement may access one or more 
DATA 
statements (they will be accessed in 
order), or several READ statements may access 
the same DATA statment. 
If 
the number of 
variables in <list of variables> exceeds the 
number of elements in the DATA statement(s), an 
OUT OF DATA message is printed. If the number 
of 
variables specified is fewer than the number 
of elements in the DATA statement(s), subsequent 
READ statements will begin reading data at the 
first unread element. 
If 
there 
are 
no 
subsequent READ statements, the extra data is 
ignored. 
To reread DATA statements from 
the RESTORE statement (see 
2.57) 
Example 1: 
80 FOR I=l TO 10 
90 READ A(I) 
100 NEXT I 
the 
start, use 
RESTORE, Section 
110 DATA 3.08,5.19,3.12,3.98,4.24 
120 DATA 5.08,5.55,4.00,3.16,3.37 
This program segment READs the values 
DATA 
statements 
into the array 
execution, the value of A(l) will be 
so on. 
from the 
A. 
After 
3. 08, 
and 
BASIC-80 COMMANDS AND STATEMENTS 
Example 2: LIST 
10 PRINT "CITY", "STATE", " ZIP" 
20 READ C$,S$,Z 
30 DATA "DENVER,", COLORADO, 80211 
40 PRINT C$,S$,Z 
Ok 
RUN 
CITY 
DENVER, 
Ok 
STATE 
COLORADO 
Page 2-71 
ZIP 
80211 
This program READs string and numeric data from 
the DATA statement in line 30. 
BASIC-80 COMMANDS AND STATEMENTS 
2.55 REM 
Format: 
Versions: 
Purpose: 
Page 2-72 
REM <remark> 
8K, Extended, Disk 
To allow explanatory remarks to be inserted in a 
program. 
Remarks: 
Example: 
REM 
statements are not executed but are output 
exactly as entered when the program is listed. 
REM statements may be branched into (from a GOTO 
or GOSUB statement), and execution will continue 
with the first executable statement after the 
REM statement. 
In the Extended and Disk versions, remarks may 
be 
added to the end of a line by preceding the 
remark with a single quotation mark instead of 
: REM. 
.. 
120 REM CALCULATE AVERAGE VELOCITY 
130 FOR I=1 TO 20 
140 SUM=SUM + V(I) 
or, with Extended and Disk versions: 
120 FOR I=l TO 20 
130 SUM=SUM+V(I) 
140 NEXT I 
~CALCULATE AVERAGE VELOCITY 
BASIC-80 COMMANDS AND STATEMENTS 
2.56 RENUM 
Format: 
Page 2-73 
RENUM [[<new number>] [,[<old number>] [,<increment>]]] 
Versions: 
Purpose: 
Remarks: 
NOTE: 
Examples: 
Extended, Disk 
To renumber program lines. 
<new number> is the first line number to be used 
in 
the new sequence. The default is 10. <old 
number> is the line in the current program where 
renumbering is to begin. 
The default is the 
first line of the program. <increment> is the 
increment to be used in the new sequence. The 
default is 10. 
RENUM also changes all line number references 
following 
GOTO, 
GOSUB, 
THEN, 
ON ••• GOTO, 
ON ••• GOSUB and ERL statements to reflect the new 
line numbers. 
If 
a 
nonexistent line number 
appears after one of these statements, the error 
message "Undefined line xxxxx in yyyyy" is 
printed. The incorrect line number reference 
(xxxxx) is not changed by RENUM, but line number 
yyyyy may be changed. 
RENUM cannot be used to change the order of 
program lines (for example, RENUM 15,30 when the 
program has three lines numbered 10, 20 and 30) 
or 
to 
RENUM 
create line numbers greater than 65529. 
An "Illegal function call" error will result. 
Renumbers the entire program. 
The first new line number 
will be 10. Lines will 
increment by 10. 
RENUM 300,,50 
Renumbers the entire pro
gram. The first new line 
number will be 300. Lines 
will increment by 50. 
RENUM 1000,900,20 Renumbers the lines from 
900 up so they start with 
line number 1000 and 
increment by 20. 
BASIC-80 COMMANDS AND STATEMENTS 
2 • 57 
RESTORE 
Format: 
Versions: 
Purpose: 
RESTORE [<line number>] 
8K, Extended, Disk 
Page 2-74 
To allow DATA statements to be reread from a 
specified line. 
Remarks: 
After a RESTORE statement is executed, the next 
READ statement accesses the first item in the 
first DATA statement in the program. 
If 
<line 
number> is specified, the next READ statement 
accesses the first item in the specified DATA 
statement. 
Example: 
10 READ A,B,C 
20 RESTORE 
30 READ D,E,F 
40 DATA 57, 68, 79 
BASIC-80 COMMANDS AND STATEMENTS 
2.58 RESUME 
Formats: 
Versions: 
Purpose: 
Page 2-75 
RESUME 
RESUME a 
RESUME NEXT 
RESUME <line number> 
Extended, Disk 
To continue program execution after an error 
Remarks: 
Example: 
recovery procedure has been performed. 
Anyone of the four formats shown above may be 
used, depending upon where execution is to 
resume: 
RESUME 
or 
RESUME a 
RESUME NEXT 
Execution resumes at the 
statement which caused the 
error. 
Execution resumes at the 
statement immediately fol
lowing the one which 
caused the error. 
RESUME <line number> Execution resumes at 
<line number>. 
A RESUME statement that is not in an error trap 
routine causes a "RESUME without error" message 
to be pr inted. 
10 ON ERROR GOTO 900 
• 
. 
900 IF (ERR=230) AND (ERL=90) THEN PRINT "TRY 
AGAIN":RESUME 80 
BASIC-SO COMMANDS AND STATEMENTS 
2.59 RUN 
Format 1: 
Versions: 
Purpose: 
Remarks: 
Page 2-76 
RUN [<line number>] 
SK, Extended, Disk 
To execute the program currently in memory. 
If <line number> is specified, execution begins 
on 
that line. 
Otherwise, execution begins at 
the lowest line number. BASIC-SO always returns 
to command level after a RUN is executed. 
Example: 
Format 2: 
Version: 
Purpose: 
Remarks: 
Example: 
RUN 
RUN <filename>[,R] 
Disk 
To load a file from disk into memory and run it. 
<filename> is the name used when the file was 
SAVEd. 
RUN 
(With CP/M and ISIS-II, the default 
extension .BAS is supplied.) 
files and deletes 
closes all open 
current contents of 
designated program. 
option, all data files 
RUN nNEWFILn, R 
See also Appendix B. 
memory before loading 
However, with the 
remain OPEN. 
the 
the 
nRn 
BASIC-SO COMMANDS AND STATEMENTS 
2.60 SAVE 
Format: 
Version: 
Purpose: 
Remarks: 
Page 2-77 
SAVE <filename> [,A I ,P] 
Disk 
To save a program file on disk. 
<filename> is a quoted string that conforms to 
your 
operating 
filenames. 
system"'s 
requirements 
for 
(With CP/M, the default extension 
.BAS is supplied.) If <filename> already exists, 
the file will be written over. 
Use the A option to save the file in ASCII 
format. 
Otherwise, BASIC saves the file in a 
compressed binary format. 
ASCII format takes 
more space on the disk, but some disk access 
requires that files be in ASCII format. 
For 
instance, the MERGE command requires and ASCII 
format file, and some operating system commands 
such as LIST may require an ASCII format file. 
Use the P option to protect the file by saving 
it 
in 
an 
encoded binary format. 
When a 
protected file is later RUN (or LOADed), any 
attempt to list or edit it will fail. 
Examples: 
SAVEnCOM2 n,A 
SAVEnpRoon, P 
See also Appendix B. 
BASIC-80 COMMANDS AND STATEMENTS 
2.61 STOP 
Format: 
Versions: 
Purpose: 
STOP 
Page 2-78 
8K, Extended, Disk 
To terminate program execution and return to 
Remarks: 
Example: 
command level. 
STOP statements may be used anywhere in a 
program to terminate execution. When a STOP is 
encountered, the following message is printed: 
Break in line nnnnn 
Unlike the END statement, the STOP statement 
does not close files. 
BASIC-80 always returns to command level after a 
STOP is executed. 
Execution is resumed by 
issuing a CONT command (see Section 2.8). 
10 INPUT A,B,C 
20 K=AA2*5.3:L=BA3/.26 
30 STOP 
40 M=C*K+100:PRINT M 
RON 
? 1,2,3 
BREAK IN 30 
Ok 
PRINT L 
30.7692 
Ok 
CONT 
115.9 
Ok 
BASIC-SO COMMANDS AND STATEMENTS 
2.62 SWAP 
Format: 
Versions: 
Purpose: 
Remarks: 
SWAP <variab1e>,<variab1e> 
Page 2-79 
EXtended, Disk 
To exchange the values of two variables. 
Any 
type variable may be SWAPped (integer, 
single precision, dQub1e precision, string), but 
the two variables must be of the same type or a 
"Type mismatch" error results. 
Example: 
LIST 
10 A$=" ONE " : B$=" ALL " : C$="FOR" 
20 PRINT A$ C$ B$ 
30 SWAP A$, B$ 
40 PRINT A$ C$ B$ 
RUN 
Ok 
ONE FOR ALL 
ALL FOR ONE 
Ok 
BASIC-80 COMMANDS AND STATEMENTS 
2.63 TRON/TROFF 
Format: 
Versions: 
Purpose: 
Remarks: 
TRON 
TROFF 
Page 2-80 
Extended, Disk 
To trace the execution of program statements. 
As an aid in debugging, the TRON statement 
(executed in either the direct or indirect mode) 
enables a trace flag that prints each line 
number of the program as it is executed. The 
numbers appear enclosed in square brackets. The 
trace flag is disabled with the TROFF statement 
(or when a NEW command is executed). 
Example: 
TRON 
Ok 
LIST 
10 K=lO 
20 FOR J=l TO 2 
30 L=K + 10 
40 PRINT J~K~L 
50 K=K+lO 
60 NEXT 
70 END 
Ok 
RUN 
[10] [20] [30] [40] 1 10 20 
[50] [60] [30] [40] 2 20 30 
[50] [60] [70] 
Ok 
TROFF 
Ok 
BASIC-80 COMMANDS AND STATEMENTS 
2.64 WAIT 
Format: 
Versions: 
Purpose: 
• 
WAIT <port number>, I[,J] 
where I and J are integer expressions 
Page 2-81 
8K, Extended, Disk 
To suspend program execution while monitoring 
the status of a machine input port. 
Remarks: 
The WAIT statement causes execution to be 
suspended until a specified machine input port 
develops a specified bit pattern. The data read 
at 
the port is exclusive OR~ed with the integer 
expression J, and then AND~ed with 1. 
If 
the 
result is zero, BASIC-80 loops back and reads 
the data at the port again. If the result is 
nonzero, 
execution continues with the next 
statement. If J is omitted, it is assumed to be 
CAUTION: 
Example: 
zero 
It is possible to enter an infinite loop with 
the WAIT statement, in which case it will be 
necessary to manually restart the machine. 
100 WAIT 32,2 
BASIC-80 COMMANDS AND STATEMENTS 
2.65 WHILE ••• WEND 
Format: 
Versions: 
Purpose: 
WHILE <expression> 
[<loop statements>] 
WEND 
Page 2-82 
Extended, Disk 
To execute a series of statements in a loop as 
Remarks: 
Example: 
long as a given condition is true. 
If <expression> is not zero (Le., true), <loop 
statements> 
are 
executed 
until 
the WEND 
statement is encountered. BASIC then returns to 
the WHILE statement and checks <expression>. If 
it is still true, the process is repeated. 
it 
is 
If 
not true, execution resumes with the 
statement following the WEND statement. 
WHILE/WEND loops may be nested to any level. 
Each WEND will match the most recent WHILE. An 
unmatched WHILE statement causes a 
nWHILE 
without WENDn error, and an unmatched WEND 
statement causes a nWEND without WHILEn error,. 
90~BUBBLE SORT ARRAY A$ 
100 FLIPS=l ~FORCE ONE PASS 
110 WHILE FLIPS 
115 
120 
130 
FLIPS=O 
FOR I=l TO J-l 
TaRU LOOP 
IF A$(I»A$(I+l) THEN 
SWAP A$(I) ,A$(I+l) :FLIPS=l 
140 
150 WEND 
NEXT I 
BASIC-80 COMMANDS AND STATEMENTS 
2.66 WIDTH 
Format: 
Versions: 
Purpose: 
WIDTH [LPRINT] <integer expression> 
Page 2-83 
Extended, Disk 
To set the printed line width in number of 
Remarks: 
Example: 
characters for the terminal or line printer. 
If the LPRINT option is omitted, the line width 
is 
set at the terminal. If LPRINT is included, 
the line width is set at the line printer. 
<integer expression> must have a value in the 
range 15 to 255. The default width is 72 
characters. 
If <integer expression> is 255, the line width 
is 
"infinite," that is, BASIC never inserts a 
carriage return. However, the position of the 
cursor or the print head, as given by the POS or 
LPOS function, returns to zero after position 
255. 
10 PRINT "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 
RUN 
ABCDEFGHIJKLMNOPQRSTUVWXYZ 
Ok 
WIDTH 18 
Ok 
RUN 
ABCDEFGHIJKLMNOPQR 
STUVWXYZ 
Ok 
BASIC-SO COMMANDS AND STATEMENTS 
2.67 WRITE 
Format: 
Ver~ion: 
Purpose: 
Remark$.: 
WRITE[<list of expressions» 
Page 2-S4 
Disk 
To output data at the terminal. 
If <list of expressions> is omitted, a blank 
line is output. 
If 
<list of expressions> is 
included, the values of te expressions are 
output at thee terminal. The expressions in the 
list may be numeric and/or string expressions, 
and they mu~t be separated by commas. 
When the printed items are output, each item 
will be separated from the last by a comma. 
Printed strings will be delimited by quotation 
marks. 
After the last item in the list is 
printed, BASIC inserts a carriage return/line 
feed. 
WRITE output~ numeric values using the same 
format as the PRINT statement, Section 2.49. 
Example: 
10 A:;SO:B=90:C$="THAT'-S ALL" 
20 WRITE A,B,C$ 
RUN 
SO, 90,"THAT~S ALL" 
Ok 
BASIC-80 COMMANDS AND STATEMENTS 
2.68 WRITEi 
Format: 
Page 2-85 
WRITEi<fi1e number>,<list of expressions> 
Version: 
Purpose: 
Remarks: 
Example: 
Disk 
To write data to a sequential file. 
<file number> is the number under which the file 
was OPENed in "0" mode. The expressions in the 
list are string or numeric expressions, and they 
must be separated by commas. 
The difference between WRITEi and PRINTi is that 
WRITEi inserts commas between the the items as 
they are written to disk and delimits strings 
with quotation marks. 
Therefore, it is not 
necessary for the user to put explicit 
delimiters in the list. A carriage return/line 
feed sequence is inserted after the last item in 
the list is written to disk. 
Let 
A$="CAMERA" 
statement: 
WRITEi1,A$,B$ 
and 
B$="93604-1". 
writes the following image to disk: 
The 
"CAMERA", "93604-1" 
A subsequent INPUTi statement, such as: 
INPUTi1,A$,B$ 
would input "CAMERA" to A$ and "93604-1" to BS. 

Paae 3-1 
CHAPTER 3 
BASIC-80 FUNCTIONS 
The intrinsic functions provided by BASIC-80 are presented 
in 
this chapter. 
The functions may be called from any 
program without further definition. 
Arguments to functions are always enclosed in parentheses. 
In 
the formats given for the functions in this chapter, the 
arguments have been abbreviated as follows: 
X and Y 
I 
and J 
X$ and Y$ 
Represent any numeric expressions 
Represent integer expressions 
Represent string expressions 
If a floating point value is supplied where an integer is 
required, BASIC-80 will round the fractional portion and use 
the resulting integer. 
NOTE 
With the BASIC-80 and BASIC-86 
interpreters, only integer and 
single precision resullts are 
returned by funtions. Double 
precision 
functions 
are 
supported only by the BASIC 
compiler. 
BASIC-80 FUNCTIONS 
3.1 ABS 
Format: 
Versions: 
Action: 
ASS (X) 
Page 3-2 
8K, Extended, Disk 
Returns the absolute value of the expression X. 
Example: 
3.2 ASC 
Format: 
Versions: 
Action: 
Example: 
PRINT ABS(7*(-5» 
35 
Ok 
ASC (X$) 
8K, Extended, Disk 
Returns a numerical value that is the ASCII code 
of 
the 
first character of the string X$. (See 
Appendix M for ASCII codes.) If X$ is null, an 
"Illegal function call" error is returned. 
10 X$ = "TEST" 
20 PRINT ASC (X$) 
RUN 
84 
Ok 
See the CHR$ function 
conversion. 
for 
ASClI-to-string 
BASIC-SO FUNCTIONS 
3.3 ATN 
Format: 
Versions: 
Action: 
ATN(X) 
SK, Extended, Disk 
Returns the arctangent of X in radians. 
Page 3-3 
Result 
is in the range -pi/2 to pi/2. The expression X 
may be any numeric type, but the evaluation of 
ATN is always performed in single precision. 
Example: 
3.4 COBL 
Format: 
Versions: 
Action: 
Example: 
10 INPUT X 
20 PRINT ATN (X) 
RUN 
? 
3 
1.24905 
Ok 
COBL(X) 
Extended, Disk 
Converts X to a double precision number. 
10 A = 454.67 
20 PRINT A:COBL(A) 
RUN 
454.67 454.6700134277344 
Ok 
BASIC-80 FUNCTIONS 
3.5 CRR$ 
Format: 
Versions: 
Action: 
CHR$(I) 
Page 3-4 
8K, Extended, Disk 
Returns a string whose one element has ASCII 
code I. 
CHR$ 
is 
(ASCII codes are listed in Appendix M.) 
commonly used to send a special 
character to the terminal. For instance, the 
BEL character could be sent (CHR$(7» 
as 
a 
preface to an error message, or a form feed 
could be sent (CRR$(12» to clear a CRT screen 
and return the cursor to the home position. 
Example: 
3.6 CINT 
Format: 
Versions: 
Action: 
Example: 
PRINT CHR$ (66) 
B 
Ok 
See the ASC function 
conversion. 
CINT(X) 
Extended, Disk 
for 
ASClI-to-numeric 
Converts X to an integer by rounding the 
fractional portion. 
If 
X is not in the range -32768 to 32767, an "Overflow" error occurs. 
PRINT CINT(45.67) 
46 
Ok 
See the CDBL and CSNG functions for converting 
numbers to the double precision and single 
precision data type. See also the FIX and INT 
functions, both of which return integers. 
BASIC-SO FUNCTIONS 
3.7 COS 
Format: 
Versions: 
Action: 
Example: 
3.S CSNG 
Format: 
Versions: 
Action: 
Example: 
COS (X) 
SK, Extended, Disk 
Returns the cosine of X 
calculation of COS (X) is 
precision. 
10 X = 2 *COS ( .4) 
20 PRINT X 
RUN 
1.S42l2 
Ok 
CSNG (X) 
Extended, Disk 
Converts X to a single precision number. 
10 Ai = 975.3421# 
20 PRINT A#; CSNG{Ai) 
RUN 
975.3421 975.342 
Page 3-5 
in 
radians. 
The 
performed in single 
Ok 
See the CINT and CDBL functions for converting 
numbers to the integer and double precision data 
types. 
BASIC-80 FUNCTIONS 
3.9 CVI, CVS, CVD 
Format: 
Version: 
Action: 
CVI«2-byte string» 
CVS«4-byte string» 
CVD«8-byte string» 
Disk 
Convert string values 
Page 3-6 
to 
numeric 
values. 
Numeric values that are read in from a random 
disk file must be converted from strings back 
into numbers. 
CVI converts a 2-byte string to 
an integer. CVS converts a 4-byte string to a 
single precision number. CVD converts an 8-byte 
string to a double precision number. 
Example: 
3.10 EOF 
Format: 
Version: 
Action: 
Example: 
70 FIELD #1,4 AS N$, 12 AS B$, ••• 
80 GET #1 
90 Y=CVS (N$) 
See also MKI$r MKS$, MKD$, Section 3.25 and 
Appendix B. 
EOF«file number» 
Disk 
Returns -1 (true) if the end of a sequential 
file has been reached. 
Use EOF to test for 
end-of-file while INPUTting, to avoid "Input 
past end" errors. 
10 OPEN "I",l,"DATA" 
20 C=O 
30 IF EOF(l) THEN 100 
40 INPUT #l,M(C) 
50 C=C+l:GOTO 30 
BASIC-80 FUNCTIONS 
3.11 ~ 
Format: 
Versions: 
Action: 
EXP(X) 
8K, Extended, Disk 
Returns e to the power of X. 
<=87.3365. 
Page 3-7 
X must be 
If 
EXP 
overflows, the "Overflown 
error message is displayed, machine infinity 
with the appropriate sign is supplied as the 
result, and execution continues. 
Example: 
3.12 FIX 
Format: 
Versions: 
Action: 
Examples: 
10 X = 5 
20 PRINT EXP (X-I) 
RUN 
54.5982 
Ok 
FIX (X) 
Extended, Disk 
Returns the truncated integer part of X. FIX(X) 
is 
equivalent to SGN(X)*INT(ABS(X». The major 
difference between FIX and INT is that FIX does 
not return the next lower number for negative X. 
PRINT FIX(58.75) 
58 
Ok 
PRINT FIX(-58.75) -58 
Ok 
BASIC-80 FUNCTIONS 
3.13 FRE 
Format: 
Versions: 
Action: 
FRE(O) 
FRE (X$) 
Page 3-8 
8K, Extended, Disk 
Arguments to FRE are dummy arguments. 
FRE 
returns the number of bytes in memory not being 
used by BASIC-80. 
FRE("") forGes a garbage collection before 
returning 
the 
number 
of 
free bytes. 
BE 
PATIENT: garbage collection may take 1 to 1-1/2 
minutes. 
BASIC 
will not initiate garbage 
collection until all free memory has been used 
up. 
Therefore, using FRE("") periodically will 
result in shorter delays for each garbage 
collection. 
Example: 
3.14 HEX$ 
Format: 
Versionsr 
Action: 
Example: 
PRINT FRE(O) 
14542 
Ok 
HEX$ (X) 
Extended, Disk 
Returns 
a 
hexadecimal 
rounded to 
evaluated. 
10 INPUT X 
string 
which 
represents 
value of the decimal argument. 
an 
20 A$ = HEX$ (X) 
integer 
before 
HEX$(X) 
30 PRINT X "DECIMAL IS II 
A$ " HEXADECIMAL II 
RUN 
? 
32 
32 DECIMAL IS 20 HEXADECIMAL 
Ok 
See the OCT$ function for octal conversion. 
the 
X is 
is 
BASIC-80 FUNCTIONS 
3.15 INKEY$ 
Format: 
Action: 
Page 3-9 
INKEY$ 
Returns either a one-character string cont~ining 
a 
character read from the terminal or a null 
string if no character is pending at the 
terminal. 
No characters will be echoed and all 
characters are passed through tto the program 
except 
program. 
for 
Contro1-C, which terminates the 
(With the BASIC Compiler, Contro1-C is 
also passed through to the program.) 
Example: 
3.16 INP 
Format: 
Versions: 
Action: 
Example: 
1000 ~TlMED INPUT SUBROUTINE 
1010 RESPONSE$="" 
1020 FOR I%=l TO TIMELIMIT% 
1030 A$=INKEY$ : IF LEN(A$)=O THEN 1060 
1040 IF ASC(A$)=13 THEN TIMEOUT%=O : RETURN 
1050 RESPONSE$=RESPONSE$+A$ 
1060 NEXT I% 
1070 TIMEOUT%=l : RETURN 
INP (I) 
8K, Extended, Disk 
Returns the byte read from port I. I must be in 
the range 0 to 255. INP is the complementary 
function to the OUT statement, Section 2.47. 
100 A=INP(255) 
BASIC-SO FUNCTIONS 
3.17 INPUT$ 
Format: 
Version: 
Action: 
INPUT$(X[,[#]Y]) 
Disk 
Page 3-10 
Returns a string of X characters, read from the 
terminal or from file number Y. If the terminal 
is used for input, no characters will be echoed 
and all control characters are passed through 
except Control-C, which is used to interrupt the 
execution of the INPUT$ function. 
Example 1: 5 ~LIST THE CONTENTS OF A SEQUENTIAL FILE IN 
HEXADECIMAL 
10 OPEN"I",l,"DATA" 
20 IF EOF(l) THEN 50 
30 PRINT HEX$(ASC(INPUT$(l,#l»); 
40 GOTO 20 
50 PRINT 
60 END 
Example 2: 
• 
100 PRINT "TYPE P TO PROCEED OR S TO STOP" 
110 X$=INPUT$(l) 
120 IF X$="P" THEN 500 
130 IF X$="S" THEN 700 ELSE 100 
BASIC-80 FUNCTIONS 
3.18 INSTR 
Format: 
Versions: 
Action: 
INSTR ( [I, ] X$, Y$) 
Page 3-11 
Extended, Disk 
Searches for the first occurrence of string Y$ 
in 
X$ 
and returns the position at which the 
match is found. 
Optional offset I sets the 
position for starting the search. I must be in 
the range 1 to 255. If I>LEN(X$) or if X$ is 
null or if Y$ cannot be found, INSTR returns O. 
If Y$ is null, INSTR returns I or 1. X$ and Y$ 
may be string variables, string expressions or 
Example: 
NOTE: 
string literals. 
10 X$ = "ABCDEB" 
20 Y$ = "B" 
30 PRINT INSTR(X$,Y$) ;INSTR(4,X$,Y$) 
RUN 
2 
6 
Ok 
If I=O is specified, error message "ILLEGAL 
ARGUMENT IN <line number>" will be returned. 
BASIC-80 FUNCTIONS 
3.19 INT 
Format: 
Versions,: 
Action: 
Examples: 
INT (X) 
8K, Extended, Disk 
Returns the largest integer <=X. 
PRINT INT ( 99. 89) 
99 
Ok 
PRINT INT(-12.ll} -13 
Page 3-12 
Ok 
See the FIX and CINT functions which also return 
integer values. 
3.20 LEFT$ 
Format: 
Versions: 
Action: 
Example: 
LEFT$ (X$, I) 
8K, Extended, Disk 
Returns a string comprised of the leftmost I 
characters of X$. I must be in the range 0 to 
255. 
If I is greater than LEN (X$), the. entire 
string (X$) will be returned. If I=O, the null 
string (length zero) is returned. 
10 A$ = "BASIC-80" 
20 B$ = LEFT$(A$,5} 
30 PRINT B$ 
BASIC 
Ok 
Also see the MID$ and RIGHT$ functions. 
BASIC-80 FUNCTIONS 
3.21 LEN 
Format: 
Versions: 
Action: 
LEN (X$) 
8R, Extended, Disk 
Page 3-13 
Returns the number of characters in X$. 
Example: 
3.22 LOC 
Format: 
Version: 
Action: 
Example: 
Non-printing characters and blanks are counted. 
10 X$ = "PORTLAND, OREGON" 
20 PRINT LEN (X$) 
16 
Ok 
LOC«file number» 
Disk 
With random disk files, LOC returns the next 
record number to be used if a GET or PUT 
(without a record number) is executed. 
With 
sequential files, LOC returns the number of 
sectors (128 byte blocks) read from or written 
to the file since it was OPENed. 
200 IF LOC(l) >50 THEN STOP 
BASIC-80 FUNCTIONS 
3.23 LOG 
Format: 
Versions: 
Action: 
LOG (X) 
Page 3-14 
8K, Extended, Disk 
Returns the-natural logarithm of X. X must be 
greater than zero. 
Example: 
3.24 LPOS 
Format: 
Versions: 
Action: 
Example: 
PRINT LOG ( 45/7 ) 
1.86075 
Ok 
LPOS(X) 
Extended, Disk 
Returns the current position of the line printer 
print head within the line printer buffer. Does 
not necessarily give the physical position of 
the print head. X is a dummy argument. 
100 IF LPOS(X) >60 THEN LPRINT CHR$(13) 
BASIC-80 FUNCTIONS 
3.25 MID$ 
Format: 
Versions: 
Action: 
MID$ (X$, I [ ,J] ) 
8K, Extended, Disk 
Page 3-15 
Returns a string of length J characters from X$ 
beginning with the Ith character. I and J must 
be in the range 1 to 255. If J is omitted or if 
there are fewer than J characters to the right 
of the Ith character, all rightmost characters 
beginning with the Ith character are returned. 
If I>LEN(X$), MID$ returns a null string. 
Example: 
NOTE: 
LIST 
10 A$=nGOOD n 
20 B$=nMORNING EVENING AFTERNOON" 
30 PRINT A$;MID$(B$,9,7) 
Ok 
RUN 
GOOD EVENING 
Ok 
Also see the LEFT$ and RIGHT$ functions. 
If I=O 
is 
specified, error message "ILLEGAL 
ARGUMENT IN <line number>" will be returned. 
3.26 MKI$, MKS$, MKD$ 
Format: 
Version: 
Action: 
MKI$«integer expression» 
MKS$«single precision expression» 
MKD$«double precision expression» 
Disk 
Convert numeric values to string values. 
Any 
numeric value that is plac'ed in a random file 
buffer with an LSET or RSET statement must be 
converted to a string. MKI$ converts an integer 
to a 2-byte string. 
MKS$ converts a single 
precision number to a 4-byte string. MKD$ 
converts a double precision number to an 8-byte 
string. 
Example: 
90 AMT= (K+T) 
100 FIELD #1, 8 AS D$, 20 AS N$ 
110 LSET D$ = MKS$(AMT) 
120 LSET N$ = A$ 
130 PUT #1 
See also CVI, CVS, CVD, Section 3.9 and Appendix 
B. 
BASIC-SO FUNCTIONS 
3.27 OCT$ 
Format: 
Versions: 
Action: 
OCT$ (X) 
Page 3-16 
Extended, Disk 
Returns a string which represents the octal 
value of the decimal argument. X is rounded to 
an integer before OCT$(X) is evaluated. 
Example: 
3.2S PEEK 
Format: 
Versions: 
Action: 
Example: 
PRINT OCT$ (24) 
30 
Ok 
See 
the 
conversion. 
PEEK (I) 
HEX $ 
function 
for 
hexadecimal 
SK, Extended, Disk 
Returns the byte (decimal integer in the range a 
to 
255) 
read from memory location I. With the 
SK version of BASIC-SO, I must be less than 
3276S. 
To 
PEEK at a memory location above 
3276S, subtract 65536 from the desired address. 
With Extended and Disk BASIC-SO, I must be in 
the range a to 65536. PEEK is the complementary 
function to the POKE statement, Section 2.4S. 
A=PEEK (&H5AOO) 
BASIC-80 FUNCTIONS 
3.29 POS 
Format: 
Versions: 
Action: 
POS (I) 
8K, Extended, Disk 
Page 3-17 
Returns the current cursor position. 
The 
leftmost position is 1. X is a dummy argument. 
Example: 
3.30 RIGHT$ 
Format: 
Versions: 
Action: 
Example: 
IF POS(X) >60 THEN PRINT CHR$(13) 
Also see the LPOS function. 
RIGHT$(X$,I) 
8K, Extended, Disk 
Returns the rightmost I characters of string X$. 
If 
I=LEN{X$), returns X$. 
If 
string (length zero) is returned. 
10 A$="DISK BASIC-80" 
20 PRINT RIGHT$(A$,8) 
RUN 
BASIC-80 
Ok 
I=O, the null 
Also see the MID$ and LEFT$ functions. 
BASIC-SO FUNCTIONS 
3.31 RND 
Format: 
Versions: 
Action: 
RND [ (X) ] 
SK, Extended, Disk 
Page 3-1S 
Returns a random number between 0 and 1. 
The 
same sequence of random numbers is generated 
each time the program is RUN unless the random 
number generator is reseeded (see RANDOMIZE, 
Section 2.53). However, X<O always restarts the 
same sequence for any given X. 
X>O or X omitted generates the next random 
number in the sequence. x=o repeats the last 
number generated. 
Example: 
3.32 SGN 
Format: 
Versions: 
Action: . 
10 FOR I=l TO 5 
20 PRINT INT(RND*100); 
30 NEXT 
RUN 
24 
Ok 
30 
SGN(X) 
31 
51 
5 
SK, Extended, Disk 
If X>O, SGN(X) returns 1. 
If X=O, SGN(X) returns O. 
Example: 
If X<O, SGN(X) returns -1. 
ON SGN(X)+2 GOTO 100,200,300 branches to 100 if 
X 
is 
negative, 200 if X is 0 and 300 if X is 
positive. 
BASIC-80 FUNCTIONS 
3.33 SIN 
Format: 
Versions: 
Action: 
Example: 
3.34 SPACES 
Format: 
Versions: 
Action: 
SIN(X) 
8K, Extended, Disk 
Returns the sine of X in 
calculated 
COS(X)=SIN(X+3.l4l59/2) • 
PRINT SIN(1.5) 
.997495 
Ok 
SPACE$(X) 
Extended, Disk 
Page 3-19 
radians. 
in 
single 
SIN (X) 
is 
precision. 
Returns a string of spaces of length X. 
The 
expression X is rounded to an integer and must 
be in the range 0 to 255. 
Example: 
10 FOR I = 1 TO 5 
20 X$ = SPACE$(I) 
30 PRINT X$;I 
40 NEXT I 
RUN 
1 
2 
3 
4 
5 
Ok 
Also see the SPC function. 
BASIC-80 FUNCTIONS 
3.35 SPC 
Format: 
Versions: 
Action: 
SPC (I) 
8K, Extended, Disk 
Page 3-20 
Prints I blanks on the terminal. SPC may only 
be 
used with PRINT and LPRINT statements. I 
must be in the range 0 to 255. 
Example: 
3.36 SQR 
Format: 
Versions: 
Action: 
Example: 
PRINT "OVER" SPC(15) "THERE" 
OVER 
~ERE 
Ok 
Also see the SPACE$ function. 
SQR(X) 
8K, Extended, Disk 
Returns the square root of X. X must be >=0. 
10 FOR X 
20 PRINT 
30 NEXT 
RUN 
10 
15 
20 
25 
Ok 
= 10 TO 25 STEP 5 
X, SQR(X) 
3.16228 
3.87298 
4.47214 
5 
BASIC-80 FUNCTIONS 
3.37 STR$ 
Format: 
Versions: 
Action: 
STR$(X) 
8K, Extended, Disk 
Page 3-21 
Returns a string representation of the value of 
X. 
Example: 
5 REM ARITHMETIC FOR KIDS 
10 INPUT "TYPE A NUMBER";N 
20 ON LEN(STR$(N» GOSUB 30,100,200,300,400,500 
Also see the VAL function. 
3.38 STRING$ 
Formats: 
Versions: 
Action: 
Example: 
STRING$(I,J) 
STRING$(I,X$) 
Extended, Disk
Returns a string of length I whose characters 
all have ASCII code J or the first character of 
X$. 
10 X$ = STRING$(10,45) 
20 PRINT X$ "MONTHLY REPORT" X$ 
RUN ----------MONTHLY REPORT---------
Ok 
BASIC-80 FUNCTIONS 
3.39 TAB 
Format: 
Versions: 
Action: 
TAB (I) 
8K, Extended, Disk 
Spaces to position I on the terminal. 
Page 3-22 
If 
the 
current print position is already beyond space 
I, TAB goes to that position on the next line. 
Space 1 is the leftmost position, and the 
rightmost position is the width minus one. 
I 
must be in the range 1 to 255. TAB may only be 
used in PRINT and LPRINT statements. 
Example: 
3.40 TAN 
Format: 
Versions: 
Action: 
10 PRINT "NAME" TAB (25) "AMOUNT" : PRINT 
20 READ A$ ,B$ 
30 PRINT A$ TAB (25) B$ 
40 DATA "G. T. JONES","$25.00" 
RUN 
NAME 
G. T. JONES 
Ok 
TAN (X) 
8K, Extended, Disk 
AMOUNT 
$25.00 
Returns the tangent of X in radians. TAN (X) is 
calculated 
in 
single 
preclslon. 
If 
overflows, the "Overflow" error message 
TAN 
is 
displayed, machine infinity with the appropriate 
sign is supplied as the . result, and execution 
Example: 
continues. 
10 Y = Q*TAN(X)/2 
BASIC-80 FUNCTIONS 
3.41 USR 
Format : 
Versions: 
Action: 
USR[<digit>] (X) 
Page 3-23 
8K, Extended, Disk 
Calls the user's assembly language subroutine 
with the argument X. <digit> is allowed in the 
Extended and Disk versions only. <digit> is in 
the range 0 to 9 and corresponds to the digit 
supplied with the DEF USR statement for that 
routine. 
If 
<digit> is omitted, USRO is 
assumed. See Appendix x. 
Example: 
3.42 VAL 
Format: 
Versions: 
Action: 
40 B = T*SIN (Y) 
50 C = USR (B/2) 
60 D = USR(B/3) 
VAL (X$) 
8K, Extended, Disk 
Returns the numerical value of string X$. 
VAL 
The 
function also strips leading blanks, tabs, 
and linefeeds from the argument string. 
example, 
VAL (" -3) 
returns -3. 
Example: 
10 READ NAME$,CITY$,STATE$,ZIP$ 
20 IF VAL(ZIP$) <90000 OR VAL(ZIP$) >96699 THEN 
PRINT NAME$ TAB(25) "OUT OF STATE" 
For 
30 IF VAL(ZIP$) >=90801 AND VAL(ZIP$) <=90815 THEN 
PRINT NAME$ TAB(25) "LONG BEACH" 
See the STR$ function for numeric to string 
conversion. 
BASIC-80 FUNCTIONS 
3.43 VARPTR 
Format 1: 
Versions: 
Format 2: 
Version: 
Action: 
VARPTR«variable name» 
Extended, Disk 
VARPTR(t<file number» 
Page 3-24 
Disk 
Format 1: Returns the address of the first byte 
of data identified with <variable name>. A 
value must be assigned to <variable name> prior 
to 
execution of VARPTR. Otherwise an "Illegal 
function call" error results. Any type variable 
name may be used (numeric, string, array), and 
the address returned will be an integer in the 
range 32767 to -32768. If a negative address is 
returned, add it to 65536 to obtain the actual 
address. 
VARPTR is usually used to obtain the address of 
a 
variable or array so it may be passed to an 
assembly language subroutine. A function call 
of 
when 
the form VARPTR(A(O» is usually specified 
passing 
lowest-addressed 
NOTE: 
an 
array, 
element 
so 
of 
that 
the 
the array is 
returned. 
All simple variables should be assigned before 
calling 
VARPTR 
for 
an 
array, because the 
addresses of the arrays change whenever a new 
simple variable is assigned. 
Format 2: For sequential files, returns the 
starting address of the disk I/O buffer assigned 
to <file number>. For random fles, returns the 
address of the FIELD buffer assigned to <file 
number>. 
In Standalone Disk BASIC, VARPTR(t<file number» 
returns the first byte of the file block. See 
Appendix H. 
Example: 
100 X=USR(VARPTR(Y» 
Page A-l 
APPENDIX A 
New Features in BASIC-SO, Release 5.0 
The execution of BASIC programs written under Microsoft 
BASIC, release 4.51 and earlier may be affected by some of 
the new features in release 5.0. Before attempting to run 
such programs, check for the following: 
1. 
2. 
3. 
4. 
5. 
6. 
7. 
New reserved words: CALL, CHAIN, COMMON, WHILE, 
WEND, WRITE, OPTION BASE, RANDOMIZE. 
Conversion from floating point to integer values 
results in rounding, as opposed to truncation. 
This affects not only assignment statements (e.g., 
I%=2.5 results in I%=3) , but also affects function 
and stat~ment evaluations (e.g., TAB(4.5) goes to 
the 5th position, A(1.5) yeilds A(2), and X=11.5 
MOD 4 yields 0 for X). 
The body of a FOR ••• NEXT loop is skipped if the 
initial value of the loop times the sign of the 
step exceeds the final value times the sign of the 
step. See Section 2.22. 
Division by zero and overflow no longer produce 
fatal errors. See Section 1.S.1.2. 
The RND function has been changed so that RND with 
no 
argument is the same as RND with a positive 
argument. The RND function generates the same 
sequence of random numbers with each RUN, unless 
RANDOMIZE is used. See Sections 2.53 and 3.31. 
The rules for PRINTing single preclslon and double 
precision numbers have been changed. See Section 
2.49. 
String space is allocated dynamically, and the 
first argument in a two-argument CLEAR statement 
sets the end of memory. The second argument sets 
the amount of stack space. See Section 2.4. 
Page A-2 
8. 
9. 
10. 
11. 
12. 
13. 
Responding to INPUT with too many or too few items, 
or 
with non-numeric characters instead of digits, 
causes the message "?Redo from start" to be 
printed. 
If 
a 
single variable is requested, a 
carriage return may be entered to indicate the 
default values of 0 for numeric input or null for 
string input. However, if more than one variable 
is requested, entering a carriage return will cause 
the 
"?Redo from start" message to be printed 
because too few items were entered. No assignment 
of 
input values is made until an acceptable 
response is given. 
There are two new field formatting characters for 
use with PRINT USING. 
An ampersand is used for 
variable length string fields, and an underscore 
signifies a literal character in a format string. 
If the expression supplied with the WIDTH statement 
is 
255, 
BASIC uses an "infinite" line width, that 
is, it does not insert carriage returns. 
WIDTH 
LPRINT may be used to set the line width at the 
line printer. See Section 2.66. 
The at-sign and underscore are no longer used as 
editing characters. 
Variable names are significant up to 40 characters 
and can contain embedded reserved words. However, 
reserved words must now be delimited by spaces. To 
maintain compatibility with earlier versions of 
BASIC, spaces will be automatically inserted 
between 
names. 
adjoining reserved words and variable 
WARNING: This insertion of spaces may 
cause the end of a line to be truncated if the line 
length is close to 255 characters. 
BASIC programs may be saved in a protected binary 
format. See SAVE, Section 2.60. 
Page B-1 
APPENDIX B 
BASIC-80 Disk I/O 
Disk I/O procedures for the beginning BASIC-80 user are 
examined in this appendix. If you are new to BASIC-80 or if 
you~re getting disk related errors, read through these 
procedures and program examples to make sure you~re using 
all the disk statements correctly. 
Wherever a filename is required in a disk command or 
statement, use a name that conforms to your operating 
system~s requirements for filenames. 
The CP/M operating 
system will append a default extension .BAS to the filename 
given in a SAVE, RUN, MERGE or LOAD command. 
B.l PROGRAM FILE COMMANDS 
Here is a review of the commands and statements used in 
program file manipulation. 
SAVE' <filename> [,A] 
Writes to disk the program that is 
currently 
residing 
in 
memory. 
Optional A writes the program as a 
series 
of 
ASCII 
characters. 
(Otherwise, BASIC uses a compressed 
binary format.) 
LOAD <filename>[,R] 
Loads the program from disk 
memory. 
into 
Optional R runs the program 
immediately. LOAD always deletes the 
current contents of memory and closes 
all files before LOADing. 
If 
R 
is 
included, however, open data files are 
kept open. 
Thus programs can be 
chained or loaded in sections and 
access the same data files. 
Page B-2 
RUN <filename>[,R] 
MERGE <filename> 
KILL <filename> 
NAME <old filename> 
AS<new filename> 
B.2 PROTECTED FILES 
RUN <filename> loads the program from 
disk into memory and runs it. RUN 
deletes the current contents of memory 
and closes all files before loading 
the program. 
If 
the 
R 
option is 
included, however, all open data files 
are kept open. 
Loads the program from disk into 
memory but does not delete the current 
contents of memory. The program line 
numbers on disk are merged with the 
line numbers in memory. If two lines 
have the same number, only the line 
from the disk program is saved. After 
a 
MERGE command, the "merged" 'progr am 
resides in memory, and BASIC returns 
to command level. 
Deletes the file from the disk. 
<filename> may be a program file, or a 
sequential or random access data file. 
To 
change the name of a disk file, 
execute the NAME 
statement, 
NAME 
<oldfile> AS <newfile>. NAME may be 
used with program files, random files, 
or sequential files. 
If you wish to save a program in an encoded binary format, 
use the "Protect" option with the SAVE command. For 
example: 
SAVE "MYPROG",P 
A program saved this way cannot be listed or edited. 
You 
may also want to save an unprotected copy of the program for 
listing and editing purposes. 
B.3 DISK DATA FILES ~ SEQUENTIAL AND RANDOM I/O 
There are two types of disk data files that may be created 
and accessed by a BASIC-80 program: sequential files and 
random access files. 
Page B-3 
B.3.l Sequential Files 
Sequential files are easier to create than random files but 
are limited in flexibility and speed when it comes to 
accessing the data. 
sequential 
file 
is 
The data that is written to a 
stored, 
one item after another 
(sequentially), in the order it is sent and is read back in 
the same way. 
The statements and functions that are used with sequential 
files are: 
OPEN 
CLOSE 
PRINTi 
PRINTt USING 
EOF 
LOC 
INPUTt 
LINE INPUTI 
WRITEt 
The following program steps are required to create a 
sequential file and access the data in the file: 
1. 
2. 
3. 
4. 
OPEN the file in "0" mode. 
Write data to the file 
using the PRINTI statement. 
(WRITEt may be used instead.) 
To access the data in the 
file, you must CLOSE the file 
and reOPEN it in "I" mode. 
Use theINPUTt statement to 
read data from the sequential 
OPEN "0", 11, "DATA" 
PRINTil,A$;B$;C$ 
CLOSE 11 
OPEN "I", 11, "DATA" 
INPUTI1,X$,Y$,Z$ 
file into the program. 
Program B-1 is a short program that creates a sequential 
file, "DATA", from information you input at the terminal. 
Page B-4 
10 OPEN "0", *1, "DATA" 
20 INPUT "NAME";N$ 
25 IF N$="DONE" THEN END 
30 INPUT "DEPARTMENT";D$ 
40 INPUT "DATE HIRED";H$ 
50 PRINT*1,N$;",";D$1","1H$ 
60 PRINT:GOTO 20 
RUN 
NAME? MICKEY MOUSE 
DEPARTMENT? AUDIO/VISUAL AIDS 
DATE HIRED? 01/12/72 
NAME? SHERLOCK HOLMES 
DEPARTMENT? RESEARCH 
DATE HIRED? 12/03/65 
NAME? EBENEEZER SCROOGE 
DEPARTMENT? ACCOUNTING 
DATE HIRED? 04/27/78 
NAME? SUPER MANN 
DEPARTMENT? MAINTENANCE 
DATE HIRED? 08/16/78 
NAME? etc. 
PROGRAM B-1 - CREATE A SEQUENTIAL DATA FILE 
Page B-5 
Now look at Program B-2. It accesses the file "DATA" that 
was created in Program B-1 and displays the name of everyone 
hir~d in 1978. 
10 OPEN "I",tl,"DATA" 
20 INPUTtl,N$,D$,H$ 
30 IF RIGHT$(H$,2)="78" THEN PRINT N$ 
40 GOTO 20 
R~ 
EBENEEZER SCROOGE 
SUPER MANN 
Input past end in 20 
Ok 
PROGRAM B-2 - ACCESSING A SEQUENTIAL FILE 
Program B-2 reads, sequentially, every item in the file. 
When all the data has been read, line 20 causes an "Input 
past end" error. To avoid getting this error, insert line 
15 which uses the EOF function to test for end-of-file: 
15 IF EOF(l) THEN END 
and change line 40 to GOTO 15. 
A program that creates a sequential file can also write 
formatted data to the disk with the PRINTt USING statement. 
For example, the statement 
PRINTtl,USING"tttt.tt,";A,B,C,D 
could be used to write numeric data to disk without explicit 
delimiters. 
The comma at the end of the format string 
serves to separate the items in the disk file. 
The LOC function, when used with a sequential file, returns 
the number of sectors that have been written to or read from 
the file since it was OPENed. A sector is a l28-byte block 
of data. 
B.3.l.l Adding ~ To A Sequential File 
If you have a sequential file residing on disk and later 
want to add more data to the end of it, you cannot simply 
open the file in "0" mode and start writing data. 
as 
As 
soon 
you open a sequential file in "0" mode, you destroy its 
current contents. The following procedure can be used to 
add data to an existing file called "NAMES". 
Page B-6 
1. 
2. 
3. 
4. 
5. 
6. 
7. 
OPEN "NAMES" in "I" mode. 
OPEN a second file called "COPY" in "0" mode. 
Read in the data in "NAMES" and write it to "COPY". 
CLOSE "NAMES" and KILL it. 
Write the new information to "COPY". 
Rename "COPY" as "NAMES" and CLOSE. 
Now there is a file on disk called "NAMES" that 
includes all the previous data plus the new data 
you just added. 
Program B-3 illustrates this technique. It can be used to 
create or add onto a file called NAMES. This program also 
illustrates the use of LINE INPUT# to read strings with 
embedded commas from the disk file. Remember, LINE INPUT# 
will read in characters from the disk until it sees a 
carriage return (it does not stop at quotes or commas) or 
until it has read 255 characters. 
Page B-7 
10 ON ERROR GOTO 2000 
20 OPEN "I",tl,"NAMES" 
30 REM IF FILE EXISTS, WRITE IT TO "COPY" 
40 OPEN "O",t2,"COPY" 
SO IF EOF(l) THEN 90 
60 LINE INPUTtl,A$ 
70 PRINTt2,A$ 
80 GOTO SO 
90 CLOSE #1 
100 KILL "NAMES" 
110 REM ADD NEW ENTRIES TO FILE 
120 INPUT "NAME";N$ 
130 IF N$="" THEN 200 ~CARRIAGE RETURN EXITS INPUT LOOP 
140 LINE INPUT "ADDRESS? ";A$ 
150 LINE INPUT "BIRTHDAY? ";B$ 
160 PRINTt2,N$ 
170 PRINTt2,A$ 
180 PRINT#2,B$ 
190 PRINT:GOTO 120 
200 CLOSE 
205 REM CHANGE FILENAME BACK TO "NAMES" 
210 NAME "COPY" AS "NAMES" 
2000 IF ERR=53 AND ERL=20 THEN OPEN "O",#2,"COPY":RESUME 120 
2010 ON ERROR GOTO 0 
PROGRAM B-3 - ADDING DATA TO A SEQUENTIAL FILE 
The error trapping routine in line 
not 
exist" error in line 20. 
statements that copy the file are 
created as if it were a new file. 
2000 traps a "File does 
If 
this happens, the 
skipped, and "COPY" is 
B.3.2 Random Files 
Creating and accessing random files requires more program 
steps than sequential files, but there are advantages to 
using random files. One advantage is that random files 
require less room on the disk, because BASIC stores them in 
a 
packed binary format. (A sequential file is stored as a 
series of ASCII characters.) 
The biggest advantage to random files is that data can be 
accessed randomly, i.e., anywhere on the disk -- it is not 
necessary to read through all the information, as with 
sequential files. This is possible because the information 
is stored and accessed in distinct units called records and 
each record is numbered. 
The statements and functions that are used with random files 
are: 
page B-8 
OPEN 
PUT 
MI<I$ 
MKS$ 
MKD$ 
FIELD 
CLOSE 
CVI 
CVS 
CVD 
LSET/RSET 
Loe 
GET 
B.3.2.l Creating A Random File 
The following program steps-are required to create a random 
file. 
1. 
OPEN the file for random 
access ("R" mode). This example 
specifies a record length of 32 
bytes. If the record length is 
omitted, the default is 128 
2. 
3. 
4. 
bytes. 
Use the FIELD statement to 
allocate space in the random 
buffer for the variables that 
will be written to the random 
file. 
Use LSET to move the data 
into the random buffer. 
Numeric values must be made 
into strings when placed in 
the buffer. To do this, use the 
"make" functions: MKI$ to 
make an integer value into a 
string, MKS$ for a single 
precision value, and MKD$ for 
a 
double precision value. 
Write the data from 
the buffer to the disk 
OPEN "R",il,"FILE",32 
FIELD il 20 AS N$, 
'4 
AS A$, 8 AS P$ 
LSET N$=X$ 
LSET A$=MKS$(AMT) 
LSET P$=TEL$ 
PUT il,CODE% 
using the PUT statement. 
Look at Program B-4. It takes information that is input at 
the 
terminal and writes it to a random file. Each time the 
PUT statement is executed, a record is written to the file. 
The 
two-digit code that is input in line 30 becomes the 
record number. 
Page B-9 
NOTE 
Do not use a 
variable in 
statement. 
FIELDed string 
an 
INPUT or LET 
This causes the 
pointer for 
point 
into 
instead of 
buffer. 
10 OPEN "R",ll,"FILE",32 
that variable to 
string 
the 
space 
random file 
20 FIELD 11,20 AS N$, 4 AS A$, 8 AS p$ 
30 INPUT "2-DIGIT CODE"1CODE% 
40 INPUT nNAME"1X$ 
50 INPUT "AMOUNT";AMT 
60 INPUT "PHONE";TEL$:PRINT 
70 LSET N$=X$ 
80 LSET A$=MKS$(AMT) 
90 LSET P$=TEL$ 
100 PUT Il,CODE% 
110 GOTO 30 
PROGRAM B-4 - CREATE A RANDOM FILE 
B.3.2.2 Access A Random File 
The following program steps are required to access a random 
file: 
1. 
2. 
OPEN the file in "R" mode. 
Use the FIELD statement to 
allocate space in the random 
buffer for the variables that 
will be read from the file. 
NOTE: 
In a program that performs both 
input and output on the same random 
file, you can often use just one 
OPEN statement and one FIELD 
statement. 
OPEN "R",ll,"FILE",32 
FIELD 11 20 AS N$, 
4 AS A$, 8 AS p$ 
Page B-10 
3. 
4. 
Use the GET statement to move 
the desired record into the 
random buffer. 
The data in the buffer ma'y 
now be accessed by the program. 
Numeric values must be converted 
back to numbers using the 
"convert" functions: CVI for 
integers, CVS for single 
precision values, and CVD 
for double precision values. 
GET il,CODE% 
PRINT N$ 
PRINT CVS (A$) 
Program B-5 accesses the random file "FILE" that was created 
in 
Program B-4. 
By inputting the three-digit code at the 
terminal, the information associated with that code is read 
from the file and displayed. 
10 OPEN "R",il,"FILE",32 
20 FIELD iI, 20 AS N$, 4 AS A$, 8 AS p$ 
30 INPUT "2-DIGIT CODE"1CODE% 
40 GET tl, CODE% 
50 PRINT N$ 
60 PRINT USING· "$$tti.ii"1CVS(A$) 
70 PRINT P$:PRINT 
80 GOTO 30 
. 
PROGRAM B-5 - ACCESS A RANDOM FILE 
The LOC function, with random files, 
record number." The current record 
last record number that was used in a 
For example, the statement 
IF LOC(l) >50 THEN END 
returns the "current 
number is one plus the 
GET or PUT statement. 
ends program execution if the current record number in 
filetl is higher than 50. 
Program B-6 is an inventory program that illustrates random 
file access. In this program, the record number is used as 
the part number, and it is assumed the inventory will 
contain no more than 100 different part numbers. Lines 
900-960 initialize the data file by writing CHR$(255) as the 
first character of each record. This is used later (line 
270 and line 500) to determine whether an entry already 
exists for that part number. 
Lines 130-220 display the different inventory functions that 
the program performs. When you type in the desired function 
number, line 230 branches to the appropriate subroutine. 
Page B-11 
120 OPEN"R",#1,"INVEN.DAT",39 
125 FIELD#l,l AS F$,30 AS D$, 2 AS Q$,2 AS R$,4 AS P$ 
130 PRINT:PRINT "FUNCTIONS:":PRINT 
135 PRINT 1,"INITIALIZE FILE" 
140 PRINT 2,"CREATE A NEW ENTRY" 
150 PRINT 3,"DISPLAY INVENTORY FOR ONE PART" 
160 PRINT 4,"ADD TO STOCK" 
170 PRINT 5,"SUBTRACT FROM STOCK" 
180 PRINT 6, "DISPLAY ALL ITEMS BELOW REORDER LEVEL" 
220 PRINT:PRINT:INPUT"FUNCTION";FUNCTION 
225 IF (FUNCTION<l) OR (FUNCTION>6) THEN PRINT 
"BAD FUNCTION NUMBER":GO TO 130 
230 ON FUNCTION GOSUB 900,250,390,480,560,680 
240 GOTO 220 
250 REM BUILD NEW ENTRY 
260 GOSUB 840 
270 IF ASC(F$) <>255 THEN INPUT"OVERWRITE";A$: 
IF A$<>"Y" THEN RETURN 
280 LSET F$=CHR$(O) 
290 INPUT "DESCRIPTION";DESC$ 
300 LSET D$=DESC$ 
310 INPUT "QUANTITY IN STOCK";Q% 
320 LSET Q$=MKI$(Q%) 
330 INPUT "REORDER LEVEL";R% 
340 LSET R$=MKI$(R%) 
350 INPUT "UNIT PRICE";P 
360 LSET P$=MKS$(P) 
370 POT#l,PART% 
380 RETURN 
390 REM DISPLAY ENTRY 
400 GOSUB 840 
410 IF ASC(F$) =255 THEN PRINT "NULL ENTRY." : RETURN 
420 PRINT USING "PART NUMBER iii";PART% 
430 PRINT 0$ 
440 PRINT USING "QUANTITY ON HAND #i#ii";CVI(Q$) 
450 PRINT USING "REORDER LEVEL iiiii";CVI(R$) 
460 PRINT USING "UNIT PRICE $$i#.ii";CVS(P$) 
470 RETURN 
480 REM ADD TO STOCK 
490 GOSUB 840 
500 IF ASC(F$) =255 THEN PRINT "NULL ENTRY":RETURN 
510 PRINT D$:INPUT "QUANTITY TO ADD ":A% 
520 Q%=CVI(Q$)+A% 
530 LSET Q$=MKI$(Q%) 
540 PUTi1,PART% 
550 RETURN 
560 REM REMOVE FROM STOCK 
570 GOSUB 840 
580 IF ASC(F$)=255 THEN PRINT "NULL ENTRY":RETURN 
590 PRINT 0$ 
600 INPUT "QUANTITY TO SUBTRACT";S% 
610 Q%=CVI(Q$) 
620 IF (Q%-S%)<O THEN PRINT "ONLY";Q%;" IN STOCK":GOTO 600 
630 Q%=Q%-S% 
Page B-12 
640 IF Q%=<CVI(R$) THEN PRINT "QUANTITY NOW":Q%: 
" 
REORDER LEVEL":CVI(R$) 
650 LSET Q$=MKI$(Q%) 
660 PUTt1,PART% 
670 RETURN 
680 DISPLAY ITEMS BELOW REORDER LEVEL 
690 FOR 1=1 TO 100 
710 GETt1,I 
720 IF CVI(Q$) <CVI(R$) THEN PRINT 0$:" QUANTITY": 
CVI(Q$) TAB (50) "REORDER LEVEL":CVI(R$) 
730 NEXT I 
740 RETURN 
840 INPUT "PART NUMBER":PART% 
850 IF (PART%<l) OR(PART%>100) THEN PRINT "BAD PART .NUMBER": 
GOTO 840 ELSE GETt1,PART%:RETURN 
890 END 
900 REM INITIALIZE FILE 
910 INPUT "ARE YOU SURE":B$:IF B$<>"Y" THEN RETURN 
920 LSET F$=CHR$(255) 
930 FOR 1=1 TO 100 
940 PUTt1,I 
950 NEXT I 
960 RETURN 
PROGRAM B-6 - INVENTORY 
Page C-l 
APPENDIX C 
Assembly Language Subroutines 
All versions of BASIC-80 have prov~s~ons for interfacing 
with assembly language subroutines. The OSR function allows 
assembly language subroutines to be called in the same way 
BASIC~s intrinsic functions are called. 
NOTE 
The addresses of the DEINT, 
GIVABF, 
routines 
locations 
supplied 
MAKINT 
are 
that 
and FRCINT 
stored 
must 
individually 
in 
be 
for 
different implementations of 
BASIC. 
C.l MEMORY ALLOCATION 
Memory space must be set aside for an assembly language 
subroutine before it can be loaded. During initialization, 
enter the highest memory location minus the amount of memory 
needed for the assembly language subroutine(s). BASIC uses 
all memory available from its starting location up, so only 
the topmost locations in memory can be set aside for user 
subroutines. 
When an assembly language subroutine is called, the stack 
pointer is set up for 8 levels (16 bytes) of stack storage. 
If more stack space is needed, BASIC~s stack can be saved 
and a new stack set up for use by the assembly language 
subroutine. BASIC~s stack must be restored, however, before 
returning from the subroutine. 
Page C-2 
The assembly language subroutine may be loaded into memory 
by means of the system monitor, or the BASIC POKE statement, 
or (if the user has the MACRO-80 or FORTRAN-80 package) 
routines may be assembled with MACRO-80 and loaded using 
LINK-80. 
C.2 USR FUNCTION CALLS - 8K BASIC 
The starting address of the assembly language subroutine 
must be stored in USRLOC, a two-byte location in memory that 
is supplied individually with different implementations of 
BASIC-80. 
With 8K BASIC, the starting address may be POKEd 
into USRLOC. Store the low order byte first, followed by 
the high order byte. 
The function USR will call the routine whose address is in 
USRLOC. 
Initially USRLOC contains the address of ILLFUN, 
the routine that gives the "Illegal function call" error. 
Therefore, if USR is called without changing the address in 
USRLOC, an "Illegal function call" error results. 
The format of a USR function call is 
USR (argument) 
where the argument is a numeric expression. To obtain the 
argument, the assembly language subroutine must call the 
routine DEINT. DEINT places the argument into the D,E 
register pair as a 2-byte, 2~s complement integer. (If the 
argument is not in the range -32768 to 32767, an "Illegal 
function call" error occurs.) 
To 
pass the result back from an assembly language 
subroutine, load the value in register pair [A,B], and call 
To 
the routine GIVABF. If GIVABF is not called, USR(X) returns 
X. 
return to BASIC, the assembly language subroutine 
must execute a RET instruction. 
For example, here is an assembly language subroutine that 
mUltiplies the argument by 2: 
USRSUB: CALL DEINT 
XCHG 
DAD H 
MOV A,H 
MOV B,L 
JMP GIVABF 
;put arg in D,E 
;move arg to H, L 
;H,L=H,L+H,L 
;move result to A,B 
;pass result back and RETurn 
Note that valid results will be obtained from this routine 
for 
arguments in the range -16384<=x<=16383. The single 
instruction JMP GIVABF has the same effect as: 
Page C-3 
CALL GIVABF 
RET 
To return additional values to the program, load them into 
memory and read them with the PEEK function. 
There are several methods by which a program may call more 
than one USR routine. For example, the starting address of 
each routine may be POKEd into USRLOC prior to each USR 
call, or the argument to USR could be an index into a table 
of USR routines. 
C.3 USR FUNCTION CALLS - EXTENDED !!Q DISK BASIC 
In the Extended and Disk versions, the format of the USR 
function is 
USR[<digit>] (argument) 
where DIGIT> is from 0 to 9 and the argument is any numeric 
or 
string expression. <digit> specifies which USR routine 
is being called, and corresponds with the digit supplied in 
the DEF USR statement for that routine. If <digit> is 
omitted, USRO is assumed. The address given in the DEF USR 
statement determines the starting address of the subroutine. 
When the USR function call is made, register A contains a 
value that specifies the type of argument that was given. 
The value in A may be one of the following: 
Value in A 
~ of Argument 
2 
3 
4 
8 
Two-byte integer (two~s complement) 
String 
Single precision floating point number 
Double precision floating point number 
If the argument is a number, the [H,L] register pair points 
to 
the Floating Point Accumulator (FAC) where the argument 
is stored. 
If the argument is an integer: 
FAC-3 contains the lower 8 bits of the argument and 
FAC-2 contains the upper 8 bits of the argument. 
If the argument is a single precision floating point number: 
FAC-3, contains the lowest 8 bits of mantissa and 
Page C-4 
FAC-2 contains the middle 8 bits of mantissa and 
FAC-l contains the highest 7 bits of mantissa 
with leading 1 suppressed (implied). Bit 7 is 
the sign of the number (O=positive, l=negative). 
FAC is the exponent minus 128, and the binary 
point is to the left of the most significant 
bit of the mantissa. 
If the argument is a double precision floating point number: 
FAC-7 through FAC-4 contain four more bytes 
of mantissa (FAC-7 contains the lowest 8 bits). 
If the 
argument is a string, the [D,E] register pair points 
to 
3 
string 
255) • 
8 bits 
bytes called the nstring descriptor.n Byte 0 of the 
descriptor contains the length of the string (0 to 
Bytes 1 and 2, respectively, are the lower and upper 
of the string starting address in string space. 
CAUTION: If the argument is a string literal in the 
program, the string descriptor will point to program text. 
Be careful not to alter or destroy your program this way. 
To 
avoid unpredictable results, add +"n to the string 
literal in the program. Example: 
A$ = nBASIC-80n+nn 
This will copy the strin~ literal into string space and will 
prevent alteration of program text during a subroutine call. 
Usually, the value returned by a USR function is the same 
type (integer, string, single precision or double precision) 
as the argument that was passed to it. However, calling the 
MAKINT . routine returns the integer in [H,L] as the value of 
the function, forcing the value returned by the function to 
be 
integer. 
To execute MAKINT, use the following sequence 
to return from the subroutine: 
PUSH 
LHLD 
XTHL 
RET 
H 
xxx 
;save value to be returned 
;get address of MAKINT routine 
;save return on stack and 
;get back [H,L] 
;return 
Also, the argument of the function, regardless of its type, 
may be forced to an integer by calling the FRCINT routine to 
get the integer value of the argument in [H,L]. Execute the 
following routine: 
LXI 
PUSH 
LHLD 
PCHL 
H 
H 
xxx 
;get address of subroutine 
;continuation 
;place on stack 
;get address of FRCINT 
SUBl: . . . . . 
Page C-S 
C.4 CALL STATEMENT 
Extended and Disk BASIC-80 user 
made with the CALL statement. 
the same as that in Microsoft's 
compilers. 
function calls may also be 
The calling sequence used is 
FORTRAN, COBOL and BASIC 
A CALL statement with no arguments generates a simple "CALL" 
instruction. The corresponding subroutine should return via 
a 
simple "RET." (CALL and RET are 8080 opcodes - see an 8080 
reference manual for details.) 
A subroutine CALL with arguments results in a somewhat more 
complex calling sequence. 
For each argument 
argument list, a parameter is passed to the 
That parameter is the address of the low 
argument. Therefore, parameters always occupy 
each, regardless of type. 
in the CALL 
subroutine. 
byte of the 
two bytes 
The method of passing the parameters depends upon the number 
of parameters to pass: 
1. 
2. 
If the number of parameters is less than or equal 
to 
3, they are passed in the registers. Parameter 
1 will be in HL, 2 in DE (if present), and 3 in BC 
(if present). 
If the number of parameters is greater than 3, they 
are passed as follows: 
1. 
Parameter 1 in HL. 
2. 
3. 
Parameter 2 in DE. 
Parameters 3 through n in a contiguous data 
block. 
BC 
will point to the low byte of this 
data block (i.e., to the low byte of parameter 
3) • 
Note that, with this scheme, the subroutine must know how 
many 
parameters 
to 
expect 
in 
order to find them. 
Conversely, the calling program is responsible for passing 
the correct number of parameters. There are no checks for 
the correct number or type of parameters. 
If the subroutine expects more than 3 parameters, and needs 
to 
transfer them to a local data area, there is a system 
subroutine which will perform this transfer. This argument 
transfer routine is named $AT (located in the FORTRAN 
library, FORLIB.REL), and is called with HL pointing to the 
local data area, BC pointing to the third parameter, and A 
containing the number of arguments to transfer (i.e., the 
total number of arguments minus 2). The subroutine is 
Page C-6 
responsible for saving the first two parameters before 
calling $AT. 
For example, if a subroutine expects 5 
parameters, it should look like: 
SUBR: 
PI: 
P2: 
P3: 
SHLD 
XCHG 
SHLD 
MVI 
LXI 
CALL 
. 
PI 
P2 
A,3 
H,P3 
$AT 
iSAVE PARAMETER 1 
iSAVE PARAMETER 2 
iNO. OF PARAMETERS LEFT 
iPOINTER TO LOCAL AREA 
iTRANSFER THE OTHER 3 PARAMETERS 
[Body of subroutine] 
i RETURN TO CALLER 
RET 
DS 
DS 
DS 
iSPACE FOR PARAMETER 1 
iSPACE FOR PARAMETER 2 
2 
2 
6 
iSPACE FOR PARAMETERS 3-5 
A listing of the argument transfer routine $AT follows. 
00100 
00200 
00300 
00400 
00500 
00600 
00700 
00800 
00900 
01000 
01100 
01200 
01300 
01400 
01500 
01600 
01700 
01800 
01900 
02000 
02100 
02200 
02300 
, 
. 
i 
i 
i 
$AT: 
ATl: 
ARGUMENT TRANSFER 
[B, C] 
[H, L] 
[A] 
POINTS TO 3RD PARAM. 
POINTS TO LOCAL STORAGE FOR PARAM 3 
CONTAINS THE t OF PARAMS TO XFER (TOTAL-2) 
ENTRY 
XCHG 
MOV 
MOV 
MOV 
INX 
MOV 
INX 
XCHG 
MOV 
INX 
MOV 
INX 
XCHG 
DCR 
JNZ 
RET 
$AT 
H,B 
L,C 
C,M 
H 
B,M 
H 
M,C 
H 
M,B 
H 
A 
ATI 
iSAVE [H,L] IN [D,E] 
i 
[H,L] = PTR TO PARAMS 
i[B,C] = PARAM ADR 
i 
[H,L] POINTS TO LOCAL STORAGE 
iSTORE PARAM IN LOCAL AREA 
iSINCE GOING BACK TO ATI 
iTRANSFERRED ALL PARAMS? 
iNO, COPY MORE 
i YES, RETURN 
Page C-7 
When accessing parameters in a subroutine, don~t forget that 
they are pointers to the actual arguments passed. 
NOTE 
It 
is 
entirely up to the 
programmer to see to it that 
the arguments in the calling 
program match in number, ~, 
and length with the parameters 
expected by the subroutine. 
This 
applies 
to 
BASIC 
subroutines, as well as those 
written in assembly language. 
C. 5 
INTERRUPTS 
Assembly language subroutines can be written to handle 
interrupts. All interrupt handling routines should save the 
stack, register A-L and the PSW. Interrupts should always 
be 
re-enabled before returning from the subroutine., since 
an interrupt automatically disables all further interrupts 
once it is received. 
The user should be aware of which 
interrupt vectors are free in the particular version of 
BASIC that has been supplied. (Note to CP/M users: In CP/M 
BASIC, all interrupt vectors are free.) 

Page D-l 
APPENDIX D 
BASIC-~O with the CP/M Operating System 
The CP/M version of BASIC-80 (MBASIC) is 
standard size 3740 single density diskette. 
file is MBASIC.COM. 
recommended. ) 
(A 
28K or larger 
supplied on a 
The name of the 
CP/M system is 
To run MBASIC, bring up CP/M and type the following: 
A>MBASIC <carriage return> 
The system will reply: 
xxxx Bytes Free 
BASIC-80 Version 5.0 
(CP/M Version) 
Copyright 1978 (C) by Microsoft 
Created: dd-mmm-yy 
Ok 
MBASIC is the same as Disk BASIC-80 as described in this 
manual, with the following exceptions: 
D.l INITIALIZATION 
The initialization dialog has been replaced by a set of 
options which are placed after the MBASIC command to CP/M. 
The format of the command line is: 
A>MBASIC [<filename>] [/F:<number of files>] [/M:<highest memory location>] 
[/S:<maximum record size>] 
If <filename> is present, MBASIC proceeds as if a RUN 
<filename> 
command were typed after initialization is 
complete. A default extension of .BAS is used if none is 
supplied and the filename is less than 9 characters long. 
This allows BASIC programs to be executed in batch mode 
using the SUBMIT facility of CP/M. Such programs should 
include a SYSTEM statement (see below) to return to CP/M 
when they have finished, allowing the next program in the 
Page 0-2 
batch stream to execute. 
If /F:<number of files> is present, it sets the number of 
disk data files that may be open at anyone time during the 
execution of a BASIC program. 
Each file data block 
allocated in this fashion requires 166 bytes of memory. If 
the /F option is omitted, the number of files defaults to 3. 
The /M:<highest memory location> option sets the highest 
memory location that will be used by MBASIC. In some cases 
it is desirable to set the amount of memory well below the 
CP/M~s 
FOOS 
to 
reserve space for assembly language 
subroutines. In all cases, <highest memory location> should 
be 
below the start of FOOS . (whose address is contained in 
locations 6 and 7). If the 1M option is omitted, all memory 
up to the start of FOOS is used. 
/S:<maximum record size> may be added at the end of the 
command line to set the maximum record size for use with 
random files. The default record size is 128 bytes. 
NOTE 
<number of files>, <highest 
memory location>, and <maximum 
record size> are numbers that 
may be either decimal, octal 
(preceded 
by 
&0) 
or 
hexadecimal (preceded by &H) • 
Examples: 
A>MBASIC PAYROLL. BAS 
A>MBASIC INVENT/F:6 
A>MBASIC /M:32768 
Use all memory and 3 files, 
load and execute PAYROLL. BAS. 
Use all memory and 6 files, 
load and execute INVENT. BAS. 
Use first 32K of memory and 
3 files. 
A>MBASIC OATACK/F:2/M:&H9000 
Use first 36K of memory, 2 
files, and execute OATACK.BAS. 
0.2 DISK FILES 
Disk filenames follow the normal CP/M naming conventions. 
All filenames may include A: or B: as the first two 
characters to specify a disk drive, otherwise the currently 
selected drive is assumed. A default extension of .BAS is 
Page D-3 
used on LOAD, SAVE, MERGE and RUN <filename> commands if no 
"." 
appears in the filename and the filename is less than 9 
characters long. 
For systems with CP/M 2.x, large random files are supported. 
The maximum logical record number is 32767. If a record 
size of 256 is specified, then files up to 8 megabytes can 
be accessed. 
D.3 FILES COMMAND 
Format: 
Purpose: 
Remarks: 
FILES[<filename>] 
To print the names of files residing on the 
current disk. 
If <filename> is omitted, all the files on the 
currently 
selected 
drive 
will be listed. 
<filename> is a string formula which may contain 
question marks (?) to match any character in the 
filename or extension. An asterisk (*) as the 
first character of the filename or extension 
will match any file or any extension. 
Examples: 
FILES 
FILES "*.BAS" 
FILES "B:*.*" 
FILES "TEST?BAS" 
D.4 RESET COMMAND 
Format: 
Purpose: 
Remarks: 
RESET 
To close all disk files and write the directory 
information to a diskette before it is removed 
,from a disk drive. 
Always execute a RESET command before removing a 
diskette from a disk drive. Otherwise, when the 
diskette is used again, it will not have the 
current directory information written on the 
directory track. 
RES~T closes all open files on 
writes the directory track 
with open files. 
all drives and 
to every diskette 
Page 0-4 
0.5 LOF FUNCTION 
Format: 
Action: 
Example: 
0.6 EOF 
LOF«file number» 
Returns the number of records present in the 
last extent read or written. If the file does 
not exceed one extent (128 records), then LOF 
returns the true length of the file. 
110 IF NUM%>LOF(~} THEN PRINT "INVALID ENTRY" 
With CP/M, the EOF function may be used with random files. 
If 
a 
GET is done past the end of file, EOF will return -1. 
This may be used to find the size of a file using a binary 
~earch or other algorithm. 
0.7 MISCELLANEOUS 
1. 
CSAVE and CLOAD are not implemented. 
2. 
3. 
To return to CP/M, use the SYSTEM command or 
statement. 
SYSTEM closes all files and then 
performs a CP/M warm start. Control-C always 
returns to MBASIC, not to CP/M. 
FRCINT is at 103 hex and MAKINT is at 105 hex. 
(Add 1000 hex for ADDS versions, 4000 for SBC CP/M 
versions.) 
Page E-1 
APPENDIX E 
Converting Programs to BASIC-80 
If you have programs written in a BASIC other than BASIC-80, 
some minor adjustments may be necessary before running them 
with BASIC-80. Here are some specific things to look for 
when converting BASIC programs. 
E.1 
STRING DIMENSIONS 
Delete all statements that are used to declare the length of 
strings. 
a 
A statement such as DIM A$(I,J), which dimensions 
string array for J elements of length I, should be 
converted to the BASIC-80 statement DIM A$(J). 
Some BASICs use a comma or ampersand for string 
concatenation. 
sign, which 
concatenation. 
Each of these must be changed to a plus 
is 
the 
operator 
In BASIC-80, the MID$, RIGHT$, and 
for 
BASIC-80 
string 
LEFT$ functions are used 
to 
take substrings of strings. 
access the Ith character in A$, 
substring of A$ from position 
changed as follows: 
Other BASIC 
X$=A$ (I) 
X$=A$(I,J) 
BASIC-80 
X$=MID$ (A$, 1,1) 
Forms such as A$(I) to 
or 
I 
X$=MID$(A$,I,J-I+l) 
A$(I,J) to take a 
to position J, must be 
If the substring reference is on the left side of an 
assignment and X$ is used to replace characters in A$, 
convert as follows: 
Other BASIC 
A$(I)=X$ 
A$(I,J)=X$ 
A$(I)=X$ 
8K BASIC-80 
A$=LEFT$ (A$,I-l) +X$+MID$(A$,I+l) 
A$=LEFT$(A$,I-l) ;X$;MID$(A$,J+l) -----
Ext. and Disk BASIC-80 
MID$(A$,l,l)=X$ 
MID$(A$,I,J-I+l)=X$ 
A$(I,J9=X$ 
Page E-2 
E.2 MULTIPLE ASSIGNMENTS 
Some BASICs allow statements of the form: 
10 LET B=C=O 
to set Band C equal to zero. BASIC-80 would interpret the 
second equal sign as a logical operator and set B equal to -1 if C equaled O. Instead, convert this statement to two 
assignment statements: 
10 C=O:B=O 
E.3 MULTIPLE STATEMENTS 
Some BASICs use a backs1ash (\) to separate multiple 
statements on a line. With BASIC-80, be sure all statements 
on a line are separated by a colon (:). 
E.4 MAT FUNCTIONS 
Programs using the MAT functions available in some BASICs 
must 
be 
properly. 
rewritten using FOR ••• NEXT loops to execute 
Page F-l 
APPENDIX F 
Summary of Error Codes and Error Messages 
Code 
NF 
SN 
Number 
1 
2 
Message 
NEXT without FOR 
A variable in a NEXT statement 
correspond 
to 
any 
previously 
unmatched FOR statement variable. 
Syntax error 
does not 
executed, 
A line is encountered that contains some 
incorrect sequence of characters (such as 
unmatched parenthesis, misspelled command or 
statement, incorrect punctuation, etc.). 
RG 
OD 
3 
4 
Return without GOSUB 
A RETURN statement is encountered for 
there 
is 
statement. 
Out of data 
no 
previous, unmatched 
which 
GOSUB 
A READ statement is executed when there are 
no DATA statements with unread data remaining 
in the program. 
FC 
5 
Illegal function call 
A parameter that is out of range is passed to 
a 
math or string function. An FC error may 
a 
also occur as the result of: 
1. 
negative 
subscript 
2. 
a 
or 
unreasonably 
negative or zero argument with LOG 
3. 
4. 
a 
a 
negative argument to SQR 
large 
negative mantissa with a non-integer 
exponent 
Page F-2 
5. 
6. 
OV 
6 
a 
call to a USR function for which the 
starting address has not yet been given 
an 
improper argument to MID$, LEFT$, 
RIGHT$, INP, OUT, WAIT, PEEK, POKE, TAB, 
SPC, 
STRING$, 
ON ••• GOTO. 
OVerflow 
SPACES, 
INSTR, 
or 
The result of a calculation is too large to 
be 
represented in BASIC-80"'s n,umber format. 
If underflow occurs, the result is zero and 
execution continues without an error. 
OM 
UL 
BS 
7 
8 
9 
Out of memory 
A program is too large, has too many FOR 
loops or GOSUBs, too many variables, or 
expressions that are too complicated. 
Undefined line 
A 
line 
reference 
IF ••• THEN ••• ELSE 
nonexistent line. 
Subscript out of 
An array element 
range 
in 
or 
a 
DELETE 
GOTO, 
is 
GOSUB, 
to 
is referenced either with 
subscript that 
the array, or 
subscripts. 
DD 
10 
is outside the dimensions 
with the wrong number 
Redimensioned array 
a 
a 
of 
of 
Two DIM statements are given for the same 
array, or a DIM statement is given for an 
array after the default dimension of 10 has 
/0 
ID 
TM 
11 
12 
13 
been established for that array. 
Division by zero 
A division by zero is encountered in an 
expression, or the operation of involution 
results in zero being rai.sed to a negative 
power. Machine infinity with the sign of the 
numerator is supplied as the result of the 
division, or positive machine infinity is 
supplied as the result of the involution, and 
execution continues. 
Illegal direct 
A statement that is illegal in direct mode is 
entered as a direct mode command. 
Type mismatch 
A string variable name is assigned a numeric 
value or vice versa; a function that expects 
a 
numeric argument is given a string argument 
or vice versa. 
Page F-3 
os 
LS 
ST 
CN 
UF 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
Out of string space 
String variables have caused BASIC to exceed 
the amount of free memory remaining. BASIC 
will allocate string space dynamically, until 
it runs out of memory. 
String too long 
An attempt is made to create a string more 
than 255 characters long. 
String formula too complex 
A string expression is too long or too 
complex. 
The expression should be broken 
into smaller expressions. 
Can~t continue 
An attempt is made to continue a program 
that: 
1. 
2. 
3. 
has halted due to an error, 
has been modified during a break in 
execution, or 
does not exist. 
Undefined user function 
A USR function is called before the function 
definition (DEF statement) is given. 
Extended and Disk Versions Only 
No RESUME 
An error trapping routine is entered but 
contains no RESUME statement. 
RESUME without error 
A RESUME statement is encountered before an 
error trapping routine is entered. 
Unprintable error 
An error message is 
error 
condition 
usually caused by 
not available 
which exists. 
an ERROR with an 
error code. 
Missing operand 
fur 
~e 
This is 
undefined 
An expression contains an operator with no 
operand following it. 
Line buffer overflow 
An attempt is made to input a line that has 
too many characters. 
Page F-4 
26 
29 
30 
50 
51 
52 
53 
54 
55 
57 
FOR without NEXT 
A FOR was encountered without a matching 
NEXT. 
WHILE without WEND 
A WHILE statement does not have a-- matching 
WEND. 
WEND without WHILE 
A WEND was encountered without a matching 
WHILE. 
Disk Errors 
Field overflow 
A FIELD statement is attempting to allocate 
more bytes than were specified for the record 
length of a random file. 
Internal error 
An internal malfunction has occurred in Disk 
BASIC-80. 
Bad file number 
A statement or command references a file with 
a 
file number that is not OPEN or is out of 
the range of file numbers specified at 
initialization. 
File not found 
A LOAD, KILL or OPEN statement references a 
file that does not exist on the current disk. 
Bad file mode 
An attempt is made to use PUT, GET, or LOF 
with a sequential file, to LOAD a random file 
or to execute an OPEN with a file mode other 
than I, 0, or R. 
File already open 
A sequential output mode 
file that is already 
given for a file that is 
Disk I/O error 
An 
I/O error occurred 
operation. 
It 
is 
a 
OPEN is issued for a 
open1 
open. 
on 
or a KILL is 
a 
disk 
I/O 
fatal error, i. e. , the 
operating system cannot recover from the 
error. 
Page F-5 
58 
61 
62 
63 
64 
66 
67 
File already exists 
The filename specified in a NAME statement is 
identical to a filename already in use on the 
disk. 
Disk full 
All disk storage space is in use. 
Input past end 
An INPUT statement is exeucted after all the 
data in the file has been INPUT, or for a 
null. (empty) file. To avoid this error, use 
the EOF function to detect the end of file. 
Bad record number 
In a PUT or GET statement, the record number 
is 
either greater than the maximum allowed 
(32767) or equal to zero. 
Bad file name 
An illegal form is used for the filename with 
LOAD, 
SAVE, 
KILL, or OPEN (e.g., a filename 
with too many characters). 
Direct statement in file 
A direct statement is encountered while 
LOADing an ASCII-format file. The LOAD is 
terminated. 
Too many files 
An attempt is made to create a new file 
(using SAVE or OPEN) when all 255 directory 
entries are full. 

Page G-l 
APPENDIX G 
Mathematical Functions 
Derived Functions 
Functions that are not intrinsic to BASIC-80 may be 
calculated as follows. 
Function 
SECANT 
COSECANT 
COTANGENT 
INVERSE SINE 
INVERSE COSINE 
INVERSE SECANT 
INVERSE COSECANT 
INVERSE COTANGENT 
HYPERBOLIC SINE 
HYPERBOLIC COSINE 
HYPERBOLIC TANGENT 
HYPERBOLIC SECANT 
HYPERBOLIC COSECANT 
HYPERBOLIC COTANGENT 
INVERSE HYPERBOLIC 
SINE 
INVERSE HY~ERBOLIC 
COSINE 
INVERSE HYPERBOLIC 
TANGENT 
INVERSE HYPERBOLIC 
SECANT 
INVERSE HYPERBOLIC 
COSECANT 
INVERSE HYPERBOLIC 
COTANGENT 
BASIC-80 Equivalent 
SEC(X)=l/COS(X) 
CSC(X)=l/SIN(X) 
COT(X)=l/TAN(X) 
ARCSIN(X)=ATN(X/SQR(-X*X+l» 
ARCCOS(X)=-ATN (X/SQR(-X*X+l»+1.5708 
ARCSEC(X)=ATN(X/SQR(X*X-l» 
+SGN(SGN(X)-l) *1.5708 
ARCCSC(X)=ATN(X/SQR(X*X-l» 
+(SGN(X)-l) *1.5708 
ARCCOT(X) =ATN(X) +1.5708 
SINH(X)=(EXP(X)-EXP(-X»/2 
COSH(X)=(EXP(X)+EXP(-X»/2· 
TANH(X)=EXP(-X)/EXP(X)+EXP(-X»*2+1 
SECH(X)=2/(EXP(X)+EXP(-X» 
CSCH(X)=2/(EXP(X)-EXP(-X» 
COTH(X)=EXP(-X)/(EXP(X)-EXP(-X»*2+1 
ARCSINH(X)=LOG(X+SQR(X*X+1» 
ARCCOSH(X)=LOG(X+SQR(X*X-1) 
ARCTANH(X)=LOG«1+X)/(1-X»/2 
ARCSECH(X)=LOG«SQR(-X*X+1)+1)/X) 
ARCCSCH(X)=LOG«SGN(X)*SQR(X*X+1)+1)/X 
ARCCOTH(X)=LOG«X+1)/(X-l»/2 

Page H-l 
APPENDIX H 
ASCII Character Codes 
ASCII 
Code 
000 
001 
002 
003 
004 
005 
006 
007 
008 
009 
010 
011 
012 
013 
014 
015 
016 
017 
018 
019 
020 
021 
022 
023 
024 
025 
026 
027 
028 
029 
030 
031 
032 
033 
034 
035 
036 
037 
038 
039 
040 
041 
042 
ASCII 
Character 
NUL 
SOH 
STX 
ETX 
EOT 
ENQ 
ACK 
BEL 
BS 
HT 
LF 
VT 
FF 
CR 
50 
SI 
DLE 
DC1 
DC2 
DC3 
DC4 
NAK 
SYN 
ETB 
CAN 
EM 
SUB 
ESCAPE 
FS 
GS 
R5 
US 
SPACE 
! 
n 
t 
$ 
% 
& 
~ 
( 
) 
* 
Code 
043 
044 
045 
046 
047 
048 
049 
050 
051 
052 
053 
054 
055 
056 
057 
058 
059 
060 
061 
062 
063 
064 
065 
066 
067 
068 
069 
070 
071 
072 
073 
074 
075 
076 
077 
078 
079 
080 
081 
082 
083 
084 
085 
ASCII codes are in decimal. 
Character 
+ 
, 
· 
/ 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
· 
· 
, 
· 
< 
= 
> 
? 
@ 
A 
B 
C 
D 
E 
F 
G 
H 
I 
J 
K 
L 
M 
N 
0 
P 
Q 
R 
5 
T 
U 
ASCII 
Code 
086 
087 
088 
089 
090 
091 
092 
093 
094 
095 
096 
097 
098 
099 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
Character 
V 
W 
X 
Y 
Z 
{ 
\ 
] 
A 
< 
~ 
a 
b 
c 
d 
e 
f 
9 
h 
i 
j 
k 
1 
m 
n 
0 
P 
q 
r 
s 
t 
u 
v 
w 
x 
Y 
z 
{ 
} 
DEL 
LF=Line Feed, FF=Form Feed, CR=Carriage Return, DEL=Rubout 

Page I-I 
INDEX 
ABS 
• •. 
. 
• • • • • • . 3-2 
Addition • • ••••••. 1-10 
ALL 
. 
.. 
• . . • . • • . 
. 
2-4, 2-9 
Arctangent • • •• •••• 3-3 
Array variables ••••••• 1-7, 2-9, 2-18 
Arrays •••••••••••• 1-7, 
Ase 
• • • • • • • • • • • • • 3-2 
ASCII codes ••••••••• 3-2, 
ASCII format ••••••••• 2-4, 
Assembly language subroutines 2-3, 
C-1 
ATN 
. . . . . . . 
AUTO . . . . . . . . . 
Boolean operators 
CALL • • • • • • 
Carriage return 
. 
. 
. 
. 
. 
. 
• • • 3-3 
• • 1-2, 
• 1-12 
. 
. 
. 
. 
. 
. 
. 
. 
2-3, 
1-3, 
2-83 
Cassette tape •••••••• 2-7, 
2-7, 2-11, 2-24 
3-4 
2-49, 2-77 
2-16, 2-59, 3-23 to 3-24, 
2-2 
C-5 
2-36, 2-41 
to 2-85 
2-11 
CHAIN • • • • • • • • •• 2-4, 2-9 
COBL • • • • •• •• • • • 3-3 
Character set • • • • •• 1-3 
CHR$ • • • • • • • • • • • • • 3-4 
CINT • • • • • • • • • • • • • 3-4 
CLEAR • • • • • • • • •• 2-6, A-l 
CLOAO • • • • • •• • • • 2-7 
CLOAD* • • • • • . • • • • • • 2-7 
CLOAD? • • • • 
• • • • 2-7 
CLOSE • • • • • • • • 2-8, B-3, B-8 
Command level • • •• •• 1-1 
COMMON •••••••••••• 2-4, 2-9 
Concatenation • • • • • • • • 1-15 
Constants 
• • • • •• 1-4 
CONT ••••••••••••• 2-10, 2-41 
Control characters • • • • • • 1-4. 
Contro1-A • • • • • • • • • • 2-22 
COS 
• • • • • • • • • • • • • 3-5 
to 2-42, 
CP/M ••••••••••••• 2-46, 2-49, 2-76 to 2-77, 
B-1, 0";'1 
CSAVE • • • • • • • • • • • • 2-11 
CSAVE* • • • • • • • • • • • • 2-11 
CSNG • • • • • • • 3-5 
CVD • •• •• • • •• 3-6, B-8 
CVI 
CVS 
••••••••• 3-6, B-8 
••••••• 3-6, B-8 
DATA 
· 
DEF FN·. 
DEF OSR 
DEFDBL • 
DEFINT · 
DEFSNG · 
DEFSTR · 
DEINT 
DELETE · 
DIM 
Direct mode 
Division • 
Double precision · 
EDIT · 
Edit mode 
END 
EOF 
ERASE 
ERL 
ERR 
ERROR 
• .. 
Error codes 
2-12, 2-74 
2-13 
2-~6, 3-23 
1-7, 2~15 
• 
• 
• 
• 
1-7, 2-15 
1-7, 2-15 
1-7, 2-15 
· C-1. 
1-2, 2-4, 2-17 
2-18 
1-1, 2-34, 2-54 
1-10 
Page I-2 
• 1-5, 2-15, 2-60, 3-3, A-1, 
• • 
• • 
• 
• 
• 
• 
1-2, 2-19 
1-4, 2-19 
2-8, 2-10, 2-23, 2-3/ 
3-6, B-3, B-5, D-4 
• • • • 2-24 
• 
• 
• 
• 2-25 
2-25 
• • • 2-26 
• 
Error messages · • • 1-16 
1-16, 2-25 to 2-26 
Error trapping • • • • 2-25 to 2-26, 2-54, 2-75, 
Escape · • 
EXP 
• 
Exponentiation · 
Expressions 
FIELD 
FILES 
FIX 
FOR ••• NEXT · 
FRE 
FRCINT · 
Functions 
GET 
GIVABF • 
GOSUB 
GOTO · 
HEX$ • 
Hexadecimal 
IF ••• GOTO 
IF ••• THEN 
IF ••• T.HEN ••• ELSE · 
B-7 
• 
• 
• 
• 
• 
• 
• 
• 
• 1-3, 2-19 
• 
3-7 
• • • 1-10 to 1-11 
• 
• 
1-9 
2-28, B-8 
• 
• 
· D-3 
3-7 
• 2-29, A-1 
• 
3-8 
· C-1, C-4, D-4 
1-14, 2-13, 3-1 
• • • • 2-28, 2-31, B-8, D-4 
· C-1 to C-2 
• 2-32 
• 
• 
• 
2-32 to 2-33 
3-8 
1-5, 3-8 
2-34 
2-25, 2-34 
2-34 
Indirect mode • • • • • • • • 1-1 
INKEY$ • .• • • • • • • • 3-9 
INP 
• . • . . . . . . • • • . 3-9 
Fage I-3 
INPUT • • • • •••• 2-10, 2-28, 2-36, A-2, 
B-9 
INPUT$ • . . . . . . . . . 3-10 
INPUTt • • • • • • • • • • • . 8-.. 3 
INPUTt • • • • • • • • •• 2-38 
INSTR • • • • • • • • • • • • 3-11 
INT 
• • • • • • • • • • • • • 3-7, 3-12 
Integer •• • . 
Inreaer division • 
• •• 3-4, 3-7, 3-12 
• • 1-10 
Interrupts • • • • • • • • • • C-7 
ISIS-II • • • • • • • • • • • 2-76 
KILL •• 
• • 2-39, B-2 
LEFT$ 
LEN 
LET 
••••• ••••• 3-12 
• • • • • • • • • • • • • 3-13 
••••••••••••• 2-28, 2-40, B-9 
Line feed 
•••••••• 1-2, 2-36, 2-41 to 2-42, 
2-84 to 2-85 
LINE INPUT 
•••• • • 2-41 
LINE INPUTt • • • • • • • • • B-3 
LINE INPUTt • • • •• • • 2-42 
Line numbers ••••••••• 1-1 to 1-2, 2-2, 2-73 
Line printer ••••••••• 2-45, 2-47, 2-83, 3-14, 
A-2 
Lines 
• • • • • • •• 1-1 
LIST ••••••••••••• 1-2, 2-43 
LLIST • • • • • • • • • • • • 2-45 
LOAD ••••••••••••• 2-46, 2-77, B-1 
LOC 
LOF 
LOG 
• • • • • • • •••• 3-13, B-3, B-5, B-8 
• • • • • • • • • • • D-4 
• • • • • • • •••• 3-1,* 
Logical operators • • • • • • 1-12 
Loops • • •• • ••••• 2-29, 2-82 
LPOS ••••••••••••• 2-83, 3-14 
LPRINT •••••••••••• 2-47, 2-83 
LPRINT USING 
.•• • • 2-47 
LSET • • • • • • • •• •• 2-48, B-8 
MAKINT 
MBASIC 
••••••• C-1, C-4, D-4, 
• • • • • • • D-1 
MERGE • • • • • • • • 2-4, 2-49, B-2 
MID$ • • • • • • • 2-50, 3-15 
MKD$ • • • • • • • • • • • • • 3-15, B-8 
MKI$ • • • • • • • • • •• 3-15, B-8 
MKS$ • ••• • • • •••• 3-15, B-8 
MOD operator • • • . • •• 1-11 . 
Modulus arithmetic • 
1-11 
Multiplication • • . . . • 1-10 
Page I-4 
NAME •• •• • • • • 
Negation . • . • • • • • 
NEW 
• • • . • • 
NULL • • • • • • • • • • 
Numeric constants . • • 
Numeric variables • • • 
· 
· 
2-51 
1-10 
• 2-8, 2-52 
• 2-53 
· 
• • 1-4 
• 1-7 
OCT$ • • • •• •••••• 3-16 
Octal • • . . 
ON ERROR GOTO 
. 
. 
•. 
• • • 1-5" 
• 2-54 
ON ••• GOSUB • • • • • •• • 2-55 
ON ••• GOTO 
•••••• ~ ••• 2-55 
OPEN • . • • 
Operators · . . · . . . 
• 2-8, 
B-8 
3-16 
2-28, 2-56, B-3, 
• 1-9, 1-11 to 1-13, 1-15 
OPTION BASE 
OUT 
• • • • • • • 2-57 
• • • • . • • • • • • 2-58 
Overflow • • • • • • • •• 1-11, 3-7, 3-22, A-1, 
Overlay 
• 2-4 
Paper tape · 
PEEK · 
· · · · · · · 2-53 
· · · · · · · · · · 2-59, 3-16 
POS 
POKE · • · · · · · · · · · · · 2-59, 3-16 
· · · · · · · · 
PRINT · · · · · · 
PRINT USING 
· · · 
· 2-83, 3-17 
· · · · 2-60, A-1 
· · 2-62, A-2 
PRINTi USING • • • • • • • • • B-5 
PRINTi USING • • • • • • • B-3 
PRINTi • • • • • • • • • • B-3 
PRINTi USING . 
• • . • 2-66 
PRINTi • • • • • • • • • • • • 2-66 
Protected files 
PUT 
• 2-77, A-2, B-2 
• • • • • • ••••• 2-28, 2-68, B-8 
Random files • 
Random numbers 
• 2-28, 2-31, 
2-56, 2-68, 
B-7, D-4 
• 2-69, 3-18 
RANDOMIZE •• 
READ • •• •••• 
Relational operators 
REM 
• •.• 2-69, 3-18, 
· 
• 2-70, 2-74 
• . • 1-11 
• • •• •••• • • • 2-72 
RE~UM 
2-39, 2-48, 
3-13, 3-15, 
A-1 
•••••••••• 2-4, 2-25, 2-73 
RESET • • • • • • . • • • • • D-3 
RESTORE • • • • • • • 2-74 
RESUME • • • • • • • • • • • • 2-75 
RETURN • • • • • • • • • • • • 2-32 
RIGHT$ • • • • • • •••• 3-17 
RND 
• •• .• • • • • 2-69, 3-18, A-1 
RSET • •• • . • • •• 2-48, B-8 
Rubout •••••••••••• 1-3, 1-15, 2-20 
RUN 
••••.•••••••• 2-76 to 2-77, B-2 
SAVE • 
• • 2-46, 2-76 to 2-77, B-1 
Page I-S 
SBC 
• • • • • • • • • · . • • G-1 
Sequential files • • • · . 
SGN 
• • • • • • • • • 
2-38 to 2-39, 2-42, 2-56, 
2-66, 2-85, 3-6, 3-13, 
B-3 
· . . • 3-18 
S-IN 
• • • • • • • • • 
Single precision • 
SPACES • • • • • • 
SPC 
SQR" 
• • • • • • • • • 
• • • • • • • • • 
· 
· . . • 3-19 
. 
. 
. 
1-5, 2-15, 2-60, 3-5, A-1 
• • 3-19 
• • • • 3-20 
• • • • 3-20 
STOP. · . . . . . . . · . . • 2-10, 2-23, 2-32, 2-78, 
STR$ • • • • • • • • • • • 3-21 
String constants • 
• • • • 1-4 
String functions • • • 3-6, 3-11 to 3-13, 3-15, 
3-17, 3-21, 3-23 
String operators • • • • • • • 1-15 
Str ing space • • • • • • • • • 2-6, 3-8, A-1, B-9 
String variables ••••••• 1-7, 2-15, 2-41 to 2-42 
STRING$ ••••• •• • • 3-21 
Subroutines ••••••••• 2-3, 2-32, 2-55, C-1 
Subscripts •••••••••• 1-7, 2-18, 2-57 
Subtraction ••••• • • • • 1-10 
SWAP • • • • • • • • • • • • • 2-79 
SYSTEM • • • • • • • • • • • • 0-4 
TAB 
Tab 
TAN 
· . . . . . . . 
· . . . . . . . . 
. . . . . . . 
· 
TROFF • • • • • • • • 
TRON • • • • • • • • • 
OSR 
• • • • • • • 
• • • 3-22 
• • • • 1-3 to 1-4 
• • • 3-2~ 
· . . 
· . . • 2-80 
• 2-80 
OSRLOC • • • • • • • 
• ••• 2-16, 3-23, C-1 
· 
VAL ••• 
Variables 
. 
. 
. 
. 
C-2 
• • • • • • • • • • 3-23 
VARPTR •• 
WAIT • · · 
WHILE 
WEND • · · 
WIDTH · · 
· 
· . · . . . 
• • 1-6 
• • • • • • • • • • 3-24 
· • • • 
• • 
· · • • 
· • • 
· • 
· • 2-81 
· • • 2-82 
· • 
· · · · · · · • · · 2-82 
· • • 
· • • 
· • 2-83, 
WIDTH LPRINT • • · • · · · · · 2-83, 
WRITE • · • · • • • · · · · • 2-84 
WRITE# • • · • • · · • • • · • B-3 
WRITE# · · • · • • • · · · • · 2-85 
A-2 
A-2 