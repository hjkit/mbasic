# MBASIC 2025 String System - Compiler Implementation Manual

## Overview

This manual describes how the MBASIC compiler should generate C code to use the string runtime system. The system provides efficient O(n log n) garbage collection, string sharing, and memory optimization while maintaining full BASIC string semantics.

## 1. Compile-Time Analysis

### 1.1 Count String Descriptors

The compiler must determine `MB25_NUM_STRINGS` at compile time by counting:

```
Simple variables:     NAME$, CITY$, etc.
DEFSTR variables:     DEFSTR A-C creates A$, B$, C$
Array elements:       DIM NAMES$(10) needs 10 descriptors
                     DIM GRID$(5,5) needs 25 descriptors
Function parameters:  DEF FNA$(X$) needs 1 for X$
Expression temps:     Each complex expression needs temporaries
Statement temps:      MID$ statement, INPUT, etc.
```

**Formula:**
```
MB25_NUM_STRINGS = simple_vars + defstr_vars + array_cells +
                   function_params + max_expr_temps + statement_temps
```

### 1.2 Assign String IDs

Each string gets a unique ID from 0 to MB25_NUM_STRINGS-1:

```c
/* Example assignments generated by compiler */
#define STR_NAME     0  /* NAME$ */
#define STR_CITY     1  /* CITY$ */
#define STR_NAMES_0  2  /* NAMES$(0) */
#define STR_NAMES_1  3  /* NAMES$(1) */
/* ... */
#define STR_TEMP_1   50 /* Expression temporary 1 */
#define STR_TEMP_2   51 /* Expression temporary 2 */
```

### 1.3 Generate Header

```c
/* Generated at top of output file */
#define MB25_NUM_STRINGS 52  /* Calculated total */
#define MB25_POOL_SIZE 8192  /* Or calculated based on program */
#include "mb25_string.h"
```

## 2. Code Generation Patterns

### 2.1 String Literals

**BASIC:** `A$ = "Hello"`

**Generated C:**
```c
mb25_string_alloc_const(STR_A, "Hello");
```
- No pool allocation
- Points directly to string literal in program memory

### 2.2 String Assignment

**BASIC:** `B$ = A$`

**Generated C:**
```c
mb25_string_copy(STR_B, STR_A);
```
- May share data (both become non-writeable)
- Efficient memory usage

### 2.3 String Input

**BASIC:** `INPUT A$`

**Generated C:**
```c
char input_buffer[256];
fgets(input_buffer, 256, stdin);
/* Remove newline */
size_t len = strlen(input_buffer);
if (len > 0 && input_buffer[len-1] == '\n') {
    input_buffer[len-1] = '\0';
}
mb25_string_alloc_init(STR_A, input_buffer);
```

### 2.4 String Concatenation

**BASIC:** `C$ = A$ + B$`

**Generated C:**
```c
mb25_string_concat(STR_C, STR_A, STR_B);
```

**BASIC:** `D$ = A$ + "!" + B$`

**Generated C (using temporaries):**
```c
mb25_string_alloc_const(STR_TEMP_1, "!");
mb25_string_concat(STR_TEMP_2, STR_A, STR_TEMP_1);
mb25_string_concat(STR_D, STR_TEMP_2, STR_B);
```

### 2.5 Substring Functions

**BASIC:** `L$ = LEFT$(A$, 5)`

**Generated C:**
```c
mb25_string_left(STR_L, STR_A, 5);
```
- Creates shared reference (no copying)
- A$ becomes non-writeable

**BASIC:** `R$ = RIGHT$(A$, 3)`

**Generated C:**
```c
mb25_string_right(STR_R, STR_A, 3);
```

**BASIC:** `M$ = MID$(A$, 3, 4)`

**Generated C:**
```c
mb25_string_mid(STR_M, STR_A, 3, 4);  /* Note: 1-based indexing */
```

### 2.6 MID$ Statement

**BASIC:** `MID$(A$, 3) = "XX"`

**Generated C:**
```c
mb25_string_mid_assign(STR_A, 3, (uint8_t *)"XX", 2);
```
- Modifies in place if writeable
- Makes copy if shared/constant (transparent)

### 2.7 String Comparison

**BASIC:** `IF A$ = B$ THEN ...`

**Generated C:**
```c
if (mb25_string_compare(STR_A, STR_B) == 0) {
    /* ... */
}
```

**BASIC:** `IF A$ < B$ THEN ...`

**Generated C:**
```c
if (mb25_string_compare(STR_A, STR_B) < 0) {
    /* ... */
}
```

### 2.8 String Functions

**LEN(A$):**
```c
len = mb25_get_length(STR_A);
```

**ASC(A$):**
```c
uint8_t *data = mb25_get_data(STR_A);
if (data && mb25_get_length(STR_A) > 0) {
    ascii_code = data[0];
} else {
    /* Error: empty string */
}
```

**CHR$(n):**
```c
char chr_buf[2] = {(char)n, '\0'};
mb25_string_alloc_init(STR_RESULT, chr_buf);
```

### 2.9 PRINT Statement

**BASIC:** `PRINT A$`

**Generated C:**
```c
char *str = mb25_to_c_string(STR_A);
if (str) {
    printf("%s", str);
    free(str);
}
```

### 2.10 String Arrays

**BASIC:** `DIM NAMES$(10)`

**Generated C:**
```c
/* String IDs STR_NAMES_0 through STR_NAMES_9 already allocated */
/* Initialize them as empty */
for (int i = STR_NAMES_0; i <= STR_NAMES_9; i++) {
    mb25_string_clear(i);
}
```

**BASIC:** `NAMES$(5) = "John"`

**Generated C:**
```c
mb25_string_alloc_const(STR_NAMES_0 + 5, "John");
```

## 3. Memory Management

### 3.1 Initialization

At program start:
```c
int main(void) {
    /* Initialize string pool using all available memory */
    {
        extern unsigned char __BSS_tail;
        uint16_t _sp;
        #asm
        ld hl, 0
        add hl, sp
        ld (__sp), hl
        #endasm
        uint16_t _pool_size = _sp - 1024 - (uint16_t)&__BSS_tail;
        if (mb25_init((uint8_t *)&__BSS_tail, _pool_size) != MB25_SUCCESS) {
            fprintf(stderr, "Out of memory\n");
            return 1;
        }
    }

    /* Main program */
    /* ... */

    return 0;
}
```

### 3.2 Garbage Collection

GC happens automatically when allocation fails. The compiler doesn't need to generate GC calls, but can optionally do so at strategic points:

```c
/* Optional: Force GC at a convenient time */
if (mb25_gc_needed()) {
    mb25_garbage_collect();
}
```

### 3.3 Error Handling

Most operations return `mb25_error_t`. For robust programs:

```c
mb25_error_t err = mb25_string_concat(STR_RESULT, STR_A, STR_B);
if (err == MB25_ERR_OUT_OF_MEMORY) {
    /* Handle "Out of string space" error */
    fprintf(stderr, "?Out of string space\n");
    goto error_handler;
}
```

## 4. String Semantics

### 4.1 Empty Strings
- Uninitialized strings are empty (len=0, data=NULL)
- Empty string in expressions = ""
- LEN("") = 0

### 4.2 Maximum Length
- All strings limited to 255 characters (BASIC limitation)
- Operations that exceed 255 are truncated

### 4.3 String Sharing
- Substring operations create shared references
- Shared strings are marked non-writeable
- Modification triggers copy-on-write (transparent)

### 4.4 Constant Strings
- String literals point to program memory
- No pool allocation
- Automatically copied to pool if modified

## 5. Optimization Opportunities

### 5.1 Temporary Reuse
Temporaries can be reused within a statement:
```c
/* A$ = B$ + C$ + D$ */
mb25_string_concat(STR_TEMP_1, STR_B, STR_C);
mb25_string_concat(STR_A, STR_TEMP_1, STR_D);
/* STR_TEMP_1 can be reused in next statement */
```

### 5.2 Common Subexpression Elimination
If the same substring appears multiple times:
```basic
10 A$ = LEFT$(X$, 5)
20 B$ = LEFT$(X$, 5)  ' Same as line 10
```
Could share the same result (both point to same substring).

### 5.3 Dead String Elimination
Strings that are never used can be optimized away:
```basic
10 TEMP$ = A$ + B$  ' If TEMP$ never used again, skip allocation
```

## 6. Example: Complete Program Translation

**BASIC Program:**
```basic
10 INPUT "Name: ", NAME$
20 INPUT "City: ", CITY$
30 RESULT$ = NAME$ + ", " + CITY$
40 PRINT "Hello "; LEFT$(RESULT$, 10)
50 END
```

**Generated C:**
```c
#define MB25_NUM_STRINGS 6  /* NAME$, CITY$, RESULT$, 3 temps */
#define MB25_POOL_SIZE 1024

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "mb25_string.h"

#define STR_NAME   0
#define STR_CITY   1
#define STR_RESULT 2
#define STR_TEMP_1 3
#define STR_TEMP_2 4
#define STR_TEMP_3 5

int main(void) {
    char input_buffer[256];
    char *temp_str;

    /* Initialize string pool using all available memory */
    {
        extern unsigned char __BSS_tail;
        uint16_t _sp;
        #asm
        ld hl, 0
        add hl, sp
        ld (__sp), hl
        #endasm
        uint16_t _pool_size = _sp - 1024 - (uint16_t)&__BSS_tail;
        if (mb25_init((uint8_t *)&__BSS_tail, _pool_size) != MB25_SUCCESS) {
            fprintf(stderr, "?Out of memory\n");
            return 1;
        }
    }

    /* Line 10: INPUT "Name: ", NAME$ */
    printf("Name: ");
    if (fgets(input_buffer, 256, stdin)) {
        size_t len = strlen(input_buffer);
        if (len > 0 && input_buffer[len-1] == '\n') {
            input_buffer[len-1] = '\0';
        }
        mb25_string_alloc_init(STR_NAME, input_buffer);
    }

    /* Line 20: INPUT "City: ", CITY$ */
    printf("City: ");
    if (fgets(input_buffer, 256, stdin)) {
        size_t len = strlen(input_buffer);
        if (len > 0 && input_buffer[len-1] == '\n') {
            input_buffer[len-1] = '\0';
        }
        mb25_string_alloc_init(STR_CITY, input_buffer);
    }

    /* Line 30: RESULT$ = NAME$ + ", " + CITY$ */
    mb25_string_alloc_const(STR_TEMP_1, ", ");
    mb25_string_concat(STR_TEMP_2, STR_NAME, STR_TEMP_1);
    mb25_string_concat(STR_RESULT, STR_TEMP_2, STR_CITY);

    /* Line 40: PRINT "Hello "; LEFT$(RESULT$, 10) */
    printf("Hello ");
    mb25_string_left(STR_TEMP_3, STR_RESULT, 10);
    temp_str = mb25_to_c_string(STR_TEMP_3);
    if (temp_str) {
        printf("%s", temp_str);
        free(temp_str);
    }
    printf("\n");

    /* Line 50: END */
    /* No cleanup needed - pool memory is from BSS to stack */
    return 0;
}
```

## 7. Testing and Validation

The compiler should generate test cases that verify:
1. String operations produce correct results
2. Memory is properly managed (no leaks)
3. Garbage collection maintains program correctness
4. Edge cases (empty strings, max length) work
5. String sharing is preserved

## 8. Summary

The string system provides:
- **Automatic memory management** with O(n log n) GC
- **Transparent string sharing** for memory efficiency
- **Copy-on-write** for shared strings
- **Constant string optimization** to avoid heap use
- **Full BASIC semantics** maintained

The compiler needs to:
1. Count strings at compile time
2. Assign unique IDs to each string
3. Generate appropriate runtime calls
4. Handle temporaries for complex expressions
5. Initialize and cleanup the runtime

This system eliminates the O(nÂ²) performance problem of original MBASIC while providing better memory efficiency through sharing and constant optimization.